diff --git a/.gitignore b/.gitignore
index 50a237cf..1c5c81ef 100755
--- a/.gitignore
+++ b/.gitignore
@@ -31,3 +31,5 @@ extlib/portablexdr-4.9.1/configure
 /java
 /install-*
 /.idea/uda.iml
+/.vscode
+/.devcontainer
diff --git a/.gitlab-ci.yml b/.gitlab-ci.yml
index 242c3334..09f4a1e0 100644
--- a/.gitlab-ci.yml
+++ b/.gitlab-ci.yml
@@ -8,7 +8,7 @@ build:
   # instead of calling g++ directly you can also use some build toolkit like make
   # install the necessary build tools when needed
   before_script:
-    - apt update && apt -y install cmake python3-dev libssl-dev libboost-dev swig libxml2-dev pkg-config ninja-build
+    - apt update && apt -y install cmake python3-dev libssl-dev libboost-dev swig libxml2-dev pkg-config ninja-build libtirpc-dev
   script:
     - cmake -GNinja -Bbuild -H. -DCMAKE_INSTALL_PREFIX=. -DTARGET_TYPE=OTHER -DNO_MODULES=ON -DFAT_TESTS=ON
     - ninja -C build
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 66e1293e..bcb1d910 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -48,13 +48,13 @@ git_describe( GIT_TAG --tags )
 
 if( "${GIT_TAG}" MATCHES "^.*NOTFOUND$" )
   message( "Failed to get git revision: ${GIT_TAG}" )
-  set( GIT_TAG "0.0.0" )
-endif()
-
-# Strip off the SHA1 tag element if it exists
-string( REGEX REPLACE "^([0-9]+\\.[0-9]+\\.[0-9]+).*" "\\1" GIT_VERSION "${GIT_TAG}" )
-if( NOT "${GIT_VERSION}" MATCHES "[0-9]+\\.[0-9]+\\.[0-9]+" )
-  message( WARNING "invalid git tag for version parsing: ${GIT_VERSION}" )
+  set( GIT_VERSION "0.0.0" )
+elseif( "${GIT_TAG}" MATCHES "^([0-9]+\\.[0-9]+\\.[0-9]+)$" )
+  set( GIT_VERSION "${GIT_TAG}" )
+elseif( "${GIT_TAG}" MATCHES "^([0-9]+\\.[0-9]+\\.[0-9]+)-([0-9]+)-.*$" )
+  set( GIT_VERSION "${CMAKE_MATCH_1}.${CMAKE_MATCH_2}" )
+else()
+  message( WARNING "invalid git tag for version parsing: ${GIT_TAG}" )
   set( GIT_VERSION "0.0.0" )
 endif()
 
@@ -119,6 +119,7 @@ endif()
 
 add_definitions(
   -DOSTYPE=${CMAKE_SYSTEM_NAME}
+  -DUDA_EXPORT
 )
 
 if( WIN32 OR MINGW )
@@ -161,7 +162,7 @@ if( SERVER_ONLY )
 endif()
 
 if( NOT CLIENT_ONLY AND NOT BUILD_SHARED_LIBS )
-  message( FATAL_ERROR "cannot compile client AND server when BUILD_SHARED_LIBS is not setted" )
+  message( FATAL_ERROR "cannot compile client AND server when BUILD_SHARED_LIBS is not set" )
 endif()
 
 if( SSLAUTHENTICATION )
diff --git a/cmake/Modules/FindLevelDB.cmake b/cmake/Modules/FindLevelDB.cmake
index dffaae04..42a8e5c3 100755
--- a/cmake/Modules/FindLevelDB.cmake
+++ b/cmake/Modules/FindLevelDB.cmake
@@ -1,28 +1,28 @@
 # - Find LevelDB
 #
 # To provide the module with a hint about where to find your LevelDB
-# installation, you can set the environment variable LEVELDB_ROOT. The
+# installation, you can set the environment variable LevelDB_ROOT. The
 # Find module will then look in this path when searching for LevelDB paths
 # and libraries.
 #
 # Find the LevelDB includes and libraries
 #
-#  LEVELDB_INCLUDE_DIR - where to find mdslib.h, etc
-#  LEVELDB_LIBRARIES   - Link these libraries when using LevelDB
-#  LEVELDB_FOUND       - True if LevelDB found
+#  LevelDB_INCLUDE_DIR - where to find mdslib.h, etc
+#  LevelDB_LIBRARIES   - Link these libraries when using LevelDB
+#  LevelDB_FOUND       - True if LevelDB found
 #
 # Normal usage would be:
 #  find_package (LevelDB REQUIRED)
-#  target_link_libraries (uses_LevelDB ${LEVELDB_LIBRARIES})
+#  target_link_libraries (uses_LevelDB ${LevelDB_LIBRARIES})
 
-if( LEVELDB_INCLUDE_DIR AND LEVELDB_LIBRARIES )
+if( LevelDB_INCLUDE_DIR AND LevelDB_LIBRARIES )
   # Already in cache, be silent
-  set( LEVELDB_FIND_QUIETLY TRUE )
-endif( LEVELDB_INCLUDE_DIR AND LEVELDB_LIBRARIES )
+  set( LevelDB_FIND_QUIETLY TRUE )
+endif( LevelDB_INCLUDE_DIR AND LevelDB_LIBRARIES )
 
-find_path( LEVELDB_INCLUDE_DIR leveldb/db.h
-  HINTS ${LEVELDB_ROOT}
-    ENV LEVELDB_DIR
+find_path( LevelDB_INCLUDE_DIR leveldb/db.h
+  HINTS ${LevelDB_ROOT}
+    ENV LevelDB_DIR
   PATHS
     /usr/local
     /opt/local
@@ -30,9 +30,9 @@ find_path( LEVELDB_INCLUDE_DIR leveldb/db.h
     /usr/lib/sfw
   PATH_SUFFIXES include )
 
-find_library( LEVELDB_LIBRARIES NAMES leveldb
-  HINTS ${LEVELDB_ROOT}
-    ENV LEVELDB_DIR
+find_library( LevelDB_LIBRARIES NAMES leveldb
+  HINTS ${LevelDB_ROOT}
+    ENV LevelDB_DIR
   PATHS
     /opt/local
     /sw
@@ -41,6 +41,6 @@ find_library( LEVELDB_LIBRARIES NAMES leveldb
   PATH_SUFFIXES lib lib64 )
 
 include( FindPackageHandleStandardArgs )
-find_package_handle_standard_args( LEVELDB DEFAULT_MSG LEVELDB_LIBRARIES LEVELDB_INCLUDE_DIR )
+find_package_handle_standard_args( LevelDB DEFAULT_MSG LevelDB_LIBRARIES LevelDB_INCLUDE_DIR )
 
-mark_as_advanced( LEVELDB_LIBRARIES LEVELDB_INCLUDE_DIR )
+mark_as_advanced( LevelDB_LIBRARIES LevelDB_INCLUDE_DIR )
diff --git a/cmake/Modules/FindTIRPC.cmake b/cmake/Modules/FindTIRPC.cmake
new file mode 100644
index 00000000..095e685e
--- /dev/null
+++ b/cmake/Modules/FindTIRPC.cmake
@@ -0,0 +1,51 @@
+# - Find TIRPC
+#
+# To provide the module with a hint about where to find your TIRPC
+# installation, you can set the environment variable TIRPC_ROOT. The
+# Find module will then look in this path when searching for TIRPC paths
+# and libraries.
+#
+# Find the TIRPC includes and libraries
+#
+#  TIRPC_INCLUDE_DIR - where to find mdslib.h, etc
+#  TIRPC_LIBRARIES   - Link these libraries when using TIRPC
+#  TIRPC_FOUND       - True if TIRPC found
+#
+# Normal usage would be:
+#  find_package (TIRPC REQUIRED)
+#  target_link_libraries (uses_TIRPC ${TIRPC_LIBRARIES})
+
+if( TIRPC_INCLUDE_DIR AND TIRPC_LIBRARIES )
+  # Already in cache, be silent
+  set( TIRPC_FIND_QUIETLY TRUE )
+endif( TIRPC_INCLUDE_DIR AND TIRPC_LIBRARIES )
+
+find_package(PkgConfig)
+
+pkg_search_module(TIRPC libtirpc QUIET )
+
+if(${TIRPC_FOUND})
+  SET(TIRPC_LIBRARIES ${TIRPC_LIBRARIES})      
+  SET(TIRPC_INCLUDE_DIR ${TIRPC_INCLUDEDIR}/tirpc)
+
+else()
+  find_path(TIRPC_INCLUDE_DIR rpc/xdr.h
+        HINTS
+          ${TIRPC_ROOT}
+        extlib
+          ENV TIRPC_ROOT           
+          ENV EBROOTLIBTIRPC         
+        PATH_SUFFIXES include include/rpc )
+  find_library( TIRPC_LIBRARIES NAMES tirpc 
+        HINTS
+          ${TIRPC_ROOT}
+        extlib
+          ENV TIRPC_ROOT
+          ENV EBROOTLIBTIRPC
+        PATH_SUFFIXES lib lib64 )          
+endif()
+
+include( FindPackageHandleStandardArgs )
+find_package_handle_standard_args( TIRPC DEFAULT_MSG TIRPC_LIBRARIES TIRPC_INCLUDE_DIR )
+
+mark_as_advanced( TIRPC_LIBRARIES TIRPC_INCLUDE_DIR )
diff --git a/cmake/plugins.cmake b/cmake/plugins.cmake
index 867a8dc0..14400538 100755
--- a/cmake/plugins.cmake
+++ b/cmake/plugins.cmake
@@ -88,9 +88,11 @@ macro( uda_plugin )
   if( WIN32 OR MINGW )
     if( MINGW )
       set( LIBRARIES ${LIBRARIES} ${XDR_LIBRARIES} dl stdc++ )
-	else()
-      set( LIBRARIES ${LIBRARIES} ${XDR_LIBRARIES} dlfcn-win32::dl )
-	endif()
+    else()
+        set( LIBRARIES ${LIBRARIES} ${XDR_LIBRARIES} dlfcn-win32::dl )
+    endif()
+  elseif(TIRPC_FOUND)
+    set( LINK_LIB ${LINK_LIB} ${TIRPC_LIBRARIES})
   else()
     set( LIBRARIES ${LIBRARIES} dl stdc++ )
   endif()
diff --git a/scripts/cmake-freia.sh b/scripts/cmake-freia.sh
index 41dcd031..a75bf393 100755
--- a/scripts/cmake-freia.sh
+++ b/scripts/cmake-freia.sh
@@ -4,7 +4,6 @@ module purge
 module load idl/08.3
 module load mdsplus/6.1
 module load java/1.8
-module load udunits/2.2.24
 module load ida
 module load hdf5-C/1.8.13
 module load netcdf-C/4.3.2
@@ -14,8 +13,9 @@ export BOOST_ROOT=/usr/local/depot/boost-1.60
 export CPLUS_INCLUDE_PATH=/usr/include/libxml2:$CPLUS_INCLUDE_PATH
 export C_INCLUDE_PATH=/usr/include/libxml2:$C_INCLUDE_PATH
 
-CC=gcc CXX=g++ cmake3 -Bbuild_freia -H. -DCMAKE_BUILD_TYPE=Debug \
+CC=gcc CXX=g++ cmake3 -Bbuild_freia -H. \
+    -DCMAKE_BUILD_TYPE=Debug \
     -DCMAKE_INSTALL_PREFIX=/projects/UDA/uda-install-develop \
     -DLIBMEMCACHED_ROOT=/common/projects/UDA/libmemcached \
-    -DUDUNITS_ROOT=$UDUNITS_DIR -DBUILD_SHARED_LIBS=ON \
+    -DBUILD_SHARED_LIBS=ON \
     $*
diff --git a/scripts/cmake-itm-marconi-gcc-4.sh b/scripts/cmake-itm-marconi-gcc-4.sh
new file mode 100755
index 00000000..4e565862
--- /dev/null
+++ b/scripts/cmake-itm-marconi-gcc-4.sh
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+module ()
+{
+    eval `/usr/bin/modulecmd bash $*`
+}
+
+module purge
+module load cineca
+module load itmenv
+module unload gnu
+
+export CC=gcc
+export CXX=g++
+export BOOST_ROOT=$HOME/boost_1_62_0
+
+cmake -Bbuild-gcc-4 -H. -DCMAKE_BUILD_TYPE=Debug \
+    -DCMAKE_INSTALL_PREFIX=/gw/swimas/extra/uda/2.3.1/gcc/4.8.5 \
+    -DBUILD_SHARED_LIBS=ON \
+    -DBUILD_PLUGINS=help\;uda $*
diff --git a/scripts/cmake-itm-marconi-gcc-6.sh b/scripts/cmake-itm-marconi-gcc-6.sh
new file mode 100755
index 00000000..7f9675a3
--- /dev/null
+++ b/scripts/cmake-itm-marconi-gcc-6.sh
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+module ()
+{
+    eval `/usr/bin/modulecmd bash $*`
+}
+
+module purge
+module load cineca
+module load itmenv
+
+export CC=gcc
+export CXX=g++
+export BOOST_ROOT=$HOME/boost_1_62_0
+
+cmake -Bbuild-gcc-6 -H. -DCMAKE_BUILD_TYPE=Debug \
+    -DCMAKE_INSTALL_PREFIX=/gw/swimas/extra/uda/2.3.1/gcc/6.1.0 \
+    -DBUILD_SHARED_LIBS=ON \
+    -DBUILD_PLUGINS=help\;uda $*
diff --git a/scripts/cmake-itm-marconi-gcc-7.sh b/scripts/cmake-itm-marconi-gcc-7.sh
new file mode 100755
index 00000000..6adefb0b
--- /dev/null
+++ b/scripts/cmake-itm-marconi-gcc-7.sh
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+module ()
+{
+    eval `/usr/bin/modulecmd bash $*`
+}
+
+module purge
+module load cineca
+module load itmenv
+module unload gnu
+module load gnu/7.3.0
+
+export CC=gcc
+export CXX=g++
+export BOOST_ROOT=$HOME/boost_1_62_0
+
+cmake -Bbuild-gcc-7 -H. -DCMAKE_BUILD_TYPE=Debug \
+    -DCMAKE_INSTALL_PREFIX=/gw/swimas/extra/uda/2.3.1/gcc/7.3.0 \
+    -DBUILD_SHARED_LIBS=ON \
+    -DBUILD_PLUGINS=help\;uda $*
diff --git a/scripts/cmake-itm-marconi.sh b/scripts/cmake-itm-marconi.sh
deleted file mode 100755
index d4136fd9..00000000
--- a/scripts/cmake-itm-marconi.sh
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-
-module ()
-{
-    eval `/usr/bin/modulecmd bash $*`
-}
-
-module purge
-module load cineca
-module load itmenv
-#module load boost/1.61.0--intelmpi--2017--binary
-
-export CC=gcc
-export CXX=g++
-export BOOST_ROOT=$HOME/boost_1_62_0
-
-cmake -Bbuild -H. -DCMAKE_BUILD_TYPE=Debug -DTARGET_TYPE=OTHER \
-    -DNO_MODULES=ON \
-    -DSWIG_EXECUTABLE:FILEPATH=/afs/eufus.eu/user/g/g2jhollo/bin/swig \
-    -DCMAKE_INSTALL_PREFIX=/gw/swimas/extra/uda/develop \
-    -DBUILD_PLUGINS=help\;uda $*
diff --git a/scripts/cmake-shedu.sh b/scripts/cmake-shedu.sh
new file mode 100755
index 00000000..7de82b12
--- /dev/null
+++ b/scripts/cmake-shedu.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+module purge
+module load idl/08.3
+
+export CPLUS_INCLUDE_PATH=/usr/include/libxml2:$CPLUS_INCLUDE_PATH
+export C_INCLUDE_PATH=/usr/include/libxml2:$C_INCLUDE_PATH
+
+CC=gcc CXX=g++ cmake3 -Bbuild -H. -DCMAKE_BUILD_TYPE=Debug \
+  -DCMAKE_INSTALL_PREFIX=/root/sharepkg/U/uda/develop \
+  -DCLIENT_ONLY=TRUE \
+  -DBUILD_SHARED_LIBS=ON \
+  
diff --git a/source/CMakeLists.txt b/source/CMakeLists.txt
index a19e1bdf..11e3334f 100755
--- a/source/CMakeLists.txt
+++ b/source/CMakeLists.txt
@@ -11,6 +11,8 @@ endif()
 
 set( LOGGING_BACKEND "FILE" CACHE STRING "Choose logging backend [FILE;SYSLOG]" )
 
+include_directories( ${CMAKE_CURRENT_BINARY_DIR} )
+
 add_subdirectory( cache )
 add_subdirectory( logging )
 add_subdirectory( authentication )
@@ -27,7 +29,14 @@ if( NOT CLIENT_ONLY )
   add_subdirectory( plugins )
 endif()
 
-install( FILES uda.h DESTINATION include/uda )
+string( TIMESTAMP BUILD_TIMESTAMP UTC )
+configure_file(
+  ${CMAKE_SOURCE_DIR}/source/version.h.in
+  ${CMAKE_BINARY_DIR}/source/version.h
+  @ONLY
+)
+
+install( FILES uda.h ${CMAKE_BINARY_DIR}/source/version.h DESTINATION include/uda )
 
 set( ENV_PATH )
 if( WIN32 AND NOT MINGW )
diff --git a/source/authentication/CMakeLists.txt b/source/authentication/CMakeLists.txt
index 1307095e..41b991a3 100755
--- a/source/authentication/CMakeLists.txt
+++ b/source/authentication/CMakeLists.txt
@@ -2,23 +2,14 @@ find_package( OpenSSL REQUIRED )
 
 # Sources
 
-set( SRC_FILES
-  udaClientSSL.cpp
-  udaServerSSL.cpp
-)
-
-set( HEADER_FILES
-  udaSSL.h
-)
-
 include_directories(
   ${CMAKE_SOURCE_DIR}/source
   ${OPENSSL_INCLUDE_DIR}
 )
 
-add_library( authentication-client-objects OBJECT ${SRC_FILES} ${HEADER_FILES} )
+add_library( authentication-client-objects OBJECT udaClientSSL.cpp udaClientSSL.h udaServerSSL.h )
 
 if( NOT CLIENT_ONLY )
-  add_library( authentication-server-objects OBJECT ${SRC_FILES} ${HEADER_FILES} )
+  add_library( authentication-server-objects OBJECT udaServerSSL.cpp udaClientSSL.h )
   target_compile_definitions( authentication-server-objects PRIVATE -DSERVERBUILD )
 endif()
\ No newline at end of file
diff --git a/source/authentication/udaClientSSL.cpp b/source/authentication/udaClientSSL.cpp
index e59d0dbc..29b5526f 100755
--- a/source/authentication/udaClientSSL.cpp
+++ b/source/authentication/udaClientSSL.cpp
@@ -1,6 +1,6 @@
 #if defined(SSLAUTHENTICATION) && !defined(SERVERBUILD) && !defined(FATCLIENT)
 
-#include "udaSSL.h"
+#include "udaClientSSL.h"
 
 #include <stdio.h>
 #include <fcntl.h>
@@ -11,69 +11,36 @@
 #include <logging/logging.h>
 #include <client/udaClientHostList.h>
 
-static int sslDisabled = 1;         // Default state is not SSL authentication
-static int sslProtocol = 0;         // The default server host name has the SSL protocol name prefix or 
-static int sslSocket = -1;
-static int sslOK = 0;               // SSL Authentication has been passed sucessfully: default is NOT Passed
-static int sslGlobalInit = 0;       // Global initialisation of SSL completed
-static SSL* ssl = nullptr;
-static SSL_CTX* ctx = nullptr;
+static bool g_sslDisabled = true;   // Default state is not SSL authentication
+static int g_sslProtocol = 0;       // The default server host name has the SSL protocol name prefix or
+static int g_sslSocket = -1;
+static bool g_sslOK = false;        // SSL Authentication has been passed sucessfully: default is NOT Passed
+static bool g_sslInit = false;      // Global initialisation of SSL completed
+static SSL* g_ssl = nullptr;
+static SSL_CTX* g_ctx = nullptr;
 
-void putUdaClientSSLProtocol(int specified)
-{
-    sslProtocol = specified;
-}
-
-int getUdaClientSSLProtocol()
-{
-    return sslProtocol;
-}
-
-void putUdaClientSSLOK(int ok)
-{
-    sslOK = ok;
-}
-
-int getUdaClientSSLOK()
-{
-    return sslOK;
-}
-
-void putUdaClientSSLGlobalInit(int init)
-{
-    sslGlobalInit = init;
-}
-
-int getUdaClientSSLGlobalInit()
-{
-    return sslGlobalInit;
-}
-
-void putUdaClientSSLDisabled(int disabled)
+bool getUdaClientSSLDisabled()
 {
-    sslDisabled = disabled;
+    return g_sslDisabled;
 }
 
-int getUdaClientSSLDisabled()
+void putUdaClientSSLProtocol(int specified)
 {
-    return sslDisabled;
+    g_sslProtocol = specified;
 }
 
 void putUdaClientSSLSocket(int s)
 {
-    sslSocket = s;
-}
-
-int getUdaClientSSLSocket()
-{
-    return sslSocket;
+    g_sslSocket = s;
 }
 
 void initUdaClientSSL()
 {
-    if (getUdaClientSSLGlobalInit()) return;    // Already initialised
+    if (g_sslInit) {
+        return;    // Already initialised
+    }
     if (getenv("UDA_SSL_INITIALISED")) {
-        putUdaClientSSLGlobalInit(1);
+        g_sslInit = true;
         UDA_LOG(UDA_LOG_DEBUG, "Prior SSL initialisation\n");
         return;
     }
@@ -87,59 +54,52 @@ void initUdaClientSSL()
 #else
     setenv("UDA_SSL_INITIALISED", "1", 0);
 #endif
-    putUdaClientSSLGlobalInit(1);
+    g_sslInit = true;
     UDA_LOG(UDA_LOG_DEBUG, "SSL initialised\n");
 }
 
 void closeUdaClientSSL()
-{            // Requires re-initialisation
-    if (getUdaClientSSLDisabled()) return;
-    putUdaClientSSLOK(0);
-    putUdaClientSSLSocket(-1);
-    putUdaClientSSLProtocol(0);
-    putUdaClientSSLDisabled(1);
-    SSL* ssl = getUdaClientSSL();
-    SSL_CTX* ctx = getUdaClientSSLCTX();
+{
+    // Requires re-initialisation
+    if (g_sslDisabled) {
+        return;
+    }
+    g_sslOK = false;
+    g_sslSocket = -1;
+    g_sslProtocol = 0;
+    g_sslDisabled = true;
+    SSL* ssl = g_ssl;
     if (ssl != nullptr) {
         SSL_shutdown(ssl);
         SSL_free(ssl);
     }
-    if (ctx != nullptr) SSL_CTX_free(ctx);
+    SSL_CTX* ctx = g_ctx;
+    if (ctx != nullptr) {
+        SSL_CTX_free(ctx);
+    }
     EVP_cleanup();
-    putUdaClientSSL(nullptr);
-    putUdaClientSSLCTX(nullptr);
+    g_ssl = nullptr;
+    g_ctx = nullptr;
 #ifdef _WIN32
     _putenv_s("UDA_SSL_INITIALISED", nullptr);
 #else
     unsetenv("UDA_SSL_INITIALISED");
 #endif
-    putUdaClientSSLGlobalInit(0);
+    g_sslInit = false;
     UDA_LOG(UDA_LOG_DEBUG, "SSL closed\n");
 }
 
-void putUdaClientSSL(SSL* s)
-{
-    ssl = s;
-    return;
-}
-
 SSL* getUdaClientSSL()
 {
-    return ssl;
+    return g_ssl;
 }
 
 void putUdaClientSSLCTX(SSL_CTX* c)
 {
-    ctx = c;
-    return;
+    g_ctx = c;
 }
 
-SSL_CTX* getUdaClientSSLCTX()
-{
-    return ctx;
-}
-
-void getUdaClientSSLErrorCode(int rc)
+void reportSSLErrorCode(int rc)
 {
     int err = SSL_get_error(getUdaClientSSL(), rc);
     char msg[256];
@@ -172,30 +132,23 @@ void getUdaClientSSLErrorCode(int rc)
             strcpy(msg, "SSL_ERROR_SSL");
             break;
     }
-    err = 999;
-    addIdamError(CODEERRORTYPE, "udaSSL", err, msg);
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: Error - %s\n", msg);
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: Error - %s\n", ERR_error_string(ERR_get_error(), nullptr));
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: State - %s\n", SSL_state_string(getUdaClientSSL()));
+    ADD_ERROR(999, msg);
+    UDA_LOG(UDA_LOG_DEBUG, "Error - %s\n", msg);
+    UDA_LOG(UDA_LOG_DEBUG, "Error - %s\n", ERR_error_string(ERR_get_error(), nullptr));
+    UDA_LOG(UDA_LOG_DEBUG, "State - %s\n", SSL_state_string(getUdaClientSSL()));
 }
 
 SSL_CTX* createUdaClientSSLContext()
 {
-    int err = 0;
-
-    const SSL_METHOD* method;
-    SSL_CTX* ctx;
-
-    method = SSLv23_client_method();        // standard TCP
+    const SSL_METHOD* method = SSLv23_client_method(); // standard TCP
 
-    // method = DTLSv1_client_method()		// reliable UDP
+    // method = DTLSv1_client_method()// reliable UDP
 
-    ctx = SSL_CTX_new(method);
+    SSL_CTX* ctx = SSL_CTX_new(method);
     putUdaClientSSLCTX(ctx);
 
     if (!ctx) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to create SSL context");
+        ADD_ERROR(999, "Unable to create SSL context");
         return nullptr;
     }
 
@@ -205,7 +158,7 @@ SSL_CTX* createUdaClientSSLContext()
 
 /*
 // Set the Cipher List 
-   if (SSL_CTX_set_cipher_list(ctx, "AES128-SHA") <= 0) {
+   if (SSL_CTX_set_cipher_list(g_ctx, "AES128-SHA") <= 0) {
       printf("Error setting the cipher list.\n");
       exit(0);
    }    
@@ -218,256 +171,226 @@ SSL_CTX* createUdaClientSSLContext()
 
 int configureUdaClientSSLContext()
 {
-    int err = 0;
-
-    SSL_CTX* ctx = getUdaClientSSLCTX();
-
-    //SSL_CTX_set_ecdh_auto(ctx, 1);
+    //SSL_CTX_set_ecdh_auto(g_ctx, 1);
 
     // Set the key and cert - these take priority over entries in the host configuration file
 
-    char* cert = getenv("UDA_CLIENT_SSL_CERT");
-    char* key = getenv("UDA_CLIENT_SSL_KEY");
-    char* ca = getenv("UDA_CLIENT_CA_SSL_CERT");
+    const char* cert = getenv("UDA_CLIENT_SSL_CERT");
+    const char* key = getenv("UDA_CLIENT_SSL_KEY");
+    const char* ca = getenv("UDA_CLIENT_CA_SSL_CERT");
 
-    if (!cert || !key || !ca) {        // Check the client hosts configuration file
+    if (!cert || !key || !ca) {
+        // Check the client hosts configuration file
         int hostId = -1;
-        if ((hostId = udaClientGetHostNameId()) >= 0) {    // Socket connection was opened with a host entry in the configuration file
-            if (!cert) cert = udaClientGetHostCertificatePath(hostId);
-            if (!key) key = udaClientGetHostKeyPath(hostId);
-            if (!ca) ca = udaClientGetHostCAPath(hostId);
-            UDA_LOG(UDA_LOG_DEBUG, "SSL certificates and private key obtained from the hosts configuration file. Host id = %d\n", hostId);
+        if ((hostId = udaClientGetHostNameId()) >= 0) {
+            // Socket connection was opened with a host entry in the configuration file
+            if (!cert) {
+                cert = udaClientGetHostCertificatePath(hostId);
+            }
+            if (!key) {
+                key = udaClientGetHostKeyPath(hostId);
+            }
+            if (!ca) {
+                ca = udaClientGetHostCAPath(hostId);
+            }
+            UDA_LOG(UDA_LOG_DEBUG,
+                    "SSL certificates and private key obtained from the hosts configuration file. Host id = %d\n",
+                    hostId);
         }
         if (!cert || !key || !ca || cert[0] == '\0' || key[0] == '\0' || ca[0] == '\0') {
-            err = 999;
             if (!cert || cert[0] == '\0') {
                 UDA_LOG(UDA_LOG_DEBUG, "No Client SSL certificate\n");
-                addIdamError(CODEERRORTYPE, "udaClientSSL", err, "No client SSL certificate!");
+                ADD_ERROR(999, "No client SSL certificate!");
             }
-            if (!key || key[0] == '\0'){
+            if (!key || key[0] == '\0') {
                 UDA_LOG(UDA_LOG_DEBUG, "No Client Private Key\n");
-                addIdamError(CODEERRORTYPE, "udaClientSSL", err, "No client SSL key!");
+                ADD_ERROR(999, "No client SSL key!");
             }
             if (!ca || ca[0] == '\0') {
-               UDA_LOG(UDA_LOG_DEBUG, "No CA SSL certificate\n");
-               addIdamError(CODEERRORTYPE, "udaClientSSL", err, "No Certificate Authority certificate!");
+                UDA_LOG(UDA_LOG_DEBUG, "No CA SSL certificate\n");
+                ADD_ERROR(999, "No Certificate Authority certificate!");
             }
             UDA_LOG(UDA_LOG_DEBUG, "Error: No SSL certificates and/or private key!\n");
-            return err;
+            return 999;
         }
     }
 
     UDA_LOG(UDA_LOG_DEBUG, "Client SSL certificates: %s\n", cert);
     UDA_LOG(UDA_LOG_DEBUG, "Client SSL key: %s\n", key);
     UDA_LOG(UDA_LOG_DEBUG, "CA SSL certificates: %s\n", ca);
- 
-    if (SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM) <= 0) {
-        err = 999;
+
+    if (SSL_CTX_use_certificate_file(g_ctx, cert, SSL_FILETYPE_PEM) <= 0) {
         UDA_LOG(UDA_LOG_DEBUG, "Error: Failed to set the client certificate!\n");
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "Failed to set the client certificate!");
-        return err;
+        THROW_ERROR(999, "Failed to set the client certificate!");
     }
 
-    if (SSL_CTX_use_PrivateKey_file(ctx, key, SSL_FILETYPE_PEM) <= 0) {
-        err = 999;
+    if (SSL_CTX_use_PrivateKey_file(g_ctx, key, SSL_FILETYPE_PEM) <= 0) {
         UDA_LOG(UDA_LOG_DEBUG, "Error: Failed to set the client key!\n");
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "Failed to set the client key!");
-        return err;
+        THROW_ERROR(999, "Failed to set the client key!");
     }
 
-    // Check key and certificate match 
-
-    if (SSL_CTX_check_private_key(ctx) == 0) {
-        err = 999;
+    // Check key and certificate match
+    if (SSL_CTX_check_private_key(g_ctx) == 0) {
         UDA_LOG(UDA_LOG_DEBUG, "Error: Private key does not match the certificate public key!\n");
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err,
-                     "Private key does not match the certificate public key!");
-        return err;
+        THROW_ERROR(999, "Private key does not match the certificate public key!");
     }
 
-    // Load certificates of trusted CAs based on file provided 
-
-    if (SSL_CTX_load_verify_locations(ctx, ca, nullptr) < 1) {
-        err = 999;
-        UDA_LOG(UDA_LOG_DEBUG, "Error: Error setting the Cetificate Authority verify locations!\n");
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err,
-                     "Error setting the Cetificate Authority verify locations!");
-        return err;
+    // Load certificates of trusted CAs based on file provided
+    if (SSL_CTX_load_verify_locations(g_ctx, ca, nullptr) < 1) {
+        UDA_LOG(UDA_LOG_DEBUG, "Error: Error setting the certificate authority verify locations!\n");
+        THROW_ERROR(999, "Error setting the certificate authority verify locations!");
     }
 
     // Peer certificate verification
+    SSL_CTX_set_verify(g_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
+    SSL_CTX_set_verify_depth(g_ctx, VERIFY_DEPTH);
 
-    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
-    SSL_CTX_set_verify_depth(ctx, VERIFY_DEPTH);
-
-    UDA_LOG(UDA_LOG_DEBUG, "configureUdaClientSSLContext: SSL Context configured\n");
+    UDA_LOG(UDA_LOG_DEBUG, "SSL context configured\n");
 
     // validate the client's certificate
-
-    FILE *fd = fopen(cert, "r");
+    FILE* fd = fopen(cert, "r");
 
     if (!fd) {
-        err = 999;
-	UDA_LOG(UDA_LOG_DEBUG, "Unable to open client certificate [%s] to verify certificate validity\n", cert);
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "Unable to open client certificate to verify certificate validity!");	
-        return err;
+        UDA_LOG(UDA_LOG_DEBUG, "Unable to open client certificate [%s] to verify certificate validity\n", cert);
+        THROW_ERROR(999, "Unable to open client certificate to verify certificate validity!");
     }
 
-    X509 *clientCert = PEM_read_X509(fd, nullptr, nullptr, nullptr);
+    X509* clientCert = PEM_read_X509(fd, nullptr, nullptr, nullptr);
 
     fclose(fd);
 
     if (!clientCert) {
         X509_free(clientCert);
-        err = 999;
-	UDA_LOG(UDA_LOG_DEBUG, "Unable to parse client certificate [%s] to verify certificate validity\n", cert);
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "Unable to parse client certificate [%s] to verify certificate validity");	
-        return err;
+        UDA_LOG(UDA_LOG_DEBUG, "Unable to parse client certificate [%s] to verify certificate validity\n", cert);
+        THROW_ERROR(999, "Unable to parse client certificate [%s] to verify certificate validity");
     }
 
-    const ASN1_TIME *before = X509_get_notBefore(clientCert);
-    const ASN1_TIME *after = X509_get_notAfter(clientCert);
+    const ASN1_TIME* before = X509_get_notBefore(clientCert);
+    const ASN1_TIME* after = X509_get_notAfter(clientCert);
 
     char work[X509STRINGSIZE];
     UDA_LOG(UDA_LOG_DEBUG, "Client X509 subject: %s\n",
-                  X509_NAME_oneline(X509_get_subject_name(clientCert), work, sizeof(work)));
+            X509_NAME_oneline(X509_get_subject_name(clientCert), work, sizeof(work)));
     UDA_LOG(UDA_LOG_DEBUG, "Client X509 issuer: %s\n",
-                  X509_NAME_oneline(X509_get_issuer_name(clientCert), work, sizeof(work)));
+            X509_NAME_oneline(X509_get_issuer_name(clientCert), work, sizeof(work)));
 
     time_t current_time = time(nullptr);
     char* c_time_string = ctime(&current_time);
 
-    int rc =0, count = 0;   
-    BIO *b = BIO_new(BIO_s_mem());
-    if (b &&  ASN1_TIME_print(b, before)){
-        count = BIO_read(b, work, X509STRINGSIZE-1);
+    int rc = 0, count = 0;
+    BIO* b = BIO_new(BIO_s_mem());
+    if (b && ASN1_TIME_print(b, before)) {
+        count = BIO_read(b, work, X509STRINGSIZE - 1);
         BIO_free(b);
     }
-    work[count]='\0';
+    work[count] = '\0';
     UDA_LOG(UDA_LOG_DEBUG, "Client X509 not before: %s\n", work);
-    if((rc = X509_cmp_time(before, &current_time)) >= 0){		// Not Before is after Now!
+    if ((rc = X509_cmp_time(before, &current_time)) >= 0) {
+        // Not Before is after Now!
         X509_free(clientCert);
         UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
         UDA_LOG(UDA_LOG_DEBUG, "Client X509 not before date is before the current date!\n");
-        UDA_LOG(UDA_LOG_DEBUG, "The client SSL/x509 certificate is Not Valid - the Vaidity Date is in the future!\n");  
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "The client SSL/x509 certificate is Not Valid - the Vaidity Date is in the future");
-        return err;
-    }   
+        UDA_LOG(UDA_LOG_DEBUG, "The client SSL/x509 certificate is Not Valid - the Vaidity Date is in the future!\n");
+        THROW_ERROR(999, "The client SSL/x509 certificate is Not Valid - the Vaidity Date is in the future");
+    }
 
     count = 0;
     b = BIO_new(BIO_s_mem());
-    if (b &&  ASN1_TIME_print(b, after)){
-        count = BIO_read(b, work, X509STRINGSIZE-1);
+    if (b && ASN1_TIME_print(b, after)) {
+        count = BIO_read(b, work, X509STRINGSIZE - 1);
         BIO_free(b);
     }
-    work[count]='\0';
+    work[count] = '\0';
     UDA_LOG(UDA_LOG_DEBUG, "Client X509 not after   : %s\n", work);
-    if((rc = X509_cmp_time(after, &current_time)) <= 0){		// Not After is before Now!
+    if ((rc = X509_cmp_time(after, &current_time)) <= 0) {// Not After is before Now!
         X509_free(clientCert);
         UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
         UDA_LOG(UDA_LOG_DEBUG, "Client X509 not after date is after the current date!\n");
-        UDA_LOG(UDA_LOG_DEBUG, "The client SSL/x509 certificate is Not Valid - the Date has Expired!\n");  
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaClientSSL", err, "The client SSL/x509 certificate is Not Valid - the Date has Expired!");
-        return err;
+        UDA_LOG(UDA_LOG_DEBUG, "The client SSL/x509 certificate is Not Valid - the Date has Expired!\n");
+        THROW_ERROR(999, "The client SSL/x509 certificate is Not Valid - the Date has Expired!");
     }
     X509_free(clientCert);
 
     UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
     UDA_LOG(UDA_LOG_DEBUG, "Cient certificate date validity checked but not validated \n");
 
-    return err;
+    return 0;
 }
 
 int startUdaClientSSL()
 {
-    int err = 0;
-    SSL_CTX* ctx = nullptr;
-
-// Has SSL/TLS authentication already been passed?
-
-    if (getUdaClientSSLOK()) return 0;
+    // Has SSL/TLS authentication already been passed?
+    if (g_sslOK) {
+        return 0;
+    }
 
-// Has the user specified the SSL protocol on the host URL?           
-// Has the user directly specified SSL/TLS authentication?
-// Does the connection entry in the client host configuration file have the three SSL authentication files
+    // Has the user specified the SSL protocol on the host URL?
+    // Has the user directly specified SSL/TLS authentication?
+    // Does the connection entry in the client host configuration file have the three SSL authentication files
 
-    if (!getUdaClientSSLProtocol() && !getenv("UDA_CLIENT_SSL_AUTHENTICATE")) {
-        putUdaClientSSLDisabled(1);
+    if (!g_sslProtocol && !getenv("UDA_CLIENT_SSL_AUTHENTICATE")) {
+        g_sslDisabled = true;
 
         int hostId = -1;
-         if ((hostId = udaClientGetHostNameId()) >= 0) {	// Socket connection was opened with a host entry in the configuration file
-            if(!udaClientGetHostSSL(hostId)){			// 3 files are Not present or SSL:// not specified
-               return 0;
+        if ((hostId = udaClientGetHostNameId()) >= 0) {
+            // Socket connection was opened with a host entry in the configuration file
+            if (!udaClientGetHostSSL(hostId)) {
+                // 3 files are Not present or SSL:// not specified
+                return 0;
             } else {
-                putUdaClientSSLDisabled(0);
+                g_sslDisabled = false;
             }
         } else {
             return 0;
         }
     } else {
-        putUdaClientSSLDisabled(0);
+        g_sslDisabled = false;
     }
 
     UDA_LOG(UDA_LOG_DEBUG, "SSL Authentication is Enabled!\n");
 
-// Initialise   
+    // Initialise
 
     initUdaClientSSL();
 
-    if (!(ctx = createUdaClientSSLContext())) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to create the SSL context!");
-        return err;
+    if (!(g_ctx = createUdaClientSSLContext())) {
+        THROW_ERROR(999, "Unable to create the SSL context!");
     }
     if (configureUdaClientSSLContext() != 0) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to configure the SSL context!");
-        return err;
+        THROW_ERROR(999, "Unable to configure the SSL context!");
     }
 
-// Bind an SSL object with the socket
-
-    SSL* ssl = SSL_new(ctx);
-    SSL_set_fd(ssl, getUdaClientSSLSocket());
+    // Bind an SSL object with the socket
 
-    putUdaClientSSL(ssl);
+    g_ssl = SSL_new(g_ctx);
+    SSL_set_fd(g_ssl, g_sslSocket);
 
-// Connect to the server
-
-    int rc = SSL_connect(ssl);
-
-// Check for error in connect 
-
-    if (rc < 1) {
+    // Connect to the server
+    int rc;
+    if ((rc = SSL_connect(g_ssl)) < 1) {
         UDA_LOG(UDA_LOG_DEBUG, "Error connecting to the server!\n");
-        err = 999;
         if (errno != 0) {
-            addIdamError(SYSTEMERRORTYPE, "udaSSL", errno, "Error connecting to the server!");
+            ADD_SYS_ERROR("Error connecting to the server!");
         }
-        getUdaClientSSLErrorCode(rc);
-        return err;
+        reportSSLErrorCode(rc);
+        return 999;
     }
 
-// Get the Server certificate and verify
+    // Get the Server certificate and verify
 
-    X509* peer = SSL_get_peer_certificate(ssl);
+    X509* peer = SSL_get_peer_certificate(g_ssl);
 
     if (peer != nullptr) {
 
-        if ((rc = SSL_get_verify_result(ssl)) !=
-            X509_V_OK) {    // returns X509_V_OK if the certificate was not obtained as no error occured!
-            err = 999;
-            addIdamError(CODEERRORTYPE, "udaSSL", err,
-                         "SSL Server certificate presented but verification error!");
-            addIdamError(CODEERRORTYPE, "udaSSL", err, X509_verify_cert_error_string(rc));
+        if ((rc = SSL_get_verify_result(g_ssl)) != X509_V_OK) {
+            // returns X509_V_OK if the certificate was not obtained as no error occurred!
+            ADD_ERROR(999, X509_verify_cert_error_string(rc));
             X509_free(peer);
             UDA_LOG(UDA_LOG_DEBUG, "SSL Server certificate presented but verification error!\n");
-            return err;
+            THROW_ERROR(999, "SSL Server certificate presented but verification error!");
         }
 
-// Server's details - not required apart from logging
+        // Server's details - not required apart from logging
 
         char work[X509STRINGSIZE];
         UDA_LOG(UDA_LOG_DEBUG, "Server certificate verified\n");
@@ -475,53 +398,50 @@ int startUdaClientSSL()
                 X509_NAME_oneline(X509_get_subject_name(peer), work, sizeof(work)));
         UDA_LOG(UDA_LOG_DEBUG, "X509 issuer: %s\n",
                 X509_NAME_oneline(X509_get_issuer_name(peer), work, sizeof(work)));
- 
-// Verify Date validity
 
-        const ASN1_TIME *before = X509_get_notBefore(peer);
-        const ASN1_TIME *after = X509_get_notAfter(peer);
+        // Verify Date validity
+
+        const ASN1_TIME* before = X509_get_notBefore(peer);
+        const ASN1_TIME* after = X509_get_notAfter(peer);
 
         time_t current_time = time(nullptr);
         char* c_time_string = ctime(&current_time);
 
-        int count = 0;   
-        BIO *b = BIO_new(BIO_s_mem());
-        if (b &&  ASN1_TIME_print(b, before)){
-            count = BIO_read(b, work, X509STRINGSIZE-1);
+        int count = 0;
+        BIO* b = BIO_new(BIO_s_mem());
+        if (b && ASN1_TIME_print(b, before)) {
+            count = BIO_read(b, work, X509STRINGSIZE - 1);
             BIO_free(b);
-        } 
-        work[count]='\0';
+        }
+        work[count] = '\0';
         UDA_LOG(UDA_LOG_DEBUG, "Server X509 not before: %s\n", work);
-        if((rc = X509_cmp_time(before, &current_time)) >= 0){		// Not Before is after Now!
+        if ((rc = X509_cmp_time(before, &current_time)) >= 0) {// Not Before is after Now!
             X509_free(peer);
             UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
             UDA_LOG(UDA_LOG_DEBUG, "Server X509 not before date is before the current date!\n");
-            UDA_LOG(UDA_LOG_DEBUG, "The Server's SSL/x509 certificate is Not Valid - the Vaidity Date is in the future!\n");  
-            err = 999;
-            addIdamError(CODEERRORTYPE, "udaClientSSL", err, "The Server's SSL/x509 certificate is Not Valid - the Vaidity Date is in the future");
-            return err;
-        }   
+            UDA_LOG(UDA_LOG_DEBUG,
+                    "The Server's SSL/x509 certificate is Not Valid - the Vaidity Date is in the future!\n");
+            THROW_ERROR(999, "The Server's SSL/x509 certificate is Not Valid - the Vaidity Date is in the future");
+        }
 
         count = 0;
         b = BIO_new(BIO_s_mem());
-        if (b &&  ASN1_TIME_print(b, after)){
-            count = BIO_read(b, work, X509STRINGSIZE-1);
+        if (b && ASN1_TIME_print(b, after)) {
+            count = BIO_read(b, work, X509STRINGSIZE - 1);
             BIO_free(b);
         }
-        work[count]='\0';
+        work[count] = '\0';
         UDA_LOG(UDA_LOG_DEBUG, "Server X509 not after   : %s\n", work);
-        if((rc = X509_cmp_time(after, &current_time)) <= 0){		// Not After is before Now!
+        if ((rc = X509_cmp_time(after, &current_time)) <= 0) {// Not After is before Now!
             X509_free(peer);
             UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
             UDA_LOG(UDA_LOG_DEBUG, "Server X509 not after date is after the current date!\n");
-            UDA_LOG(UDA_LOG_DEBUG, "The Server's SSL/x509 certificate is Not Valid - the Date has Expired!\n");  
-            err = 999;
-            addIdamError(CODEERRORTYPE, "udaClientSSL", err, "The Server's SSL/x509 certificate is Not Valid - the Date has Expired!");
-            return err;
+            UDA_LOG(UDA_LOG_DEBUG, "The Server's SSL/x509 certificate is Not Valid - the Date has Expired!\n");
+            THROW_ERROR(999, "The Server's SSL/x509 certificate is Not Valid - the Date has Expired!");
         }
 
         UDA_LOG(UDA_LOG_DEBUG, "Current Time               : %s\n", c_time_string);
- 
+
 /*      
       // Write the certificate to a tmp file
       char template[] = "/tmp/UDAServer-X509-XXXXXX";
@@ -529,39 +449,34 @@ int startUdaClientSSL()
       FILE *tmp = fopen(xname, "wb+");
       if(tmp){
          PEM_write_X509(tmp, peer);
-	 fclose(tmp);
+ fclose(tmp);
       }
 */
         X509_free(peer);
 
     } else {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err,
-                     "Server certificate not presented for verification!");
         X509_free(peer);
         UDA_LOG(UDA_LOG_DEBUG, "Server certificate not presented for verification!\n");
-        return err;
+        THROW_ERROR(999, "Server certificate not presented for verification!");
     }
 
-// Print out connection details 
+    // Print out connection details
 
-    UDA_LOG(UDA_LOG_DEBUG, "SSL version: %s\n", SSL_get_version(ssl));
-    UDA_LOG(UDA_LOG_DEBUG, "SSL cipher: %s\n", SSL_get_cipher(ssl));
+    UDA_LOG(UDA_LOG_DEBUG, "SSL version: %s\n", SSL_get_version(g_ssl));
+    UDA_LOG(UDA_LOG_DEBUG, "SSL cipher: %s\n", SSL_get_cipher(g_ssl));
 
-// SSL/TLS authentication has been passed - do not repeat
+    // SSL/TLS authentication has been passed - do not repeat
 
-    putUdaClientSSLOK(1);
+    g_sslOK = true;
 
     return 0;
 }
 
 int writeUdaClientSSL(void* iohandle, char* buf, int count)
 {
-
-//return SSL_write(getUdaClientSSL(), buf, count);
-
-// This routine is only called when there is something to write to the Server
-// SSL uses an all or nothing approach when the socket is blocking - an SSL error or incomplete write means the write has failed
+    // This routine is only called when there is something to write to the Server
+    // SSL uses an all or nothing approach when the socket is blocking - an SSL error or incomplete write
+    // means the write has failed
 
     int rc, err = 0;
 
@@ -570,10 +485,9 @@ int writeUdaClientSSL(void* iohandle, char* buf, int count)
 
     // Block till it's possible to write to the socket or timeout
 
-    idamUpdateSelectParms(getUdaClientSSLSocket(), &wfds, &tv);
-
-    while ((rc = select(getUdaClientSSLSocket() + 1, nullptr, &wfds, nullptr, &tv)) <= 0) {
+    udaUpdateSelectParms(g_sslSocket, &wfds, &tv);
 
+    while ((rc = select(g_sslSocket + 1, nullptr, &wfds, nullptr, &tv)) <= 0) {
         if (rc < 0) {    // Error
             if (errno == EBADF) {
                 UDA_LOG(UDA_LOG_DEBUG, "Socket is closed! Data access failed!.\n");
@@ -585,7 +499,7 @@ int writeUdaClientSSL(void* iohandle, char* buf, int count)
 
 #ifndef _WIN32
         int fopts = 0;
-        if ((rc = fcntl(getUdaClientSSLSocket(), F_GETFL, &fopts)) < 0 || errno == EBADF) {
+        if ((rc = fcntl(g_sslSocket, F_GETFL, &fopts)) < 0 || errno == EBADF) {
             // Is the socket closed? Check status flags
             err = 999;
             UDA_LOG(UDA_LOG_DEBUG, "Socket is closed!\n");
@@ -593,10 +507,10 @@ int writeUdaClientSSL(void* iohandle, char* buf, int count)
         }
 #endif
 
-        idamUpdateSelectParms(getUdaClientSSLSocket(), &wfds, &tv);
+        udaUpdateSelectParms(g_sslSocket, &wfds, &tv);
     }
 
-// set SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode to disable automatic renegotiation?
+    // set SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode to disable automatic renegotiation?
 
     rc = SSL_write(getUdaClientSSL(), buf, count);
 
@@ -611,13 +525,13 @@ int writeUdaClientSSL(void* iohandle, char* buf, int count)
             break;
 
         default:
-            getUdaClientSSLErrorCode(rc);
+            reportSSLErrorCode(rc);
             err = 999;
             UDA_LOG(UDA_LOG_DEBUG, "Write to socket failed!\n");
             addIdamError(CODEERRORTYPE, "writeUdaClientSSL", err, "Write to socket failed!");
 #ifndef _WIN32
             int fopts = 0;
-            if ((rc = fcntl(getUdaClientSSLSocket(), F_GETFL, &fopts)) < 0 ||
+            if ((rc = fcntl(g_sslSocket, F_GETFL, &fopts)) < 0 ||
                 errno == EBADF) {    // Is the socket closed? Check status flags
                 UDA_LOG(UDA_LOG_DEBUG, "Socket is closed!\n");
             }
@@ -626,15 +540,10 @@ int writeUdaClientSSL(void* iohandle, char* buf, int count)
     }
 
     return rc;
-
 }
 
 int readUdaClientSSL(void* iohandle, char* buf, int count)
 {
-
-//return SSL_read(getUdaClientSSL(), buf, count);
-
-
     int rc, err = 0;
     fd_set rfds;
     struct timeval tv;
@@ -643,9 +552,10 @@ int readUdaClientSSL(void* iohandle, char* buf, int count)
 
     // Wait till it's possible to read from socket 
 
-    idamUpdateSelectParms(getUdaClientSSLSocket(), &rfds, &tv);
+    udaUpdateSelectParms(g_sslSocket, &rfds, &tv);
 
-    while (((rc = select(getUdaClientSSLSocket() + 1, &rfds, nullptr, nullptr, &tv)) <= 0) && maxloop++ < MAXLOOP) {
+    while (((rc = select(g_sslSocket + 1, &rfds, nullptr, nullptr, &tv)) <= 0)
+            && maxloop++ < MAXLOOP) {
 
         if (rc < 0) {    // Error
             int serrno = errno;
@@ -664,7 +574,7 @@ int readUdaClientSSL(void* iohandle, char* buf, int count)
         }
 #ifndef _WIN32
         int fopts = 0;
-        if ((rc = fcntl(getUdaClientSSLSocket(), F_GETFL, &fopts)) < 0 ||
+        if ((rc = fcntl(g_sslSocket, F_GETFL, &fopts)) < 0 ||
             errno == EBADF) {    // Is the socket closed? Check status flags
             err = 999;
             UDA_LOG(UDA_LOG_DEBUG, "Socket is closed!\n");
@@ -672,7 +582,7 @@ int readUdaClientSSL(void* iohandle, char* buf, int count)
         }
 #endif
 
-        idamUpdateSelectParms(getUdaClientSSLSocket(), &rfds, &tv);        // Keep blocking and wait for data
+        udaUpdateSelectParms(g_sslSocket, &rfds, &tv);        // Keep blocking and wait for data
     }
 
 // First byte of encrypted data received but need the full record in buffer before SSL can decrypt
@@ -686,8 +596,8 @@ int readUdaClientSSL(void* iohandle, char* buf, int count)
             case SSL_ERROR_NONE:                // clean read
                 break;
 
-            case SSL_ERROR_ZERO_RETURN:    // connection closed by server 	(not caught by select?)
-                getUdaClientSSLErrorCode(rc);
+            case SSL_ERROR_ZERO_RETURN:    // connection closed by server (not caught by select?)
+                reportSSLErrorCode(rc);
                 err = 999;
                 UDA_LOG(UDA_LOG_DEBUG, "Server socket connection closed!\n");
                 addIdamError(CODEERRORTYPE, "readUdaClientSSL", err,
@@ -699,27 +609,27 @@ int readUdaClientSSL(void* iohandle, char* buf, int count)
                 break;
 
             case SSL_ERROR_WANT_WRITE:    //the operation did not complete, error
-                getUdaClientSSLErrorCode(rc);
+                reportSSLErrorCode(rc);
                 err = 999;
                 UDA_LOG(UDA_LOG_DEBUG, "A read operation failed!\n");
                 addIdamError(CODEERRORTYPE, "readUdaClientSSL", err, "A read operation failed!");
                 return -1;
 
             case SSL_ERROR_SYSCALL:    //some I/O error occured - disconnect?
-                getUdaClientSSLErrorCode(rc);
+                reportSSLErrorCode(rc);
                 err = 999;
                 UDA_LOG(UDA_LOG_DEBUG, "Socket read I/O error!\n");
                 addIdamError(CODEERRORTYPE, "readUdaClientSSL", err, "Socket read I/O error!");
                 return -1;
 
             default:            //some other error
-                getUdaClientSSLErrorCode(rc);
+                reportSSLErrorCode(rc);
                 err = 999;
                 UDA_LOG(UDA_LOG_DEBUG, "Read from socket failed!\n");
                 addIdamError(CODEERRORTYPE, "readUdaClientSSL", err, "Read from socket failed!");
 #ifndef _WIN32
                 int fopts = 0;
-                if ((rc = fcntl(getUdaClientSSLSocket(), F_GETFL, &fopts)) < 0 ||
+                if ((rc = fcntl(g_sslSocket, F_GETFL, &fopts)) < 0 ||
                     errno == EBADF) {    // Is the socket closed? Check status flags
                     UDA_LOG(UDA_LOG_DEBUG, "Socket is closed!\n");
                 }
diff --git a/source/authentication/udaClientSSL.h b/source/authentication/udaClientSSL.h
new file mode 100755
index 00000000..d4bfa143
--- /dev/null
+++ b/source/authentication/udaClientSSL.h
@@ -0,0 +1,43 @@
+#ifndef UDA_AUTHENTICATION_CLIENT_SSL_H
+#define UDA_AUTHENTICATION_CLIENT_SSL_H
+
+#if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
+
+// Create the SSL context and binding to the socket
+// 3 UDA protocol modes: TCP without SSL/TLS, TCP and UDP both with SSL/TLS
+// This set of functions is concerned only with the SSL/TLS protocol (authentication and encryption) - not with establishing socket connections or non SSL TCP transport
+
+// Server host addressed beginng with SSL:// are assumed to be using SSL authentication. The SSL:// prefix is removed to make the connection.
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/crypto.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
+
+#define VERIFY_DEPTH	4
+#define X509STRINGSIZE	256
+
+#include <clientserver/export.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+LIBRARY_API bool getUdaClientSSLDisabled();
+LIBRARY_API SSL *getUdaClientSSL();
+LIBRARY_API void putUdaClientSSLSocket(int s);
+LIBRARY_API void closeUdaClientSSL();
+LIBRARY_API void putUdaClientSSLProtocol(int specified);
+LIBRARY_API int startUdaClientSSL();
+LIBRARY_API int readUdaClientSSL(void* iohandle, char* buf, int count);
+LIBRARY_API int writeUdaClientSSL(void* iohandle, char* buf, int count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SSLAUTHENTICATION
+
+#endif // UDA_AUTHENTICATION_CLIENT_SSL_H
diff --git a/source/authentication/udaSSL.h b/source/authentication/udaSSL.h
deleted file mode 100755
index 0ff55886..00000000
--- a/source/authentication/udaSSL.h
+++ /dev/null
@@ -1,88 +0,0 @@
-#ifndef UDA_AUTHENTICATION_SSL_H
-#define UDA_AUTHENTICATION_SSL_H
-
-#if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-
-// Create the SSL context and binding to the socket
-// 3 UDA protocol modes: TCP without SSL/TLS, TCP and UDP both with SSL/TLS
-// This set of functions is concerned only with the SSL/TLS protocol (authentication and encryption) - not with establishing socket connections or non SSL TCP transport
-
-// Server host addressed beginng with SSL:// are assumed to be using SSL authentication. The SSL:// prefix is removed to make the connection.
-
-#include <openssl/ssl.h>
-#include <openssl/err.h>
-#include <openssl/crypto.h>
-#include <openssl/x509.h>
-#include <openssl/pem.h>
-#include <openssl/asn1.h>
-
-#define VERIFY_DEPTH	4
-#define X509STRINGSIZE	256
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#ifdef SERVERBUILD
-
-LIBRARY_API void putUdaServerSSL(SSL *s);
-LIBRARY_API SSL *getUdaServerSSL();
-LIBRARY_API void putUdaServerSSLCTX(SSL_CTX *c);
-LIBRARY_API SSL_CTX *getUdaServerSSLCTX();
-LIBRARY_API void putUdaServerSSLSocket(int s);
-LIBRARY_API int getUdaServerSSLSocket();
-LIBRARY_API void getUdaServerSSLErrorCode(int rc);
-LIBRARY_API void initUdaServerSSL();
-LIBRARY_API void closeUdaServerSSL();
-LIBRARY_API void putUdaServerSSLDisabled(int disabled);
-LIBRARY_API int getUdaServerSSLDisabled();
-LIBRARY_API void putUdaServerSSLGlobalInit(int init);
-LIBRARY_API int getUdaServerSSLGlobalInit();
-LIBRARY_API SSL_CTX *createUdaServerSSLContext();
-LIBRARY_API int configureUdaServerSSLContext();
-LIBRARY_API X509_CRL *loadUdaServerSSLCrl(char *crlist);
-LIBRARY_API int addUdaServerSSLCrlsStore(X509_STORE *st, STACK_OF(X509_CRL) *crls);
-LIBRARY_API int startUdaServerSSL();
-LIBRARY_API int readUdaServerSSL(void* iohandle, char* buf, int count);
-LIBRARY_API int writeUdaServerSSL(void* iohandle, char* buf, int count);
-
-#else
-
-LIBRARY_API void putUdaClientSSL(SSL *s);
-LIBRARY_API SSL *getUdaClientSSL();
-LIBRARY_API void putUdaClientSSLCTX(SSL_CTX *c);
-LIBRARY_API SSL_CTX *getUdaClientSSLCTX();
-LIBRARY_API void putUdaClientSSLSocket(int s);
-LIBRARY_API int getUdaClientSSLSocket();
-LIBRARY_API void getUdaClientSSLErrorCode(int rc);
-LIBRARY_API void initUdaClientSSL();
-LIBRARY_API void closeUdaClientSSL();
-LIBRARY_API void putUdaClientSSLDisabled(int disabled);
-LIBRARY_API int getUdaClientSSLDisabled();
-LIBRARY_API void putUdaClientSSLGlobalInit(int init);
-LIBRARY_API int getUdaClientSSLGlobalInit();
-LIBRARY_API void putUdaClientSSLOK(int ok);
-LIBRARY_API int getUdaClientSSLOK();
-LIBRARY_API void putUdaClientSSLProtocol(int specified);
-LIBRARY_API int getUdaClientSSLProtocol();
-LIBRARY_API SSL_CTX *createUdaClientSSLContext();
-LIBRARY_API int configureUdaClientSSLContext();
-LIBRARY_API int startUdaClientSSL();
-LIBRARY_API int readUdaClientSSL(void* iohandle, char* buf, int count);
-LIBRARY_API int writeUdaClientSSL(void* iohandle, char* buf, int count);
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // SSLAUTHENTICATION
-
-#endif // UDA_AUTHENTICATION_SSL_H
diff --git a/source/authentication/udaServerSSL.cpp b/source/authentication/udaServerSSL.cpp
index bcbe33e6..7ed3dfe6 100755
--- a/source/authentication/udaServerSSL.cpp
+++ b/source/authentication/udaServerSSL.cpp
@@ -1,11 +1,21 @@
-#if defined(SSLAUTHENTICATION) && defined(SERVERBUILD)
+#if defined(SSLAUTHENTICATION)
 
-#include "udaSSL.h"
+#include "udaServerSSL.h"
+
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <openssl/crypto.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/asn1.h>
 
 #include <clientserver/errorLog.h>
 #include <logging/logging.h>
 #include <server/writer.h>
 
+#define VERIFY_DEPTH        4
+#define X509STRINGSIZE      256
+
 /*
 Note on initialisation:
 UDA Servers using plugins that connect to other UDA servers through the standard client API library
@@ -16,76 +26,32 @@ and should not be passed to subsequent servers. An alternative and simpler mecha
 to assign a value to an environment variable, and for the client to test this environment variable. 
 */
 
-static int sslDisabled = 1;        // Default state is not SSL authentication
-static int sslSocket = -1;
-static int sslOK = 0;        // SSL Authentication has been passed sucessfully: default is NOT Passed
-static int sslGlobalInit = 0;        // Global initialisation of SSL completed
-static SSL* ssl = nullptr;
-static SSL_CTX* ctx = nullptr;
-
-void putUdaServerSSLOK(int ok)
-{
-    sslOK = ok;
-}
-
-int getUdaServerSSLOK()
-{
-    return sslOK;
-}
-
-void putUdaServerSSLDisabled(int disabled)
-{
-    sslDisabled = disabled;
-}
-
-int getUdaServerSSLDisabled()
-{
-    return sslDisabled;
-}
-
-void putUdaServerSSLGlobalInit(int init)
-{
-    sslGlobalInit = init;
-}
-
-int getUdaServerSSLGlobalInit()
-{
-    return sslGlobalInit;
-}
+static bool g_sslDisabled = true;       // Default state is not SSL authentication
+static int g_sslSocket = -1;
+static bool g_sslOK = false;            // SSL Authentication has been passed successfully: default is NOT Passed
+static bool g_sslInit = false;          // Global initialisation of SSL completed
+static SSL* g_ssl = nullptr;
+static SSL_CTX* g_ctx = nullptr;
 
-void putUdaServerSSL(SSL* s)
-{
-    ssl = s;
-}
+static void initUdaServerSSL();
+static SSL_CTX* createUdaServerSSLContext();
+static int configureUdaServerSSLContext();
+static X509_CRL* loadUdaServerSSLCrl(const char* crlist);
+static int addUdaServerSSLCrlsStore(X509_STORE* st, STACK_OF(X509_CRL)* crls);
 
-SSL* getUdaServerSSL()
+void putUdaServerSSLSocket(int socket)
 {
-    return ssl;
+    g_sslSocket = socket;
 }
 
-void putUdaServerSSLCTX(SSL_CTX* c)
+bool getUdaServerSSLDisabled()
 {
-    ctx = c;
+    return g_sslDisabled;
 }
 
-SSL_CTX* getUdaServerSSLCTX()
+void reportServerSSLErrorCode(int rc)
 {
-    return ctx;
-}
-
-void putUdaServerSSLSocket(int s)
-{
-    sslSocket = s;
-}
-
-int getUdaServerSSLSocket()
-{
-    return sslSocket;
-}
-
-void getUdaServerSSLErrorCode(int rc)
-{
-    int err = SSL_get_error(getUdaServerSSL(), rc);
+    int err = SSL_get_error(g_ssl, rc);
     char msg[256];
     switch (err) {
         case SSL_ERROR_NONE:
@@ -118,16 +84,16 @@ void getUdaServerSSLErrorCode(int rc)
     }
     err = 999;
     addIdamError(CODEERRORTYPE, "udaSSL", err, msg);
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: Error - %s\n", msg);
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: Error - %s\n", ERR_error_string(ERR_get_error(), nullptr));
-    UDA_LOG(UDA_LOG_DEBUG, "udaSSL: State - %s\n", SSL_state_string(getUdaServerSSL()));
+    UDA_LOG(UDA_LOG_DEBUG, "Error - %s\n", msg);
+    UDA_LOG(UDA_LOG_DEBUG, "Error - %s\n", ERR_error_string(ERR_get_error(), nullptr));
+    UDA_LOG(UDA_LOG_DEBUG, "State - %s\n", SSL_state_string(g_ssl));
 }
 
 void initUdaServerSSL()
 {
-    if (getUdaServerSSLGlobalInit()) return;    // Already initialised
+    if (g_sslInit) return;    // Already initialised
     if (getenv("UDA_SSL_INITIALISED")) {
-        putUdaServerSSLGlobalInit(1);
+        g_sslInit = true;
         UDA_LOG(UDA_LOG_DEBUG, "Prior SSL initialisation\n");
         return;
     }
@@ -137,66 +103,59 @@ void initUdaServerSSL()
 #ifdef _WIN32
     _putenv_s("UDA_SSL_INITIALISED", "1");
 #else
-    setenv("UDA_SSL_INITIALISED", "1", 0);    // Ensure the library is not re-initialised by the UDA client library
+    // Ensure the library is not re-initialised by the UDA client library
+    setenv("UDA_SSL_INITIALISED", "1", 0);
 #endif
-    putUdaServerSSLGlobalInit(1);
+    g_sslInit = true;
     UDA_LOG(UDA_LOG_DEBUG, "SSL initialised\n");
 }
 
 void closeUdaServerSSL()
-{            // Requires re-initialisation (should only be called once at closedown!)
-    if (getUdaServerSSLDisabled()) return;
-    putUdaServerSSLOK(0);
-    putUdaServerSSLSocket(-1);
-    putUdaServerSSLDisabled(1);
-    SSL* ssl = getUdaServerSSL();
-    SSL_CTX* ctx = getUdaServerSSLCTX();
-    if (ssl != nullptr) {
-        SSL_shutdown(ssl);
-        SSL_free(ssl);
+{
+    // Requires re-initialisation (should only be called once at closedown!)
+    if (g_sslDisabled) {
+        return;
     }
-    if (ctx != nullptr) SSL_CTX_free(ctx);
+    g_sslOK = false;
+    g_sslSocket = -1;
+    g_sslDisabled = true;
+    if (g_ssl != nullptr) {
+        SSL_shutdown(g_ssl);
+        SSL_free(g_ssl);
+    }
+    if (g_ctx != nullptr) SSL_CTX_free(g_ctx);
     EVP_cleanup();
-    putUdaServerSSL(nullptr);
-    putUdaServerSSLCTX(nullptr);
+    g_ssl = nullptr;
+    g_ctx = nullptr;
 #ifdef _WIN32
     _putenv_s("UDA_SSL_INITIALISED", NULL);
 #else
     unsetenv("UDA_SSL_INITIALISED");
 #endif
-    putUdaServerSSLGlobalInit(0);
-    UDA_LOG(UDA_LOG_DEBUG, "closeUdaServerSSL: SSL closed\n");
+    g_sslInit = false;
+    UDA_LOG(UDA_LOG_DEBUG, "SSL closed\n");
 }
 
-
 SSL_CTX* createUdaServerSSLContext()
 {
-    int err = 0;
-
-    const SSL_METHOD* method;
-    SSL_CTX* ctx;
-
-    method = SSLv23_server_method();        // standard TCP
+    const SSL_METHOD* method = SSLv23_server_method();        // standard TCP
 
     // method = DTLSv1_server_method()		// reliable UDP
 
-    ctx = SSL_CTX_new(method);
-    putUdaServerSSLCTX(ctx);
+    g_ctx = SSL_CTX_new(method);
 
-    if (!ctx) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to create SSL context");
+    if (!g_ctx) {
         UDA_LOG(UDA_LOG_DEBUG, "Unable to create SSL context!\n");
+        ADD_ERROR(999, "Unable to create SSL context");
         return nullptr;
     }
 
-// Disable SSLv2 for v3 and TSLv1  negotiation 
-
-    SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2);
+    // Disable SSLv2 for v3 and TSLv1  negotiation
+    SSL_CTX_set_options(g_ctx, SSL_OP_NO_SSLv2);
 
 /*
 // Set the Cipher List 
-   if (SSL_CTX_set_cipher_list(ctx, "AES128-SHA") <= 0) {
+   if (SSL_CTX_set_cipher_list(g_ctx, "AES128-SHA") <= 0) {
       printf("Error setting the cipher list.\n");
       exit(0);
    }    
@@ -204,145 +163,116 @@ SSL_CTX* createUdaServerSSLContext()
 
     UDA_LOG(UDA_LOG_DEBUG, "SSL Context created\n");
 
-    return ctx;
+    return g_ctx;
 }
 
 int configureUdaServerSSLContext()
 {
-    int err = 0;
-
-    SSL_CTX* ctx = getUdaServerSSLCTX();
-
-    //SSL_CTX_set_ecdh_auto(ctx, 1);
-
-// Set the key and cert 
-
-    char* cert = getenv("UDA_SERVER_SSL_CERT");
-    char* key = getenv("UDA_SERVER_SSL_KEY");
-    char* ca = getenv("UDA_SERVER_CA_SSL_CERT");
-    char* crlist = getenv("UDA_SERVER_CA_SSL_CRL");
+    const char* cert = getenv("UDA_SERVER_SSL_CERT");
+    const char* key = getenv("UDA_SERVER_SSL_KEY");
+    const char* ca = getenv("UDA_SERVER_CA_SSL_CERT");
+    const char* crlist = getenv("UDA_SERVER_CA_SSL_CRL");
 
     if (!cert || !key || !ca || !crlist) {
-        err = 999;
-        if (!cert) addIdamError(CODEERRORTYPE, "udaServerSSL", err, "No server SSL certificate!");
-        if (!key) addIdamError(CODEERRORTYPE, "udaServerSSL", err, "No server SSL key!");
+        if (!cert) {
+            ADD_ERROR(999, "No server SSL certificate!");
+        }
+        if (!key) {
+            ADD_ERROR(999, "No server SSL key!");
+        }
         if (!ca) {
-            addIdamError(CODEERRORTYPE, "udaServerSSL", err, "No Certificate Authority certificate!");
+            ADD_ERROR(999, "No Certificate Authority certificate!");
         }
         if (!crlist) {
-            addIdamError(CODEERRORTYPE, "udaServerSSL", err, "No Certificate Revocation List!");
+            ADD_ERROR(999, "No Certificate Revocation List!");
         }
         UDA_LOG(UDA_LOG_DEBUG, "Certificate/Key/CRL environment variable problem!\n");
-        return err;
+        return 999;
     }
 
-    if (SSL_CTX_use_certificate_file(ctx, cert, SSL_FILETYPE_PEM) <= 0) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaServerSSL", err, "Failed to set the server certificate!");
-        return err;
+    if (SSL_CTX_use_certificate_file(g_ctx, cert, SSL_FILETYPE_PEM) <= 0) {
+        THROW_ERROR(999, "Failed to set the server certificate!");
     }
 
-    if (SSL_CTX_use_PrivateKey_file(ctx, key, SSL_FILETYPE_PEM) <= 0) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaServerSSL", err, "Failed to set the server key!");
-        return err;
+    if (SSL_CTX_use_PrivateKey_file(g_ctx, key, SSL_FILETYPE_PEM) <= 0) {
+        THROW_ERROR(999, "Failed to set the server key!");
     }
 
-// Check key and certificate match 
-
-    if (SSL_CTX_check_private_key(ctx) == 0) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaServerSSL", err,
-                     "Private key does not match the certificate public key!");
-        return err;
+    // Check key and certificate match
+    if (SSL_CTX_check_private_key(g_ctx) == 0) {
+        THROW_ERROR(999, "Private key does not match the certificate public key!");
     }
 
-// Load certificates of trusted CAs   
-
-    if (SSL_CTX_load_verify_locations(ctx, ca, nullptr) < 1) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaServerSSL", err,
-                     "Error setting the Cetificate Authority verify locations!");
-        return err;
+    // Load certificates of trusted CAs
+    if (SSL_CTX_load_verify_locations(g_ctx, ca, nullptr) < 1) {
+        THROW_ERROR(999, "Error setting the Cetificate Authority verify locations!");
     }
 
-// Peer certificate verification
-
-    SSL_CTX_set_verify(ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
-    SSL_CTX_set_verify_depth(ctx, VERIFY_DEPTH);
-
-// Add verification against the Certificate Revocation List
+    // Peer certificate verification
+    SSL_CTX_set_verify(g_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);
+    SSL_CTX_set_verify_depth(g_ctx, VERIFY_DEPTH);
 
+    // Add verification against the Certificate Revocation List
     X509_VERIFY_PARAM* params = X509_VERIFY_PARAM_new();
     X509_VERIFY_PARAM_set_flags(params, X509_V_FLAG_CRL_CHECK);
-    SSL_CTX_set1_param(ctx, params);
+    SSL_CTX_set1_param(g_ctx, params);
 
     X509_CRL* crl = loadUdaServerSSLCrl(crlist);
-    if (!crl) return 999;    // CRL not loaded
+    if (!crl) {
+        return 999; // CRL not loaded
+    }
 
     STACK_OF(X509_CRL)* crls = sk_X509_CRL_new_null();
     if (!crls || !sk_X509_CRL_push(crls, crl)) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaServerSSL", err,
-                     "Error loading the CRL for client certificate verification!");
         X509_CRL_free(crl);
-        return err;
+        THROW_ERROR(999, "Error loading the CRL for client certificate verification!");
     }
 
-    X509_STORE* st = SSL_CTX_get_cert_store(ctx);
+    X509_STORE* st = SSL_CTX_get_cert_store(g_ctx);
     addUdaServerSSLCrlsStore(st, crls);
-    SSL_CTX_set1_verify_cert_store(ctx, st);
+    SSL_CTX_set1_verify_cert_store(g_ctx, st);
 
-// Set CA list used for client authentication 
+    // Set CA list used for client authentication
 
 /*
-  if(SSL_CTX_use_certificate_chain_file(ctx, getenv("UDA_SERVER_CA_SSL_CERT")) < 1){
+  if(SSL_CTX_use_certificate_chain_file(g_ctx, getenv("UDA_SERVER_CA_SSL_CERT")) < 1){
      //printf("Error setting the CA chain file\n");
      exit(0);
   }
 */
 /*   
-  SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(getenv("UDA_SERVER_CA_SSL_CERT"))); 
+  SSL_CTX_set_client_CA_list(g_ctx, SSL_load_client_CA_file(getenv("UDA_SERVER_CA_SSL_CERT")));
 
-   rc = load_CA(ssl, ctx, getenv("UDA_SERVER_CA_SSL_CERT"));	// calls SSL_CTX_add_client_CA(ctx, X509 *cacert) and         SSL_add_client_CA(ssl, X509 *cacert)
+   rc = load_CA(g_ssl, g_ctx, getenv("UDA_SERVER_CA_SSL_CERT"));	// calls SSL_CTX_add_client_CA(g_ctx, X509 *cacert) and         SSL_add_client_CA(g_ssl, X509 *cacert)
    if(rc == 0)fprintf(logout, "Unable to load Client CA!\n");
 */
 
     UDA_LOG(UDA_LOG_DEBUG, "SSL Context configured\n");
 
-    return err;
+    return 0;
 }
 
-X509_CRL* loadUdaServerSSLCrl(char* crlist)
+X509_CRL* loadUdaServerSSLCrl(const char* crlist)
 {
-
     // Load the Certificate Revocation Lists for certificate verification
 
-    int err = 0;
-
     BIO* in = BIO_new(BIO_s_file());
     if (in == nullptr) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err,
-                     "Error creating a Certificate Revocation List object!");
+        ADD_ERROR(999, "Error creating a Certificate Revocation List object!");
         return nullptr;
     }
 
     if (BIO_read_filename(in, crlist) <= 0) {
         BIO_free(in);
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err,
-                     "Error opening the Certificate Revocation List file!");
+        ADD_ERROR(999, "Error opening the Certificate Revocation List file!");
         return nullptr;
     }
 
-    X509_CRL* x = PEM_read_bio_X509_CRL(in, nullptr, nullptr, nullptr);
+    X509_CRL* crl = PEM_read_bio_X509_CRL(in, nullptr, nullptr, nullptr);
 
-    if (x == nullptr) {
+    if (crl == nullptr) {
         BIO_free(in);
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err,
-                     "Error reading the Certificate Revocation List file!");
+        ADD_ERROR(999, "Error reading the Certificate Revocation List file!");
         return nullptr;
     }
 
@@ -350,7 +280,7 @@ X509_CRL* loadUdaServerSSLCrl(char* crlist)
 
     UDA_LOG(UDA_LOG_DEBUG, "CRL loaded\n");
 
-    return (x);
+    return crl;
 }
 
 int addUdaServerSSLCrlsStore(X509_STORE* st, STACK_OF(X509_CRL)* crls)
@@ -363,162 +293,123 @@ int addUdaServerSSLCrlsStore(X509_STORE* st, STACK_OF(X509_CRL)* crls)
     return 1;
 }
 
-/*
-static int load_CA(SSL *ssl, SSL_CTX *ctx, char *file){
-    FILE *in;
-    X509 *x = nullptr;
-
-    if ((in = fopen(file, "r")) == nullptr){
-        fprintf(logout, "Unable to open the CA certificate file\n");
-        return (0);
-    }
-    for (;;) {
-        if (PEM_read_X509(in, &x, 0, nullptr) == nullptr){
-           fprintf(logout, "Unable to read the CA certificate file\n");
-           break;
-        }
-        SSL_CTX_add_client_CA(ctx, x);
-	SSL_add_client_CA(ssl, x);
-    }
-
-    if (x != nullptr) X509_free(x);
-    fclose(in);
-    
-    if(x == nullptr) return 0;
-    return (1);
-}
-*/
-
-
 int startUdaServerSSL()
 {
-    int rc, err = 0;
-    SSL_CTX* ctx = nullptr;
-
-// Has SSL/TLS authentication already been passed?
-
-    if (getUdaServerSSLOK()) return 0;
+    int rc;
 
-// Has the server disabled SSL/TLS authentication?
+    // Has SSL/TLS authentication already been passed?
+    if (g_sslOK) {
+        return 0;
+    }
 
+    // Has the server disabled SSL/TLS authentication?
     if (!getenv("UDA_SERVER_SSL_AUTHENTICATE")) {
-        putUdaServerSSLDisabled(1);
+        g_sslDisabled = true;
         return 0;
     } else {
-        putUdaServerSSLDisabled(0);
+        g_sslDisabled = false;
     }
 
     UDA_LOG(UDA_LOG_DEBUG, "SSL Authentication is Enabled!\n");
 
-// Initialise  
-
+    // Initialise
     initUdaServerSSL();
 
-    if (!(ctx = createUdaServerSSLContext())) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to create the SSL context!");
-        return err;
+    if (!(g_ctx = createUdaServerSSLContext())) {
+        THROW_ERROR(999, "Unable to create the SSL context!");
     }
     if (configureUdaServerSSLContext() != 0) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to configure the SSL context!");
-        return err;
+        THROW_ERROR(999, "Unable to configure the SSL context!");
     }
 
-// Bind an SSL object with the socket
-
-    SSL* ssl = SSL_new(ctx);
-    if ((rc = SSL_set_fd(ssl, getUdaServerSSLSocket())) < 1) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err, "Unable to bind the socket to SSL!");
-        UDA_LOG(UDA_LOG_DEBUG, "udaSSL: Error - Unable to bind the socket to SSL!\n");
-        return err;
+    // Bind an SSL object with the socket
+    g_ssl = SSL_new(g_ctx);
+    if ((rc = SSL_set_fd(g_ssl, g_sslSocket)) < 1) {
+        UDA_LOG(UDA_LOG_DEBUG, "Error - Unable to bind the socket to SSL!\n");
+        THROW_ERROR(999, "Unable to bind the socket to SSL!");
     }
 
-    putUdaServerSSL(ssl);
-
-// SSL Handshake with Client Authentication
-
-    if ((rc = SSL_accept(ssl)) < 1) {
-        if (errno != 0) addIdamError(SYSTEMERRORTYPE, "udaSSL", errno, "SSL Handshake failed!");
+    // SSL Handshake with Client Authentication
+    if ((rc = SSL_accept(g_ssl)) < 1) {
+        if (errno != 0) {
+            ADD_SYS_ERROR("SSL Handshake failed!");
+        }
         UDA_LOG(UDA_LOG_DEBUG, "Error - SSL Handshake Failed!\n");
-        err = SSL_get_error(ssl, rc);
+        int err = SSL_get_error(g_ssl, rc);
         if (err == 5) {
             UDA_LOG(UDA_LOG_DEBUG, "Error - Client application terminated?!\n");
-            addIdamError(CODEERRORTYPE, "udaSSL", err,
-                         "SSL error in SSL_accept, application terminated!");
+            ADD_ERROR(err, "SSL error in SSL_accept, application terminated!");
         }
-        getUdaServerSSLErrorCode(rc);
+        reportServerSSLErrorCode(rc);
         return err;
     }
 
-// Get the Client's certificate and verify
-
-    X509* peer = SSL_get_peer_certificate(ssl);
+    // Get the Client's certificate and verify
+    X509* peer = SSL_get_peer_certificate(g_ssl);
 
     if (peer != nullptr) {
-
-        if ((rc = SSL_get_verify_result(ssl)) !=
-            X509_V_OK) {    // returns X509_V_OK if the certificate was not obtained as no error occured!
-            err = 999;
-            addIdamError(CODEERRORTYPE, "udaSSL", err,
-                         "SSL Client certificate  presented but verification error!");
-            addIdamError(CODEERRORTYPE, "udaSSL", err, X509_verify_cert_error_string(rc));
+        if ((rc = SSL_get_verify_result(g_ssl)) != X509_V_OK) {
+            // returns X509_V_OK if the certificate was not obtained as no error occured!
             X509_free(peer);
             UDA_LOG(UDA_LOG_DEBUG, "SSL Client certificate presented but verification error!\n");
-            return err;
+            ADD_ERROR(999, "SSL Client certificate  presented but verification error!");
+            THROW_ERROR(999, X509_verify_cert_error_string(rc));
         }
 
-// Client's details
+        // Client's details
 
         char work[X509STRINGSIZE];
         UDA_LOG(UDA_LOG_DEBUG, "Client certificate verified\n");
         UDA_LOG(UDA_LOG_DEBUG, "X509 subject: %s\n",
-                  X509_NAME_oneline(X509_get_subject_name(peer), work, sizeof(work)));
+                X509_NAME_oneline(X509_get_subject_name(peer), work, sizeof(work)));
         UDA_LOG(UDA_LOG_DEBUG, "X509 issuer: %s\n",
-                  X509_NAME_oneline(X509_get_issuer_name(peer), work, sizeof(work)));
+                X509_NAME_oneline(X509_get_issuer_name(peer), work, sizeof(work)));
         UDA_LOG(UDA_LOG_DEBUG, "X509 not before: %d\n", X509_get_notBefore(peer));
         UDA_LOG(UDA_LOG_DEBUG, "X509 not after: %d\n", X509_get_notAfter(peer));
         X509_free(peer);
     } else {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "udaSSL", err,
-                     "Client certificate not presented for verification!");
         X509_free(peer);
         UDA_LOG(UDA_LOG_DEBUG, "Client certificate not presented for verification!\n");
-        return err;
+        THROW_ERROR(999, "Client certificate not presented for verification!");
     }
 
-// Print out connection details 
+    // Print out connection details
 
-    UDA_LOG(UDA_LOG_DEBUG, "SSL version: %s\n", SSL_get_version(ssl));
-    UDA_LOG(UDA_LOG_DEBUG, "SSL cipher: %s\n", SSL_get_cipher(ssl));
+    UDA_LOG(UDA_LOG_DEBUG, "SSL version: %s\n", SSL_get_version(g_ssl));
+    UDA_LOG(UDA_LOG_DEBUG, "SSL cipher: %s\n", SSL_get_cipher(g_ssl));
 
-// SSL/TLS authentication has been passed - do not repeat
+    // SSL/TLS authentication has been passed - do not repeat
 
-    putUdaServerSSLOK(1);
+    g_sslOK = true;
 
     return 0;
 }
 
-int writeUdaServerSSL(void* iohandle, char* buf, int count)
-{
-
-//return SSL_write(getUdaServerSSL(), buf, count);
+#ifdef UNUSED
+#elif defined(__GNUC__)
+# define UNUSED __attribute__((unused))
+#elif defined(__LCLINT__)
+# define UNUSED /*@unused@*/
+#else
+# define UNUSED
+#endif
 
-// This routine is only called when there is something to write back to the Client
-// SSL uses an all or nothing approach when the socket is blocking - an SSL error or incomplete write means the write has failed
+int writeUdaServerSSL(UNUSED void* iohandle, const char* buf, int count)
+{
+    // This routine is only called when there is something to write back to the Client
+    // SSL uses an all or nothing approach when the socket is blocking - an SSL error or incomplete write
+    // means the write has failed
 
-    int rc, err = 0;
+    int rc;
 
     fd_set wfds;        // File Descriptor Set for Writing to the Socket
-    struct timeval tv;
+    struct timeval tv = {};
 
     // Block till it's possible to write to the socket or timeout
 
-    setSelectParms(getUdaServerSSLSocket(), &wfds, &tv);
+    setSelectParms(g_sslSocket, &wfds, &tv);
 
-    while ((rc = select(getUdaServerSSLSocket() + 1, nullptr, &wfds, nullptr, &tv)) <= 0) {
+    while ((rc = select(g_sslSocket + 1, nullptr, &wfds, nullptr, &tv)) <= 0) {
 
         if (rc < 0) {    // Error
             if (errno == EBADF) {
@@ -531,9 +422,8 @@ int writeUdaServerSSL(void* iohandle, char* buf, int count)
         }
 
         int fopts = 0;
-        if ((rc = fcntl(getUdaServerSSLSocket(), F_GETFL, &fopts)) < 0 ||
-            errno == EBADF) {    // Is the socket closed? Check status flags
-            err = 999;
+        if (fcntl(g_sslSocket, F_GETFL, &fopts) < 0 || errno == EBADF) {
+            // Is the socket closed? Check status flags
             UDA_LOG(UDA_LOG_DEBUG, "Client Socket is closed! Closing server down.\n");
             return -1;
         }
@@ -544,59 +434,53 @@ int writeUdaServerSSL(void* iohandle, char* buf, int count)
             UDA_LOG(UDA_LOG_DEBUG, "Total Blocking Time: %d (ms). Closing server down.\n", server_tot_block_time);
             return -1;        // Timeout
         }
-        updateSelectParms(getUdaServerSSLSocket(), &wfds, &tv);
+        updateSelectParms(g_sslSocket, &wfds, &tv);
     }
 
-// set SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode to disable automatic renegotiation?
+    // set SSL_MODE_AUTO_RETRY flag of the SSL_CTX_set_mode to disable automatic renegotiation?
 
-    rc = SSL_write(getUdaServerSSL(), buf, count);
+    rc = SSL_write(g_ssl, buf, count);
 
-    switch (SSL_get_error(getUdaServerSSL(), rc)) {
+    switch (SSL_get_error(g_ssl, rc)) {
         case SSL_ERROR_NONE:
-            if (rc != count) {    // Check the write is complete
-                err = 999;
+            if (rc != count) {
+                // Check the write is complete
                 UDA_LOG(UDA_LOG_DEBUG, "Incomplete write to socket!\n");
-                addIdamError(CODEERRORTYPE, "writeUdaServerSSL", err, "Incomplete write to socket!");
+                ADD_ERROR(999, "Incomplete write to socket!");
                 return -1;
             }
             break;
 
         default:
-            getUdaServerSSLErrorCode(rc);
-            err = 999;
+            reportServerSSLErrorCode(rc);
             UDA_LOG(UDA_LOG_DEBUG, "Write to socket failed!\n");
-            addIdamError(CODEERRORTYPE, "writeUdaServerSSL", err, "Write to socket failed!");
+            ADD_ERROR(999, "Write to socket failed!");
             int fopts = 0;
-            if ((rc = fcntl(getUdaServerSSLSocket(), F_GETFL, &fopts)) < 0 ||
-                errno == EBADF) {    // Is the socket closed? Check status flags
-                    UDA_LOG(UDA_LOG_DEBUG, "Client Socket is closed! Closing server down.\n");
+            if (fcntl(g_sslSocket, F_GETFL, &fopts) < 0 || errno == EBADF) {
+                // Is the socket closed? Check status flags
+                UDA_LOG(UDA_LOG_DEBUG, "Client Socket is closed! Closing server down.\n");
             }
             return -1;
     }
 
     return rc;
-
 }
 
-int readUdaServerSSL(void* iohandle, char* buf, int count)
+int readUdaServerSSL(UNUSED void* iohandle, char* buf, int count)
 {
-
-//return SSL_read(getUdaServerSSL(), buf, count);
-
-
-    int rc, err = 0;
+    int rc;
     fd_set rfds;        // File Descriptor Set for Reading from the Socket
     struct timeval tv, tvc;
 
     // Wait till it's possible to read from the socket
     // Set the blocking period before a timeout
 
-    setSelectParms(getUdaServerSSLSocket(), &rfds, &tv);
+    setSelectParms(g_sslSocket, &rfds, &tv);
     tvc = tv;
 
-// TODO: Use pselect to include a signal mask to force a timeout
+    // TODO: Use pselect to include a signal mask to force a timeout
 
-    while ((rc = select(getUdaServerSSLSocket() + 1, &rfds, nullptr, nullptr, &tvc)) <= 0) {
+    while ((rc = select(g_sslSocket + 1, &rfds, nullptr, nullptr, &tvc)) <= 0) {
 
         if (rc < 0) {    // Error
             if (errno == EBADF) {
@@ -612,40 +496,37 @@ int readUdaServerSSL(void* iohandle, char* buf, int count)
 
         if (server_tot_block_time > 1000 * server_timeout) {
             UDA_LOG(UDA_LOG_DEBUG,
-                      "Total Wait Time Exceeds Lifetime Limit = %d (ms). Closing server down.\n",
-                      server_timeout * 1000);
+                    "Total Wait Time Exceeds Lifetime Limit = %d (ms). Closing server down.\n",
+                    server_timeout * 1000);
             return -1;
         }
 
         int fopts = 0;
-        if ((rc = fcntl(getUdaServerSSLSocket(), F_GETFL, &fopts)) < 0 ||
-            errno == EBADF) {    // Is the socket closed? Check status flags
-            err = 999;
+        if (fcntl(g_sslSocket, F_GETFL, &fopts) < 0 || errno == EBADF) {
+            // Is the socket closed? Check status flags
             UDA_LOG(UDA_LOG_DEBUG, "Client Socket is closed! Closing server down.\n");
             return -1;
         }
 
-        updateSelectParms(getUdaServerSSLSocket(), &rfds, &tv);        // Keep blocking and wait for data
+        updateSelectParms(g_sslSocket, &rfds, &tv);        // Keep blocking and wait for data
         tvc = tv;
     }
 
-// First byte of encrypted data received but need the full record in buffer before SSL can decrypt
+    // First byte of encrypted data received but need the full record in buffer before SSL can decrypt
 
     int blocked;
     do {
         blocked = 0;
-        rc = SSL_read(getUdaServerSSL(), buf, count);
+        rc = SSL_read(g_ssl, buf, count);
 
-        switch (SSL_get_error(getUdaServerSSL(), rc)) {    // check for SSL errors
+        switch (SSL_get_error(g_ssl, rc)) {    // check for SSL errors
             case SSL_ERROR_NONE:                    // clean read
                 break;
 
             case SSL_ERROR_ZERO_RETURN:    // connection closed by client 	(not caught by select?)
-                getUdaServerSSLErrorCode(rc);
-                err = 999;
+                reportServerSSLErrorCode(rc);
                 UDA_LOG(UDA_LOG_DEBUG, "Client socket connection closed!\n");
-                addIdamError(CODEERRORTYPE, "readUdaServerSSL", err,
-                             "Client socket connection closed!");
+                ADD_ERROR(999, "Client socket connection closed!");
                 return -1;
 
             case SSL_ERROR_WANT_READ:    // the operation did not complete, try again
@@ -653,35 +534,32 @@ int readUdaServerSSL(void* iohandle, char* buf, int count)
                 break;
 
             case SSL_ERROR_WANT_WRITE:    //the operation did not complete, error
-                getUdaServerSSLErrorCode(rc);
-                err = 999;
+                reportServerSSLErrorCode(rc);
                 UDA_LOG(UDA_LOG_DEBUG, "A read operation failed!\n");
-                addIdamError(CODEERRORTYPE, "readUdaServerSSL", err, "A read operation failed!");
+                ADD_ERROR(999, "A read operation failed!");
                 return -1;
 
             case SSL_ERROR_SYSCALL:    //some I/O error occured - disconnect?
-                getUdaServerSSLErrorCode(rc);
-                err = 999;
+                reportServerSSLErrorCode(rc);
                 UDA_LOG(UDA_LOG_DEBUG, "Client socket read I/O error!\n");
-                addIdamError(CODEERRORTYPE, "readUdaServerSSL", err, "Client socket read I/O error!");
+                ADD_ERROR(999, "Client socket read I/O error!");
                 return -1;
 
             default:            //some other error
-                getUdaServerSSLErrorCode(rc);
-                err = 999;
+                reportServerSSLErrorCode(rc);
                 UDA_LOG(UDA_LOG_DEBUG, "Read from socket failed!\n");
-                addIdamError(CODEERRORTYPE, "readUdaServerSSL", err, "Read from socket failed!");
+                ADD_ERROR(999, "Read from socket failed!");
                 int fopts = 0;
-                if ((rc = fcntl(getUdaServerSSLSocket(), F_GETFL, &fopts)) < 0 ||
+                if ((rc = fcntl(g_sslSocket, F_GETFL, &fopts)) < 0 ||
                     errno == EBADF) {    // Is the socket closed? Check status flags
-                        UDA_LOG(UDA_LOG_DEBUG, "writeUdaServerSSL: Client Socket is closed! Closing server down.\n");
+                    UDA_LOG(UDA_LOG_DEBUG, "writeUdaServerSSL: Client Socket is closed! Closing server down.\n");
                 }
                 return -1;
         }
 
-    } while (SSL_pending(getUdaServerSSL()) && !blocked);    // data remaining in buffer or re-read attempt
+    } while (SSL_pending(g_ssl) && !blocked);    // data remaining in buffer or re-read attempt
 
     return rc;
 }
 
-#endif   // SERVERBUILD && SSLAUTHENTICATION 
+#endif // SERVERBUILD
\ No newline at end of file
diff --git a/source/authentication/udaServerSSL.h b/source/authentication/udaServerSSL.h
new file mode 100644
index 00000000..c8dc84ee
--- /dev/null
+++ b/source/authentication/udaServerSSL.h
@@ -0,0 +1,31 @@
+#ifndef UDA_AUTHENTICATION_SERVER_SSL_H
+#define UDA_AUTHENTICATION_SERVER_SSL_H
+
+#if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
+
+// Create the SSL context and binding to the socket
+// 3 UDA protocol modes: TCP without SSL/TLS, TCP and UDP both with SSL/TLS
+// This set of functions is concerned only with the SSL/TLS protocol (authentication and encryption) - not with establishing socket connections or non SSL TCP transport
+
+// Server host addressed beginng with SSL:// are assumed to be using SSL authentication. The SSL:// prefix is removed to make the connection.
+
+#include <clientserver/export.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+LIBRARY_API int startUdaServerSSL();
+LIBRARY_API void closeUdaServerSSL();
+LIBRARY_API int readUdaServerSSL(void* iohandle, char* buf, int count);
+LIBRARY_API int writeUdaServerSSL(void* iohandle, const char* buf, int count);
+LIBRARY_API void putUdaServerSSLSocket(int socket);
+LIBRARY_API bool getUdaServerSSLDisabled();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // SSLAUTHENTICATION
+
+#endif // UDA_AUTHENTICATION_SERVER_SSL_H
diff --git a/source/cache/CMakeLists.txt b/source/cache/CMakeLists.txt
index e6185dec..1ec268d1 100755
--- a/source/cache/CMakeLists.txt
+++ b/source/cache/CMakeLists.txt
@@ -1,14 +1,33 @@
 find_package( LibMemcached )
 
+if( WIN32 OR MINGW )
+  find_package( XDR REQUIRED )
+  if( NOT MINGW )
+    find_package( dlfcn-win32 CONFIG REQUIRED )
+  endif()
+else()
+  find_package( TIRPC QUIET )
+  if( TIRPC_FOUND )
+    add_definitions(-D__TIRPC__)    
+  endif()
+endif()
+
 set( SRC_FILES
-  cache.cpp
+  memcache.cpp
   fileCache.cpp
+  cache.cpp
 )
 
 include_directories(
   ${CMAKE_SOURCE_DIR}/source
 )
 
+if( MINGW OR WIN32 )
+  include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
+endif()
+
 if( LIBMEMCACHED_FOUND )
   include_directories( ${LIBMEMCACHED_INCLUDES} )
   set( EXTRA_LD_LIBRARY_PATHS "${EXTRA_LD_LIBRARY_PATHS};${LIBMEMCACHED_LIB_DIR}" CACHE INTERNAL "" )
diff --git a/source/cache/cache.cpp b/source/cache/cache.cpp
old mode 100755
new mode 100644
index ecece7a1..a4fcc8e6
--- a/source/cache/cache.cpp
+++ b/source/cache/cache.cpp
@@ -1,265 +1,29 @@
 #include "cache.h"
 
-#ifdef NOLIBMEMCACHED
-
-struct IdamCached {
-    int dummy_;
-};
-
-UDA_CACHE* idamOpenCache()
-{ return nullptr; }
-
-void idamFreeCache()
-{}
-
-char* idamCacheKey(const REQUEST_BLOCK* request_block, ENVIRONMENT environment)
-{ return nullptr; }
-
-int idamCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
-                   LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment,
-                   int protocolVersion)
-{ return 0; }
-
-DATA_BLOCK* idamCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
-                          USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
-{ return nullptr; }
-
-#else
-
-#include <libmemcached/memcached.h>
-#include <openssl/ssl.h>
-
-#include <logging/logging.h>
+#include <clientserver/xdrlib.h>
 #include <clientserver/protocol.h>
 #include <clientserver/initStructs.h>
-#include <clientserver/memstream.h>
-#include <clientserver/xdrlib.h>
-
-#define HASHXDR 1
-#ifdef HASHXDR
-#  define PARTBLOCKINIT        1
-#  define PARTBLOCKUPDATE      2
-#  define PARTBLOCKOUTPUT      3
-#endif // HASHXDR
-
-#define MAXELEMENTSHA1 20
 
-struct UdaCache {
-    memcached_st memcache;
-};
-
-static UDA_CACHE* global_cache = nullptr;    // scope limited to this code module
-
-UDA_CACHE* idamOpenCache()
+void writeCacheData(FILE* fp, LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                    const DATA_BLOCK* data_block, int protocolVersion)
 {
-    auto cache = (UDA_CACHE*)malloc(sizeof(UDA_CACHE));
-    memcached_return_t rc;
-    memcached_server_st* servers;
-
-    const char* host = getenv("UDA_CACHE_HOST");   // Overrule the default settings
-    const char* port = getenv("UDA_CACHE_PORT");
-
-    if (host == nullptr && port == nullptr) {
-        servers = memcached_server_list_append(nullptr, UDA_CACHE_HOST, (in_port_t)UDA_CACHE_PORT, &rc);
-    } else if (host != nullptr && port != nullptr) {
-        servers = memcached_server_list_append(nullptr, host, (in_port_t)atoi(port), &rc);
-    } else if (host != nullptr) {
-        servers = memcached_server_list_append(nullptr, host, (in_port_t)UDA_CACHE_PORT, &rc);
-    } else {
-        servers = memcached_server_list_append(nullptr, UDA_CACHE_HOST, (in_port_t)atoi(port), &rc);
-    }
-
-    //memcached_create(&cache->memcache);       // Causes a segmentation Violation!
-    cache->memcache = *memcached_create(nullptr);
-    rc = memcached_server_push(&cache->memcache, servers);
-
-    if (rc == MEMCACHED_SUCCESS) {
-        UDA_LOG(UDA_LOG_DEBUG, "%s\n", "Added server successfully");
-    } else {
-        UDA_LOG(UDA_LOG_DEBUG, "Couldn't add server: %s\n", memcached_strerror(&cache->memcache, rc));
-        free(cache);
-        return nullptr;
-    }
-
-    global_cache = cache;   // Copy the pointer
-    return cache;
-}
-
-void idamFreeCache() // Will be called by the idamFreeAll function
-{
-    memcached_free(&global_cache->memcache);
-}
-
-// Use the requested signal and source with client specified properties to create a unique key
-// All parameters that may effect the data state, e.g. flags, host, port, properties, etc. must be included in the key
-// There is a 250 character limit - use SHA1 hash if it exceeds 250
-// The local cache should only be used to record data returned from a server after a GET method - Note: Put methods may be disguised in a GET call!
-// How to validate the cached data?
-
-char* idamCacheKey(const REQUEST_BLOCK* request_block, ENVIRONMENT environment)
-{
-    // Check Client Properties for permission and requested method
-    if (!(clientFlags & CLIENTFLAG_CACHE)) {
-        return nullptr;
-    }
-
-    // **** TODO **** if(!(clientFlags & CLIENTFLAG_CACHE) || request_block->put) return nullptr;
-    const char* delimiter = "&&";
-    size_t len = strlen(request_block->source) + strlen(request_block->signal) +
-                 strlen(environment.server_host) + 128;
-    char* key = (char*)malloc(len * sizeof(char));
-    sprintf(key, "%s%s%s%s%s%s%d%s%d%s%d", request_block->signal, delimiter, request_block->source, delimiter,
-            environment.server_host, delimiter, environment.server_port, delimiter, environment.clientFlags, delimiter,
-            privateFlags);
-
-    // *** TODO: Add server properties (set by the client) to the key - planned to use clientFlags (bit settings) but not implemented yet! ***
-    // *** which server is the client connected to .... may not be the default in the ENVIRONMENT structure! - Investigate! ***
-    // *** privateFlags is a global also in the CLIENT_BLOCK structure passed to the server (with clientFlags)
-
-    if (len < 250) {
-        return key;
-    }
-
-#ifndef HASHXDR
-    free(key);
-    return nullptr;
-    // No Hash function to create the key
-#else
-    // Need a compact hash - use SHA1 as always 20 bytes (40 bytes when printable)
-    unsigned char md[MAXELEMENTSHA1 + 1];      // SHA1 Hash
-    md[MAXELEMENTSHA1] = '\0';
-    strcpy((char*)md, "                    ");
-    SHA1((unsigned char*)key, len, md);
-    // Convert to a printable string (40 characters) for the key (is this necessary?)
-    key[40] = '\0';
-
-    for (int j = 0; j < 20; j++) {
-        sprintf(&key[2 * j], "%2.2x", md[j]);
-    }
-
-    return key;
-#endif
-}
-
-// Use NON-BLOCKING IO mode for performance?
-// Write only with the server's permission - which information should be kept in the cache is the concern of the server only
-// All data services should indicate whether or not the data returned is suitable for client side caching (all server plugin get methods must decide!)
-// The server should also set a recommmended expiration time (lifetime of the stored object) - overridden by the client if necessary
-
-int
-idamCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
-               LOGMALLOCLIST* logmalloclist,
-               USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
-{
-#ifdef CACHEDEV
-
-    if (!data_block->cachePermission) {
-        return -1;    // Test permission for the Client to cache this structure.
-    }
-
-#endif
-    char* key = idamCacheKey(request_block, environment);
-    UDA_LOG(UDA_LOG_DEBUG, "Caching value for key: %s\n", key);
-
-    if (key == nullptr) {
-        return -1;
-    }
-
-    char* buffer;
-    size_t bufsize = 0;
-
-    FILE* memfile = open_memstream(&buffer, &bufsize);
-
     XDR xdrs;
-    xdrstdio_create(&xdrs, memfile, XDR_ENCODE);
+    xdrstdio_create(&xdrs, fp, XDR_ENCODE);
 
     int token;
-
     protocol2(&xdrs, PROTOCOL_DATA_BLOCK, XDR_SEND, &token, logmalloclist, userdefinedtypelist, (void*)data_block,
               protocolVersion);
-    xdr_destroy(&xdrs);     // Destroy before the  file otherwise a segmentation error occurs
-    fclose(memfile);
-
-    // Expiration of the object
-    static unsigned int age_max = UDA_CACHE_EXPIRY;
-    static int init = 1;
-
-    if (init) {
-        char* env = getenv("UDA_CACHE_EXPIRY");
-
-        if (env != nullptr) {
-            age_max = (unsigned int)atoi(env);
-        }
-
-        init = 0;
-    }
 
-    time_t life = time(nullptr);
-#ifdef CACHEDEV
-
-    if (data_block->cacheExpiryTime > 0) {  // Object expiration time is set by the server
-        life += data_block->cacheExpiryTime; // Add a lifetime for the object to the current time
-    } else {
-        life += age_max;             // Add the default or client overridden lifetime for the object to the current time
-    }
-
-#else
-    life += age_max;                // Add the default or client overridden lifetime for the object to the current time
-#endif
-    memcached_return_t rc = memcached_set(&cache->memcache, key, strlen(key), buffer, bufsize, life, (uint32_t)0);
-
-    if (rc != MEMCACHED_SUCCESS) {
-        UDA_LOG(UDA_LOG_DEBUG, "Couldn't store key: %s\n", memcached_strerror(&cache->memcache, rc));
-        free(key);
-        return -1;
-    }
-
-    rc = memcached_flush_buffers(&cache->memcache);
-
-    if (rc != MEMCACHED_SUCCESS) {
-        UDA_LOG(UDA_LOG_DEBUG, "Couldn't flush buffers: %s\n", memcached_strerror(&cache->memcache, rc));
-        free(key);
-        return -1;
-    }
-
-    free(key);
-    return 0;
+    xdr_destroy(&xdrs);     // Destroy before the  file otherwise a segmentation error occurs
 }
 
-DATA_BLOCK* idamCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
-                          USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
+DATA_BLOCK*
+readCacheData(FILE* fp, LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, int protocolVersion)
 {
-    char* key = idamCacheKey(request_block, environment);
-    UDA_LOG(UDA_LOG_DEBUG, "Retrieving value for key: %s\n", key);
-
-    if (key == nullptr) {
-        return nullptr;
-    }
-
-    memcached_return rc;
-    size_t len = 0;
-    u_int32_t flags = 0;
-    char* value = nullptr;
-    value = (char*)memcached_get(&cache->memcache, key, strlen(key), &len, &flags, &rc);
-
-    if (rc != MEMCACHED_SUCCESS) {
-        UDA_LOG(UDA_LOG_DEBUG, "Couldn't retrieve key: %s\n", memcached_strerror(&cache->memcache, rc));
-        free(key);
-        return nullptr;
-    }
-
-    char* buffer;
-    size_t bufsize = 0;
-
-    FILE* memfile = open_memstream(&buffer, &bufsize);
-
-    fwrite(value, sizeof(char), len, memfile);
-    fseek(memfile, 0L, SEEK_SET);
-
     XDR xdrs;
-    xdrstdio_create(&xdrs, memfile, XDR_DECODE);
+    xdrstdio_create(&xdrs, fp, XDR_DECODE);
 
-    DATA_BLOCK* data_block = (DATA_BLOCK*)malloc(sizeof(DATA_BLOCK));
+    auto data_block = (DATA_BLOCK*)malloc(sizeof(DATA_BLOCK));
     initDataBlock(data_block);
 
     int token;
@@ -267,10 +31,6 @@ DATA_BLOCK* idamCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block,
               protocolVersion);
 
     xdr_destroy(&xdrs);     // Destroy before the  file otherwise a segmentation error occurs
-    fclose(memfile);
-    free(key);
 
     return data_block;
-}
-
-#endif // NOLIBMEMCACHED
+}
\ No newline at end of file
diff --git a/source/cache/cache.h b/source/cache/cache.h
old mode 100755
new mode 100644
index 5805e7b5..f04d1718
--- a/source/cache/cache.h
+++ b/source/cache/cache.h
@@ -1,57 +1,23 @@
 #ifndef UDA_CACHE_CACHE_H
 #define UDA_CACHE_CACHE_H
 
-#include <time.h>
-
+#include <cstdio>
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#define CACHE_NOT_OPENED    1
-#define CACHE_NOT_AVAILABLE 2
-#define CACHE_AVAILABLE     3
-
-#define UDA_CACHE_HOST     "localhost"     // Override these with environment variables with the same name
-#define UDA_CACHE_PORT     11211
-#define UDA_CACHE_EXPIRY   86400           //24*3600       // Lifetime of the object in Secs
-
-// Cache permissions
-
-#define UDA_PLUGIN_NOT_OK_TO_CACHE  0   // Plugin state management incompatible with client side cacheing
-#define UDA_PLUGIN_OK_TO_CACHE      1   // Data are OK for the Client to Cache
-
-#define UDA_PLUGIN_CACHE_DEFAULT  UDA_PLUGIN_NOT_OK_TO_CACHE // The cache permission to use as the default
-
-#define UDA_PLUGIN_NO_CACHE_TYPE   0
-#define UDA_PLUGIN_MEM_CACHE_TYPE  1
-#define UDA_PLUGIN_FILE_CACHE_TYPE 2
-
-typedef struct UdaCache UDA_CACHE;
-
-LIBRARY_API UDA_CACHE* idamOpenCache();
-
-LIBRARY_API void idamFreeCache();
-
-LIBRARY_API char* idamCacheKey(const REQUEST_BLOCK* request_block, ENVIRONMENT environment);
-
-LIBRARY_API int idamCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
-        LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment,
-        int protocolVersion);
+LIBRARY_API void writeCacheData(FILE* fp, LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                                const DATA_BLOCK* data_block, int protocolVersion);
 
-LIBRARY_API DATA_BLOCK* idamCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
-        USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion);
+LIBRARY_API DATA_BLOCK*
+readCacheData(FILE* fp, LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, int protocolVersion);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif // UDA_CACHE_CACHE_H
+#endif // UDA_CACHE_CACHE_H
\ No newline at end of file
diff --git a/source/cache/fileCache.cpp b/source/cache/fileCache.cpp
index e4c4d5bf..1b5fc9e2 100755
--- a/source/cache/fileCache.cpp
+++ b/source/cache/fileCache.cpp
@@ -4,7 +4,7 @@
 Contents of DATA_BLOCK structures written to a local cache
 Date/Time Stamp used to build in automatic obsolescence.
 Unique hash key used to identify cached data using signal/source arguments
-Cache located in directory given by environment variables IDAM_CACHE_DIR, IDAM_CACHE_TABLE
+Cache located in directory given by environment variables UDA_CACHE_DIR, UDA_CACHE_TABLE
 Maximum number of cached files prevents ...
 Maximum size ...
 Cache is communal: shared database table
@@ -20,124 +20,179 @@ unsigned int Hash key
 unsigned long long timestamp
 char Filename[]
 unsigned long long properties
-char signal[]	- cannot contain a ';' character
+char signal[]    - cannot contain a ';' character
 char source[]
 */
 
 #include "fileCache.h"
 
 #ifdef _WIN32
-int idamClientLockCache(FILE **db, short type) {
+DATA_BLOCK* udaFileCacheRead(const REQUEST_BLOCK* request_block,
+                             LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                             int protocolVersion)
+{
+    return nullptr;
+}
+
+int udaFileCacheWrite(const DATA_BLOCK* data_block, const REQUEST_BLOCK* request_block,
+                      LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                      int protocolVersion)
+{
     return 0;
 }
 #else
 
+#include "cache.h"
+
 #include <fcntl.h>
 #include <cstdlib>
 #include <cerrno>
 #include <string>
 #include <vector>
+#include <boost/algorithm/string.hpp>
+#include <boost/optional.hpp>
 
 #include <clientserver/errorLog.h>
 #include <clientserver/stringUtils.h>
-#include <structures/struct.h>
-#include <client/clientXDRStream.h>
-#include <clientserver/xdrlib.h>
-#include <client/udaClient.h>
+#include <sstream>
 
-REQUEST_BLOCK* request_block_ptr = nullptr;
+constexpr int CACHE_MAXCOUNT            = 100; // Max Attempts at obtaining a database table lock
+constexpr int CACHE_HOURSVALID          = 0;
+constexpr int CACHE_MAXDEADRECORDS      = 10;
+constexpr int CACHE_MAXRECORDS          = 1000; // Including comment records
+constexpr int CACHE_STATSLENGTH         = 30;
+constexpr int CACHE_MAXLOCKTIME         = 100;  // Maximum Grace period after time expiry when a file record is locked
 
-// Cache database table lock/unlock
-// nullptr File handle returned if there is no cache
+namespace {
 
-int idamClientLockCache(FILE** db, short type)
+enum class LockActionType : short
 {
-    // Types of Lock: F_RDLCK, F_WRLCK, or F_UNLCK
+    READ    = F_RDLCK,
+    WRITE   = F_WRLCK,
+    UNLOCK  = F_UNLCK
+};
 
-    FILE* fh = nullptr;
-    struct flock lock;
-    struct timespec requested;
-    struct timespec remaining;
-    int err = 0;
-    int rc = 0;
-    int delay = 0;
-    int count = 0;
+struct CacheStats
+{
+    unsigned long recordCount;
+    unsigned long deadCount;
+    long endOffset;
+};
 
-    // Open the Cache database table on locking and close on unlocking
+enum class EntryState {
+    DEAD = 0,
+    LIVE = 1,
+    LOCKED = 2,
+};
 
-    if (type == F_WRLCK) {                    // Open the Database Table and apply an Exclusive lock
-        const char* dir = getenv("UDA_CACHE_DIR");        // Where the files are located
-        const char* table = getenv("UDA_CACHE_TABLE");        // List of cached files
+struct CacheEntry
+{
+    size_t file_position = 0;
+    EntryState state = EntryState::DEAD;
+    std::string signal;
+    std::string source;
+    std::string filename;
+    unsigned long long timestamp = 0;
+    unsigned long long properties = 0;
+    unsigned long dbkey = 0;
+};
 
-        *db = nullptr;
-        if (dir == nullptr || table == nullptr) {
-            // No Cache? This is Not an Error!
-            return 0;
-        }
+} // anon namespace
 
-        std::string dbfile = std::string{ dir } + "/" + table;
+static int set_db_file_lock_state(FILE* db, LockActionType type);
+static bool is_cache_time_valid(unsigned long long timestamp);
+static bool is_cache_locked_time_valid(unsigned long long timestamp);
+static bool is_cache_file_valid(const std::string& filename);
+static boost::optional<CacheStats> get_cache_stats(FILE* db);
+static int update_cache_stats(FILE* db, CacheStats stats);
+static boost::optional<CacheStats> purge_cache(FILE* db);
+static boost::optional<CacheEntry> find_cache_entry(const REQUEST_BLOCK* request_block);
+static unsigned int xcrc32(const unsigned char* buf, int len, unsigned int init);
+static int set_entry_state(const CacheEntry& entry, EntryState state);
+static std::string get_file_path(const std::string& filename);
 
-        // Open the Cache database table
+constexpr const char* delimiter = ";";
 
-        errno = 0;
-        fh = fopen(dbfile.c_str(), "r+");    // ASCII file: Read with update (over-write)
-
-        if (fh == nullptr || errno != 0) {
-            err = 999;
-            if (errno != 0) {
-                addIdamError(SYSTEMERRORTYPE, __func__, errno, "");
-            }
-            addIdamError(CODEERRORTYPE, __func__, err, "Unable to Open the Cache Database");
-            if (fh != nullptr) {
-                fclose(fh);
-            }
-            return err;
-        }
+// Cache database table lock/unlock
+// nullptr File handle returned if there is no cache
 
-        *db = fh;                // Returned database table file handle
+std::string get_file_path(const std::string& filename)
+{
+    const char* dir = getenv("UDA_CACHE_DIR");
 
-    } else {
-        fh = *db;
+    if (dir == nullptr) {
+        return "";
     }
 
-    int fd = fileno(fh);
+    return std::string{dir} + "/" + filename;
+}
+
+FILE* open_db_file(bool create)
+{
+    // Open the Database Table and apply an Exclusive lock
+    const char* table = getenv("UDA_CACHE_TABLE");  // List of cached files
+    if (table == nullptr) {
+        return nullptr;
+    }
 
-    lock.l_whence = SEEK_SET;        // Relative to the start of the file
-    lock.l_start = 0;            // Lock applies from this byte
-    lock.l_len = 0;            // To the end of the file
-    lock.l_type = type;        // Lock type to apply
+    std::string dbfile = get_file_path(table);
+    if (dbfile.empty()) {
+        return nullptr;
+    }
 
-    rc = fcntl(fd, F_SETLK, &lock);    // Manage the Cache table lock
+    // Open the Cache database table
 
-    if (type == F_UNLCK) {
-        *db = nullptr;
-        fclose(fh);    // Close the database table
+    errno = 0;
+    FILE* fh = fopen(dbfile.c_str(), "r+"); // ASCII file: Read with update (over-write)
+    if (fh == nullptr && create) {
+        errno = 0;
+        fh = fopen(dbfile.c_str(), "w");
     }
 
-    if (rc == 0) return 0;        // Lock managed OK
+    return fh;
+}
+
+int set_db_file_lock_state(FILE* db, LockActionType type)
+{
+    int fd = fileno(db);
+
+    flock lock = {};
+    lock.l_whence = SEEK_SET;               // Relative to the start of the file
+    lock.l_start = 0;                       // Lock applies from this byte
+    lock.l_len = 0;                         // To the end of the file
+    lock.l_type = static_cast<short>(type); // Lock type to apply
+
+    int rc = fcntl(fd, F_SETLK, &lock);    // Manage the Cache table lock
+
+    if (rc == 0) {
+        // Lock managed OK
+        return 0;
+    }
 
-    if (type == F_UNLCK) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, __func__, err, "Cache file lock not released indicating problem with cache");
+    if (type == LockActionType::UNLOCK) {
+        int err = 999;
+        addIdamError(CODEERRORTYPE, __func__, err,
+                     "cache file lock not released indicating problem with cache");
         return err;
     }
 
     // Problem obtaing an exclusive file lock - wait for a random time delay and try again
+    int count = 0;
+    do {
+        int delay = 1 + (int)(10.0 * (rand() / (RAND_MAX + 1.0))); // Random delay [1,10]
 
-    delay = 1 + (int)(10.0 * (rand() / (RAND_MAX + 1.0)));    // Random delay 1->10
-    requested.tv_sec = 0;
-    requested.tv_nsec = 1000 * delay;                // Microsecs
+        timespec requested = {};
+        requested.tv_sec = 0;
+        requested.tv_nsec = 1000 * delay; // Microsecs
 
-    do {
-        rc = nanosleep(&requested, &remaining);
+        timespec remaining = {};
+        nanosleep(&requested, &remaining);
         rc = fcntl(fd, F_SETLK, &lock);
     } while (rc == -1 && count++ < CACHE_MAXCOUNT);
 
     if (rc == -1 || count >= CACHE_MAXCOUNT) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, __func__, err, "Unable to Lock the Cache Database");
-        *db = nullptr;
-        fclose(fh);
+        int err = 999;
+        addIdamError(CODEERRORTYPE, __func__, err, "unable to lock the cache database");
         return err;
     }
 
@@ -146,541 +201,447 @@ int idamClientLockCache(FILE** db, short type)
 
 // Time stamp test
 
-int idamClientCacheTimeValid(unsigned long long timestamp)
+bool is_cache_time_valid(unsigned long long timestamp)
 {
+    if (timestamp == 0) {
+        return true;
+    }
     timeval current = {};
     gettimeofday(&current, nullptr);
     if (timestamp >= (unsigned long long)current.tv_sec) {
         // Timestamp OK
-        return 1;
+        return true;
     }
-    return 0;
+    return false;
 }
 
 // Check the locked file time is within a reasonable time period - protect against possible bugs in file management
 
-int idamClientCacheLockedTimeValid(unsigned long long timestamp)
+bool is_cache_locked_time_valid(unsigned long long timestamp)
 {
     timeval current = {};
     gettimeofday(&current, nullptr);
     if ((timestamp + CACHE_MAXLOCKTIME) >= (unsigned long long)current.tv_sec) {
         // Timestamp OK
-        return 1;
+        return true;
     }
-    return 0;
+    return false;
 }
 
 // Test the File exists
 
-int idamClientCacheFileValid(const char* filename)
+bool is_cache_file_valid(const std::string& filename)
 {
-    // TODO: add proper check
-    return filename != nullptr;
+    auto path = get_file_path(filename);
+    return access(path.c_str(), F_OK) != -1;
 }
 
 // Current table statistics
 
-int idamClientGetCacheStats(FILE* db, unsigned long* recordCount, unsigned long* deadCount, unsigned long* endOffset,
-                            char csvChar)
+boost::optional<CacheStats> get_cache_stats(FILE* db)
 {
-    int err = 0;
-    char* csv = nullptr;
-    char* next = nullptr;
-    char work[CACHE_FIRSTRECORDLENGTH + 1];
     rewind(db);
-    if (fgets(work, CACHE_FIRSTRECORDLENGTH, db) == nullptr) {
-        err = 999;
-        return err;
+    char buffer[CACHE_STATSLENGTH + 1];
+    if (fgets(buffer, CACHE_STATSLENGTH, db) == nullptr) {
+        fseek(db, 0, SEEK_END);
+        if (ftell(db) == 0) {
+            update_cache_stats(db, {});
+            return CacheStats{};
+        }
+        return {};
     }
-    LeftTrimString(TrimString(work));
-    next = work;
-    if ((csv = strchr(next, csvChar)) != nullptr) {
-        // Split the record into fields using delimiter character
-        csv[0] = '\0';
-    }
-    TrimString(next);
-    LeftTrimString(next);
-    *recordCount = (unsigned int)strtoul(next, nullptr, 10);
-    next = &csv[1];
-    if ((csv = strchr(next, csvChar)) != nullptr) csv[0] = '\0';
-    *deadCount = (unsigned int)strtoul(next, nullptr, 10);
-    next = &csv[1];
-    *endOffset = (unsigned int)strtoul(next, nullptr, 10);
-    return 0;
-}
-
-// Update statistics
-
-void idamClientUpdateCacheStats(FILE* db, unsigned long recordCount, unsigned long deadCount, unsigned long endOffset,
-                                char csvChar)
-{
-    char work[CACHE_FIRSTRECORDLENGTH + 1];
-    rewind(db);
-    // Updated statistics record
-    sprintf(work, "%lu%c%lu%c%lu", recordCount, csvChar, deadCount, csvChar, endOffset);
-    int lstr = (int)strlen(work);
-    for (int i = lstr; i < CACHE_FIRSTRECORDLENGTH; i++) {
-        // Pack remaining record with space chars
-        work[i] = ' ';
-    }
-    work[CACHE_FIRSTRECORDLENGTH - 1] = '\n';
-    work[CACHE_FIRSTRECORDLENGTH] = '\0';
-    fwrite(work, sizeof(char), CACHE_FIRSTRECORDLENGTH, db);                    // Update
-    fflush(db);
-}
-
-int idamClientPurgeCache(FILE* db, unsigned long recordCount, unsigned long* endOffset)
-{
-    unsigned short status = 0;
-    unsigned long dbkey = 0;
-    unsigned long validRecordCount = 0;
 
-    unsigned long long timestamp = 0;
-    char filename[MAXFILENAME];
+    std::vector<std::string> tokens;
+    boost::split(tokens, buffer, boost::is_any_of(delimiter));
 
-    char csvChar = ';';
-    char buffer[STRING_LENGTH];
-    char* p = nullptr;
-    char* csv = nullptr;
-    char* next = nullptr;
+    CacheStats stats = {};
+    stats.recordCount = std::stoul(tokens[0]);
+    stats.deadCount = std::stoul(tokens[1]);
+    stats.endOffset = std::stol(tokens[2]);
 
-    char* dir = getenv("UDA_CACHE_DIR");        // Where the files are located
+    // If there are too many dead records, then compact the database table
+    if (stats.deadCount >= CACHE_MAXDEADRECORDS) {
+        auto maybe_updated_stats = purge_cache(db);
+        if (!maybe_updated_stats) {
+            addIdamError(CODEERRORTYPE, __func__, 999, "failed to purge cache");
+            return {};
+        }
+        stats = maybe_updated_stats.get();
+    }
 
-    // Remove dead records to compact the database table
+    return stats;
+}
 
-    fseek(db, CACHE_FIRSTRECORDLENGTH, SEEK_SET);        // rewind the file to the beginning of the second record
+/**
+ * Update statistics
+ * @param db cache file
+ * @param stats
+ * @return 0 on success, else error code
+ */
+int update_cache_stats(FILE* db, CacheStats stats)
+{
+    std::stringstream ss;
+    ss << stats.recordCount << delimiter << stats.deadCount << delimiter << stats.endOffset;
+
+    std::string stats_line = ss.str();
+
+    size_t size = stats_line.size();
+    if (size < CACHE_STATSLENGTH - 1) {
+        rewind(db);
+        fwrite(stats_line.c_str(), sizeof(char), size, db);
+        for (size_t i = size; i < CACHE_STATSLENGTH - 1; i++) {
+            // Pack remaining record with space chars
+            fputc(' ', db);
+        }
+        fputc('\n', db);
+    } else {
+        THROW_ERROR(999, "invalid cache stats record");
+    }
 
-    std::vector<std::string> table(recordCount);
-    std::vector<unsigned long long> timestamplist(recordCount);
+    fflush(db);
+    return 0;
+}
 
-    unsigned long count = 0;
-    while (count++ < recordCount && !feof(db) && fgets(buffer, STRING_LENGTH, db) != nullptr) {
-        // Read each record
+/**
+ * Remove dead records to compact the database table
+ * @param db
+ * @return
+ */
+boost::optional<CacheStats> purge_cache(FILE* db)
+{
+    // rewind the file to the beginning of the records
+    fseek(db, CACHE_STATSLENGTH, SEEK_SET);
 
-        LeftTrimString(TrimString(buffer));
-        dbkey = 0;
+    std::vector<std::pair<unsigned long long, std::string>> table;
 
-        if (buffer[0] == '#') {            // Preserve comments
-            table[validRecordCount++] = buffer;
+    char* line = nullptr;
+    size_t n = 0;
+    while (getline(&line, &n, db) >= 0) {
+        if (line[0] == '#') {
+            // Preserve comments
+            table.emplace_back(std::make_pair(0, line));
             continue;
         }
 
-        if (buffer[0] == '\n') {
+        if (line[0] == '\n') {
             continue;
         }
 
-        for (int i = 0; i < 4; i++) {
-            if ((csv = strchr(next, csvChar)) != nullptr) csv[0] = '\0';
-            TrimString(next);
-            LeftTrimString(next);
-            switch (i) {
-                case 0:    // Status
-                    status = (unsigned short)strtoul(next, nullptr, 10);
-                    break;
-                case 1:    // Hash key
-                    dbkey = (unsigned int)strtoul(next, nullptr, 10);
-                    break;
-                case 2:    // Time Stamp
-                    timestamp = strtoull(next, nullptr, 10);
-                    break;
-                case 3:    // Cached Filename
-                    strcpy(filename, next);
-                    if ((p = strchr(filename, '\n')) != nullptr) p[0] = '\0';    // Remove training line feed
-                    break;
-                default:
-                    break;
-            }
-            if (status == CACHE_DEADRECORD) break;    // Skip this record - it's marked as dead! purge by ignoring it
-            if (csv != nullptr) next = &csv[1];    // Next element starting point
-        }
-        if (dbkey != 0) {
-            // Check the records is valid (always if locked by a process)
-            if ((status == CACHE_LOCKEDRECORD && idamClientCacheLockedTimeValid(timestamp)) ||
-                (idamClientCacheTimeValid(timestamp) && idamClientCacheFileValid(filename))) {
-                table[validRecordCount] = buffer;
-                timestamplist[validRecordCount] = timestamp;    // Sort on this to purge oldest records
-                validRecordCount++;
-            } else {
-                std::string dbfile;
-                dbfile = std::string{ dir } + "/" + filename;
-                // Delete the cached file and ignore the record - purge
-                remove(dbfile.c_str());
-            }
+        std::vector<std::string> tokens;
+        boost::split(tokens, line, boost::is_any_of(delimiter));
+
+        unsigned short state = std::stoul(tokens[0]);
+        unsigned long long timestamp = std::stoull(tokens[2]);
+        std::string filename = tokens[3];
+
+        if (state == static_cast<int>(EntryState::DEAD)) {
+            std::string cache_file = get_file_path(filename);
+            remove(cache_file.c_str());
+            continue;
         }
+
+        table.emplace_back(std::make_pair(timestamp, line));
     }
 
-    // Drop the oldest record?
+    using pair_type = std::pair<unsigned long long, std::string>;
+    std::sort(table.begin(), table.end(), [](const pair_type& a, const pair_type& b){ return a.first < b.first; });
 
-    if (validRecordCount > CACHE_MAXRECORDS - 1) validRecordCount = CACHE_MAXRECORDS - 1;
+    while (table.size() > CACHE_MAXRECORDS) {
+        std::vector<std::string> tokens;
+        boost::split(tokens, line, boost::is_any_of(delimiter));
 
-    // Write the compacted table in time order (youngest first) following a sort on the timestamp
+        std::string filename = tokens[3];
+        std::string cache_file = get_file_path(filename);
+        remove(cache_file.c_str());
 
-    fseek(db, CACHE_FIRSTRECORDLENGTH, SEEK_SET);    // Position at the start of record 2
+        table.pop_back();
+    }
+
+    fseek(db, CACHE_STATSLENGTH, SEEK_SET); // Position at the start of records
 
     errno = 0;
-    for (unsigned long i = 0; i < validRecordCount; i++) {
-        size_t lstr = table[i].size();
-        count = fwrite(table[i].c_str(), sizeof(char), lstr, db);    // Write all valid records
-        if (count != lstr || errno != 0) {
-            int err = 999;
-            return -err;
+    for (const auto& pair : table) {
+        const auto& record = pair.second;
+        size_t count = fwrite(record.c_str(), sizeof(char), record.size(), db);
+        if (count != record.size() || errno != 0) {
+            addIdamError(CODEERRORTYPE, __func__, 999, "Failed to write cache record");
+            return {};
         }
     }
 
-    *endOffset = (unsigned long)ftell(db);            // Append or overwrite new records from this location (End of active records)
-
-    fwrite("\n", sizeof(char), 1, db);        // Insert a new line at the end of the valid set of records
+    CacheStats stats = {};
+    stats.endOffset = ftell(db);
+    stats.recordCount = table.size();
+    stats.deadCount = 0;
 
-    // Update statistics
+    update_cache_stats(db, stats);
 
-    idamClientUpdateCacheStats(db, validRecordCount, 0, *endOffset, csvChar);
-
-    return (int)validRecordCount;
+    return stats;
 }
 
-int idamClientReadCache(DATA_BLOCK* data_block, char* filename, int protocolVersion)
+DATA_BLOCK* udaFileCacheRead(const REQUEST_BLOCK* request_block,
+                             LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                             int protocolVersion)
 {
-    int err = 0;
-    int rc = 0;
-    XDR XDRInput;
-    XDR* xdrs = clientInput;
-    FILE* xdrfile = nullptr;
-    void* data = nullptr;
-
-    err = 0;
-
-    if (filename == nullptr || filename[0] == '\0') {
-        return 0;
+    auto maybe_entry = find_cache_entry(request_block);
+    if (!maybe_entry) {
+        return nullptr;
     }
 
-    do {
-        // Error Trap
+    auto entry = maybe_entry.get();
 
-        // Create input xdr file stream
-
-        errno = 0;
-
-        if ((xdrfile = fopen(filename, "rb")) == nullptr || errno != 0) {    // Read cached file
-            err = 999;
-            if (errno != 0) {
-                addIdamError(SYSTEMERRORTYPE, "idamClientReadCache", errno, "");
-            }
-            addIdamError(CODEERRORTYPE, __func__, err, "Unable to Open the Cached Data File");
-            break;
-        }
-
-        xdr_destroy(xdrs);    // *** xdrs not initialised?
-        XDRstdioFlag = 1;
-        xdrstdio_create(&XDRInput, xdrfile, XDR_DECODE);
-        xdrs = &XDRInput;                        // Switch from stream to file
-
-        // Initialise structure passing mechanism
-
-        auto logmalloclist = (LOGMALLOCLIST*)malloc(sizeof(LOGMALLOCLIST));
-        initLogMallocList(logmalloclist);
-        auto userdefinedtypelist = (USERDEFINEDTYPELIST*)malloc(sizeof(USERDEFINEDTYPELIST));
-        auto udt_received = (USERDEFINEDTYPE*)malloc(sizeof(USERDEFINEDTYPE));
-        initUserDefinedTypeList(userdefinedtypelist);
+    if (!is_cache_file_valid(entry.filename)
+        || (entry.state == EntryState::LIVE && !is_cache_time_valid(entry.timestamp))
+        || (entry.state == EntryState::LOCKED && !is_cache_locked_time_valid(entry.timestamp))) {
+        set_entry_state(entry, EntryState::DEAD);
+        return nullptr;
+    } else {
+        set_entry_state(entry, EntryState::LOCKED);
+    }
 
-        rc = xdr_userdefinedtypelist(xdrs, userdefinedtypelist); // receive the full set of known named structures
+    std::string path = get_file_path(entry.filename);
 
-        if (!rc) {
-            err = 999;
-            addIdamError(CODEERRORTYPE, __func__, err, "Failure receiving Structure Definitions");
-            break;
-        }
-
-        initUserDefinedType(udt_received);
+    errno = 0;
 
-        rc = rc && xdrUserDefinedTypeData(xdrs, logmalloclist, userdefinedtypelist, udt_received, &data, protocolVersion); // receive the Data
+    FILE* xdrfile;
+    if ((xdrfile = fopen(path.c_str(), "rb")) == nullptr || errno != 0) {
+        THROW_ERROR(0, "Unable to Open the Cached Data File");
+    }
 
-        if (!rc) {
-            err = 999;
-            addIdamError(CODEERRORTYPE, __func__, err, "Failure receiving Data and Structure Definition");
-            break;
-        }
+    auto data_block = readCacheData(xdrfile, logmalloclist, userdefinedtypelist, protocolVersion);
 
-        // Close the stream and file
+    fclose(xdrfile);
 
-        fflush(xdrfile);
-        fclose(xdrfile);
+    set_entry_state(entry, EntryState::LIVE);
 
-        // Switch back to the normal xdr record stream
+    return data_block;
+}
 
-        idamCreateXDRStream();
-        xdrs = clientInput;
-        XDRstdioFlag = 0;
+boost::optional<CacheEntry> processLine(const std::string& line, size_t position)
+{
+    if (line[0] == '#' || line[0] == '\n') {
+        return {};
+    }
 
-        if (STR_EQUALS(udt_received->name, "SARRAY")) {            // expecting this carrier structure
+    std::vector<std::string> tokens;
+    boost::split(tokens, line, boost::is_any_of(delimiter));
 
-            auto general_block = (GENERAL_BLOCK*)malloc(sizeof(GENERAL_BLOCK));
+    CacheEntry entry;
+    entry.file_position = position;
 
-            auto s = (SARRAY*)data;
-            if (s->count != data_block->data_n) {                // check for consistency
-                err = 999;
-                addIdamError(CODEERRORTYPE, __func__, err, "Inconsistent S Array Counts");
+    int i = 0;
+    for (const auto& token : tokens) {
+        switch (i) {
+            case 0:
+                entry.state = static_cast<EntryState>(std::stoi(token));
+                break;
+            case 1:
+                entry.dbkey = static_cast<unsigned int>(std::stoul(token));
+                break;
+            case 2:
+                entry.timestamp = std::stoull(token);
+                break;
+            case 3:
+                entry.filename = token;
                 break;
-            }
-            data_block->data = (char*)fullNTree;        // Global Root Node with the Carrier Structure containing data
-            data_block->opaque_block = (void*)general_block;
-            general_block->userdefinedtype = udt_received;
-            general_block->userdefinedtypelist = userdefinedtypelist;
-            general_block->logmalloclist = logmalloclist;
-            general_block->lastMallocIndex = 0;
-        } else {
-            err = 999;
-            addIdamError(CODEERRORTYPE, __func__, err, "Name of Received Data Structure Incorrect");
+            case 4:
+                entry.properties = std::stoull(token);
+                break;
+            case 5:
+                entry.signal = token;
+                break;
+            case 6:
+                if (!token.empty() && token[token.size() - 1] == '\n') {
+                    entry.source = token.substr(0, token.size() - 1);
+                } else {
+                    entry.source = token;
+                }
+                break;
+            default:
+                break;
+        }
+        if (entry.state == EntryState::DEAD) {
+            // Don't need the remaining information on this record!
             break;
         }
+        ++i;
+    }
 
-    } while (0);
-
-    return err;
+    return entry;
 }
 
-// Identify the name of the required cache file
-
-int idamClientGetCacheFilename(REQUEST_BLOCK* request_block, char** cacheFilename)
+unsigned int generate_hash_key(const REQUEST_BLOCK* request_block)
 {
-    int rc = 0;
-    unsigned short status = 0;
-    unsigned short outcome = 0;
-    unsigned long position = 0;
-    unsigned long endOffset = 0;
-    unsigned long recordCount = 0;
-    unsigned long deadCount = 0;
-    FILE* db = nullptr;
-
-    unsigned int dbkey = 0;
-
-    unsigned long long timestamp = 0;
-    char filename[MAXFILENAME];
-    //unsigned long long properties = 0;
-
-    char csvChar = ';';
-    char buffer[STRING_LENGTH];
-    char signal[STRING_LENGTH];
-    char source[STRING_LENGTH];
-    char* p, * csv, * next;
-
-    // Lock the database
-
-    if ((rc = idamClientLockCache(&db, F_WRLCK)) != 0 || db == nullptr) return rc;
-
     // Generate a Hash Key (not guaranteed unique)
-
     unsigned int key = 0;
     // combine CRC has keys
     key = xcrc32((const unsigned char*)request_block->signal, (int)strlen(request_block->signal), key);
     key = xcrc32((const unsigned char*)request_block->source, (int)strlen(request_block->source), key);
+    return key;
+}
 
-    // Sequentially read all records and test against the hash key (small file so not that inefficient)
-
-    outcome = CACHE_NORECORD;
-
-    // Table stats
-
-    idamClientGetCacheStats(db, &recordCount, &deadCount, &endOffset, csvChar);
-
-    fseek(db, CACHE_FIRSTRECORDLENGTH, SEEK_SET);    // Position at the start of record 2
-    position = (unsigned long)ftell(db);
-
-    while (!feof(db) && fgets(buffer, STRING_LENGTH, db) != nullptr) {
-        LeftTrimString(TrimString(buffer));
-        do {
-            dbkey = 0;
-            if (buffer[0] == '#') break;
-            if (buffer[0] == '\n') break;
-            next = buffer;
-
-            for (int i = 0; i < 7; i++) {
-                if ((csv = strchr(next, csvChar)) != nullptr) {
-                    csv[0] = '\0';
-                }    // Split the record into fields using delimiter character
-                TrimString(next);
-                LeftTrimString(next);
-                switch (i) {
-                    case 0:    // Status
-                        status = (unsigned short)strtoul(next, nullptr, 10);
-                        break;
-                    case 1:    // Hash key
-                        dbkey = (unsigned int)strtoul(next, nullptr, 10);
-                        break;
-                    case 2:    // Time Stamp
-                        timestamp = strtoull(next, nullptr, 10);
-                        break;
-                    case 3:    // Cached Filename
-                        strcpy(filename, next);
-                        if ((p = strchr(filename, '\n')) != nullptr) p[0] = '\0';    // Remove training line feed
-                        break;
-                    case 4:    // Properties
-                        //properties = (unsigned long long)strtoull(next, nullptr, 10);
-                        break;
-                    case 5:    // signal
-                        strcpy(signal, next);
-                        if ((p = strchr(signal, '\n')) != nullptr) p[0] = '\0';
-                        break;
-                    case 6:    // source
-                        strcpy(source, next);
-                        if ((p = strchr(source, '\n')) != nullptr) p[0] = '\0';
-                        break;
-                    default:
-                        break;
-                }
-                if (status == CACHE_DEADRECORD) break;    // Don't need the remaining information on this record!
-                if (csv != nullptr) next = &csv[1];        // Next element starting point
-            }
-        } while (0);
-
-        if (status == CACHE_DEADRECORD || buffer[0] == '#' || buffer[0] == '\n') continue;
-
-        if (key == dbkey) {            // Key found: Use this record if within time limitation and the file exists
-            if (idamClientCacheTimeValid(timestamp) && idamClientCacheFileValid(filename)) {
-                if ((strcmp(request_block->signal, signal) != 0) &&
-                    (strcmp(request_block->source, source) != 0)) {        // Additional Check
-                    outcome = CACHE_RECORDFOUND;
-                    break;
-                }        //  keep searching as signal and source strings do not match - possible hash key duplicate
-            } else {
-                if (status == CACHE_LIVERECORD ||
-                    (status == CACHE_LOCKEDRECORD &&
-                     idamClientCacheLockedTimeValid(timestamp))) {    // Record needs purging but only if not locked
-                    outcome = CACHE_PURGERECORD;
-                    deadCount++;
-                    break;
-                }
-            }
-        }
-
-        position = (unsigned long)ftell(db);    // Start of next record
+int set_entry_state(const CacheEntry& entry, EntryState state)
+{
+    int rc = 0;
+    FILE* db = open_db_file(false);
+    if (db == nullptr || (rc = set_db_file_lock_state(db, LockActionType::WRITE)) != 0) {
+        return rc;
     }
 
-    if (outcome == CACHE_RECORDFOUND) {        // Record found and Timestamp OK
+    fseek(db, entry.file_position, SEEK_SET);
+    char buffer[3];
+    sprintf(buffer, "%d%c", static_cast<int>(state), delimiter[0]);
+    fwrite(buffer, sizeof(char), 2, db);
 
-        int lstr = (int)strlen(filename) + 1;
-        *cacheFilename = (char*)malloc(lstr * sizeof(char));
-        strcpy(*cacheFilename, filename);
+    rc = set_db_file_lock_state(db, LockActionType::UNLOCK);    // release lock
+    fclose(db);
 
-        // Lock the cache file record using the status value only - not a record lock on the table
-
-        fseek(db, position, SEEK_SET);    // Goto start of last record read and change status to LOCKED
-        sprintf(buffer, "%d%c", CACHE_LOCKEDRECORD, csvChar);
-        fwrite(buffer, sizeof(char), 2, db);
+    return rc;
+}
 
-    } else if (outcome == CACHE_PURGERECORD) {
+// Identify the name of the required cache file
+boost::optional<CacheEntry> find_cache_entry(const REQUEST_BLOCK* request_block)
+{
+    // Lock the database
+    FILE* db = open_db_file(false);
+    if (db == nullptr || set_db_file_lock_state(db, LockActionType::READ) != 0) {
+        return {};
+    }
 
-        // Cache has expired. Remove table entry and delete the data file
+    unsigned int key = generate_hash_key(request_block);
 
-        fseek(db, position, SEEK_SET);    // Goto start of last record read and mark for removal: status changed to DEAD
-        sprintf(buffer, "%d%c", CACHE_DEADRECORD, csvChar);
-        fwrite(buffer, sizeof(char), 2, db);
+    fseek(db, CACHE_STATSLENGTH, SEEK_SET);    // Position at the start of record 2
 
-        // If there are too many dead records, then compact the database table
+    boost::optional<CacheEntry> found_entry;
 
-        if (deadCount >= CACHE_MAXDEADRECORDS) {
-            recordCount = (unsigned long)idamClientPurgeCache(db, recordCount, &endOffset);
-            deadCount = 0;
-        } else {
-            char* dir = getenv("UDA_CACHE_DIR");        // Where the files are located
-            std::string dbfile = std::string{ dir } + "/" + filename;
-            remove(dbfile.c_str());
+    char* line = nullptr;
+    size_t n = 0;
+    size_t position = CACHE_STATSLENGTH;
+    size_t len;
+    while ((len = getline(&line, &n, db)) != static_cast<size_t>(-1)) {
+        auto maybe_entry = processLine(line, position);
+        position += len;
+        if (!maybe_entry) {
+            continue;
         }
 
-        idamClientUpdateCacheStats(db, recordCount, deadCount, endOffset, csvChar);
+        auto& entry = maybe_entry.get();
+        if (entry.state == EntryState::DEAD) {
+            continue;
+        }
 
+        if (key == entry.dbkey
+            && (entry.signal == request_block->signal && entry.source == request_block->source)) {
+            found_entry = entry;
+            break;
+        }
     }
 
-    // Free	the Lock
-
-    rc = idamClientLockCache(&db, F_UNLCK);    // release lock
+    free(line);
+    set_db_file_lock_state(db, LockActionType::UNLOCK);
+    fclose(db);
 
-    return rc;
+    return found_entry;
 }
 
-
-// Write a new record
-
-int idamClientWriteCache(char* filename)
+int add_cache_record(const REQUEST_BLOCK* request_block, const char* filename)
 {
-    int err = 0;
-    int rc = 0;
-    FILE* db = nullptr;
-
-    REQUEST_BLOCK* request_block = request_block_ptr;    // Global pointer to the request block
-
-    unsigned short status = CACHE_LIVERECORD;
-    unsigned long recordCount;
-    unsigned long deadCount;
-    unsigned long endOffset;
-
-    unsigned long long timestamp = 0;
-    unsigned long long properties = 0;
-
-    char csvChar = ';';
-    char buffer[STRING_LENGTH];
-
     // Generate a Hash Key (not guaranteed unique)
-
     unsigned int key = 0;
     // combine CRC has keys
     key = xcrc32((const unsigned char*)request_block->signal, (int)strlen(request_block->signal), key);
     key = xcrc32((const unsigned char*)request_block->source, (int)strlen(request_block->source), key);
 
     // Generate a timestamp
-
-    struct timeval current;
-    gettimeofday(&current, nullptr);
-
-    timestamp = (unsigned long long)current.tv_sec + CACHE_HOURSVALID * 3600 + 60;
+    unsigned long long timestamp = 0;
+    if (CACHE_HOURSVALID != 0) {
+        timeval current = {};
+        gettimeofday(&current, nullptr);
+        timestamp = (unsigned long long)current.tv_sec + CACHE_HOURSVALID * 3600 + 60;
+    }
 
     // Create the new record string
-
-    sprintf(buffer, "%d%c%du%c%llu%c%s%c%llu%c%s%c%s\n", status, csvChar, key, csvChar,
-            timestamp, csvChar, filename, csvChar, properties, csvChar, request_block->signal,
-            csvChar, request_block->source);
+    std::stringstream ss;
+    constexpr int properties = 0;
+    ss  << static_cast<int>(EntryState::LIVE) << delimiter
+        << key << delimiter
+        << timestamp << delimiter
+        << filename << delimiter
+        << properties << delimiter
+        << request_block->signal << delimiter
+        << request_block->source << '\n';
+    std::string record = ss.str();
 
     // Append the new record to the database table
-
-    if ((rc = idamClientLockCache(&db, F_WRLCK)) != 0 || db == nullptr) return rc;
+    int rc = 0;
+    FILE* db = open_db_file(true);
+    if (db == nullptr || (rc = set_db_file_lock_state(db, LockActionType::WRITE)) != 0) {
+        THROW_ERROR(rc, "unable to get lock cache file");
+    }
 
     // Current table statistics
+    auto maybe_stats = get_cache_stats(db);
+    if (!maybe_stats) {
+        rc = set_db_file_lock_state(db, LockActionType::UNLOCK);    // Free the Lock and File
+        THROW_ERROR(rc, "unable to get cache stats");
+    }
+    CacheStats stats = maybe_stats.get();
 
-    if ((err = idamClientGetCacheStats(db, &recordCount, &deadCount, &endOffset, csvChar)) != 0) {
-        rc = idamClientLockCache(&db, F_UNLCK);    // Free	the Lock and File
-        return err;
+    // Append a new record at the file position (always the end of the valid set of records)
+    if (stats.endOffset == 0) {
+        fseek(db, 0, SEEK_END);
+        stats.endOffset = ftell(db);
     }
 
-    // Too many records when the new record is added?
+    fseek(db, stats.endOffset, SEEK_SET);
+    fwrite(record.c_str(), sizeof(char), record.size(), db);
+    stats.endOffset = ftell(db);
+
+    fflush(db);
+    stats.recordCount++;
 
-    if (recordCount >= CACHE_MAXRECORDS - 1 ||
-        deadCount >= CACHE_MAXDEADRECORDS) {        // purge dead records + oldest active record
-        recordCount = (unsigned long)idamClientPurgeCache(db, recordCount, &endOffset);
-        deadCount = 0;
+    rc = update_cache_stats(db, stats);
+    if (rc != 0) {
+        THROW_ERROR(rc, "unable to update cache stats");
     }
 
-    // Append a new record at the file position (always the end of the valid set of records)
+    return set_db_file_lock_state(db, LockActionType::UNLOCK);
+}
 
-    if (endOffset == 0) {
-        fseek(db, 0, SEEK_END);
-        endOffset = (unsigned long)ftell(db);
+std::string generate_cache_filename(const REQUEST_BLOCK* request_block)
+{
+    unsigned int key = generate_hash_key(request_block);
+    return std::string{"uda_"} + std::to_string(key) + ".cache";
+}
+
+int udaFileCacheWrite(const DATA_BLOCK* data_block, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
+                      USERDEFINEDTYPELIST* userdefinedtypelist, int protocolVersion)
+{
+    auto maybe_entry = find_cache_entry(request_block);
+    if (maybe_entry) {
+        // Entry already exists, do not add another
+        return 0;
     }
 
-    fseek(db, endOffset, SEEK_SET);
-    fwrite(buffer, sizeof(char), strlen(buffer), db);
-    endOffset = (unsigned long)ftell(db);
-    fwrite("\n", sizeof(char), 1, db);
+    std::string filename = generate_cache_filename(request_block);
+    std::string path = get_file_path(filename);
 
-    fflush(db);
-    recordCount++;
+    FILE* xdrfile;
+    errno = 0;
+    if ((xdrfile = fopen(path.c_str(), "wb")) == nullptr || errno != 0) {
+        THROW_ERROR(0, "unable to create the Cached Data File");
+    }
 
-    // Update statistics
+    writeCacheData(xdrfile, logmalloclist, userdefinedtypelist, data_block, protocolVersion);
 
-    idamClientUpdateCacheStats(db, recordCount, deadCount, endOffset, csvChar);
+    fclose(xdrfile);
 
-    idamClientLockCache(&db, F_UNLCK);    // release lock
+    int rc = add_cache_record(request_block, filename.c_str());
+    if (rc != 0) {
+        THROW_ERROR(rc, "unable to add cache record");
+    }
 
     return 0;
-
 }
 
 /*
@@ -692,23 +653,23 @@ int idamClientWriteCache(char* filename)
 
    if the data is available from the cache
         test the timestamp
-	if timestamp OK
-		read the data
-		free the lock
-	else
-		remove database entry
-		remove cached file
-		free the lock
-		access the original data source
+    if timestamp OK
+        read the data
+        free the lock
+    else
+        remove database entry
+        remove cached file
+        free the lock
+        access the original data source
    else
-	free the lock
-	access the original data source
+    free the lock
+    access the original data source
 
    if new data accessed
-   	lock the cache database
-	add new record
-	write new cache file
-	free the lock
+       lock the cache database
+    add new record
+    write new cache file
+    free the lock
 */
 
 //=========================================================================================
@@ -760,19 +721,19 @@ int idamClientWriteCache(char* filename)
 
      for (int i = 0; i < 256; i++)
        {
-	 for (c = i << 24, j = 8; j > 0; --j)
-	   c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
-	 table[i] = c;
+     for (c = i << 24, j = 8; j > 0; --j)
+       c = c & 0x80000000 ? (c << 1) ^ 0x04c11db7 : (c << 1);
+     table[i] = c;
        }
 
      printf ("static const unsigned int crc32_table[] =\n{\n");
      for (int i = 0; i < 256; i += 4)
        {
-	 printf ("  0x%08x, 0x%08x, 0x%08x, 0x%08x",
-		 table[i + 0], table[i + 1], table[i + 2], table[i + 3]);
-	 if (i + 4 < 256)
-	   putchar (',');
-	 putchar ('\n');
+     printf ("  0x%08x, 0x%08x, 0x%08x, 0x%08x",
+         table[i + 0], table[i + 1], table[i + 2], table[i + 3]);
+     if (i + 4 < 256)
+       putchar (',');
+     putchar ('\n');
        }
      printf ("};\n");
      return 0;
diff --git a/source/cache/fileCache.h b/source/cache/fileCache.h
index 1d3519ae..ebc39a9f 100755
--- a/source/cache/fileCache.h
+++ b/source/cache/fileCache.h
@@ -1,56 +1,23 @@
-#ifndef UDA_FILECACHE_H
-#define UDA_FILECACHE_H
-
-#include <stdio.h>
-#include <time.h>
+#ifndef UDA_CACHE_FILECACHE_H
+#define UDA_CACHE_FILECACHE_H
 
 #include <clientserver/udaStructs.h>
-
-#define CACHE_MAXCOUNT		100		// Max Attempts at obtaining a database table lock
-#define CACHE_HOURSVALID	0
-#define CACHE_MAXDEADRECORDS	2
-#define CACHE_MAXRECORDS	9		// Including comment records
-#define CACHE_FIRSTRECORDLENGTH	30
-#define CACHE_MAXLOCKTIME	100		// Maximum Grace period after time expiry when a file record is locked
-#define CACHE_NORECORD		1
-#define CACHE_RECORDFOUND	2
-#define CACHE_PURGERECORD	3
-#define CACHE_NOFREERECORD	4
-#define CACHE_FREERECORD	5
-
-#define CACHE_DEADRECORD	0
-#define CACHE_LIVERECORD	1
-#define CACHE_LOCKEDRECORD	2		// Do Not purge this file - possibly in use
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <structures/genStructs.h>
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-// File Cache
-extern REQUEST_BLOCK* request_block_ptr;   // Pointer to the User REQUEST_BLOCK
-
-LIBRARY_API int idamClientLockCache(FILE** db, short type);
-LIBRARY_API int idamClientCacheTimeValid(unsigned long long timestamp);
-LIBRARY_API int idamClientCacheLockedTimeValid(unsigned long long timestamp);
-LIBRARY_API int idamClientCacheFileValid(const char* filename);
-LIBRARY_API int idamClientGetCacheStats(FILE* db, unsigned long* recordCount, unsigned long* deadCount, unsigned long* endOffset,
-                            char csvChar);
-LIBRARY_API void idamClientUpdateCacheStats(FILE* db, unsigned long recordCount, unsigned long deadCount, unsigned long endOffset,
-                                char csvChar);
-LIBRARY_API int idamClientPurgeCache(FILE* db, unsigned long recordCount, unsigned long* endOffset);
-LIBRARY_API int idamClientReadCache(DATA_BLOCK* data_block, char* filename, int protocolVersion);
-LIBRARY_API int idamClientGetCacheFilename(REQUEST_BLOCK* request_block, char** cacheFilename);
-LIBRARY_API int idamClientWriteCache(char* filename);
-LIBRARY_API unsigned int xcrc32(const unsigned char* buf, int len, unsigned int init);
+LIBRARY_API DATA_BLOCK* udaFileCacheRead(const REQUEST_BLOCK* request_block,
+                                         LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                                         int protocolVersion);
+LIBRARY_API int udaFileCacheWrite(const DATA_BLOCK* data_block, const REQUEST_BLOCK* request_block,
+                                  LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist,
+                                  int protocolVersion);
 
 #ifdef __cplusplus
 }
 #endif
 
-#endif // UDA_FILECACHE_H
+#endif // UDA_CACHE_FILECACHE_H
diff --git a/source/cache/memcache.cpp b/source/cache/memcache.cpp
new file mode 100755
index 00000000..fed6b7f1
--- /dev/null
+++ b/source/cache/memcache.cpp
@@ -0,0 +1,279 @@
+#include "memcache.h"
+#include "cache.h"
+
+#ifdef NOLIBMEMCACHED
+
+struct UdaCache {
+    int dummy_;
+};
+
+UDA_CACHE* udaOpenCache()
+{ return nullptr; }
+
+void udaFreeCache()
+{}
+
+char* udaCacheKey(const REQUEST_BLOCK* request_block, ENVIRONMENT environment)
+{ return nullptr; }
+
+int udaCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
+                   LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment,
+                   int protocolVersion)
+{ return 0; }
+
+DATA_BLOCK* udaCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
+                          USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
+{ return nullptr; }
+
+#else
+
+#include <libmemcached/memcached.h>
+#include <openssl/ssl.h>
+
+#include <logging/logging.h>
+#include <clientserver/initStructs.h>
+#include <clientserver/memstream.h>
+#include <clientserver/xdrlib.h>
+#include <tuple>
+#include <clientserver/errorLog.h>
+
+#define HASHXDR 1
+#ifdef HASHXDR
+#  define PARTBLOCKINIT        1
+#  define PARTBLOCKUPDATE      2
+#  define PARTBLOCKOUTPUT      3
+#endif // HASHXDR
+
+#define MAXELEMENTSHA1 20
+
+struct UdaCache {
+    memcached_st memcache;
+};
+
+static UDA_CACHE* global_cache = nullptr;    // scope limited to this code module
+
+UDA_CACHE* udaOpenCache()
+{
+    auto cache = (UDA_CACHE*)malloc(sizeof(UDA_CACHE));
+    memcached_return_t rc;
+    memcached_server_st* servers;
+
+    const char* host = getenv("UDA_CACHE_HOST");   // Overrule the default settings
+    const char* port = getenv("UDA_CACHE_PORT");
+
+    if (host == nullptr && port == nullptr) {
+        servers = memcached_server_list_append(nullptr, UDA_CACHE_HOST, (in_port_t)UDA_CACHE_PORT, &rc);
+    } else if (host != nullptr && port != nullptr) {
+        servers = memcached_server_list_append(nullptr, host, (in_port_t)atoi(port), &rc);
+    } else if (host != nullptr) {
+        servers = memcached_server_list_append(nullptr, host, (in_port_t)UDA_CACHE_PORT, &rc);
+    } else {
+        servers = memcached_server_list_append(nullptr, UDA_CACHE_HOST, (in_port_t)atoi(port), &rc);
+    }
+
+    //memcached_create(&cache->memcache);       // Causes a segmentation Violation!
+    cache->memcache = *memcached_create(nullptr);
+    rc = memcached_server_push(&cache->memcache, servers);
+
+    if (rc == MEMCACHED_SUCCESS) {
+        UDA_LOG(UDA_LOG_DEBUG, "%s\n", "Added server successfully");
+    } else {
+        UDA_LOG(UDA_LOG_DEBUG, "Couldn't add server: %s\n", memcached_strerror(&cache->memcache, rc));
+        free(cache);
+        return nullptr;
+    }
+
+    global_cache = cache;   // Copy the pointer
+    return cache;
+}
+
+void udaFreeCache() // Will be called by the idamFreeAll function
+{
+    memcached_free(&global_cache->memcache);
+}
+
+// Use the requested signal and source with client specified properties to create a unique key
+// All parameters that may effect the data state, e.g. flags, host, port, properties, etc. must be included in the key
+// There is a 250 character limit - use SHA1 hash if it exceeds 250
+// The local cache should only be used to record data returned from a server after a GET method - Note: Put methods may be disguised in a GET call!
+// How to validate the cached data?
+
+char* generate_cache_key(const REQUEST_BLOCK* request_block, ENVIRONMENT environment)
+{
+    // Check Client Properties for permission and requested method
+    if (!(clientFlags & CLIENTFLAG_CACHE)) {
+        return nullptr;
+    }
+
+    // **** TODO **** if(!(clientFlags & CLIENTFLAG_CACHE) || request_block->put) return nullptr;
+    const char* delimiter = "&&";
+    size_t len = strlen(request_block->source) + strlen(request_block->signal) +
+                 strlen(environment.server_host) + 128;
+    char* key = (char*)malloc(len * sizeof(char));
+    sprintf(key, "%s%s%s%s%s%s%d%s%d%s%d", request_block->signal, delimiter, request_block->source, delimiter,
+            environment.server_host, delimiter, environment.server_port, delimiter, environment.clientFlags, delimiter,
+            privateFlags);
+
+    // *** TODO: Add server properties (set by the client) to the key - planned to use clientFlags (bit settings) but not implemented yet! ***
+    // *** which server is the client connected to .... may not be the default in the ENVIRONMENT structure! - Investigate! ***
+    // *** privateFlags is a global also in the CLIENT_BLOCK structure passed to the server (with clientFlags)
+
+    if (len < 250) {
+        return key;
+    }
+
+#ifndef HASHXDR
+    free(key);
+    return nullptr;
+    // No Hash function to create the key
+#else
+    // Need a compact hash - use SHA1 as always 20 bytes (40 bytes when printable)
+    unsigned char md[MAXELEMENTSHA1 + 1];      // SHA1 Hash
+    md[MAXELEMENTSHA1] = '\0';
+    strcpy((char*)md, "                    ");
+    SHA1((unsigned char*)key, len, md);
+    // Convert to a printable string (40 characters) for the key (is this necessary?)
+    key[40] = '\0';
+
+    for (int j = 0; j < 20; j++) {
+        sprintf(&key[2 * j], "%2.2x", md[j]);
+    }
+
+    return key;
+#endif
+}
+
+// Use NON-BLOCKING IO mode for performance?
+// Write only with the server's permission - which information should be kept in the cache is the concern of the server only
+// All data services should indicate whether or not the data returned is suitable for client side caching (all server plugin get methods must decide!)
+// The server should also set a recommmended expiration time (lifetime of the stored object) - overridden by the client if necessary
+
+int memcache_put(UDA_CACHE* cache, const char* key, const char* buffer, size_t bufsize)
+{
+    // Expiration of the object
+    static unsigned int age_max = UDA_CACHE_EXPIRY;
+    static int init = 1;
+
+    if (init) {
+        char* env = getenv("UDA_CACHE_EXPIRY");
+
+        if (env != nullptr) {
+            age_max = (unsigned int)atoi(env);
+        }
+
+        init = 0;
+    }
+
+    time_t life = time(nullptr);
+
+#ifdef CACHEDEV
+    if (data_block->cacheExpiryTime > 0) {
+        // Object expiration time is set by the server
+        life += data_block->cacheExpiryTime;
+    } else {
+        // Add the default or client overridden lifetime for the object to the current time
+        life += age_max;
+    }
+#else
+    // Add the default or client overridden lifetime for the object to the current time
+    life += age_max;
+#endif
+
+    memcached_return_t rc = memcached_set(&cache->memcache, key, strlen(key), buffer, bufsize, life, (uint32_t)0);
+
+    if (rc != MEMCACHED_SUCCESS) {
+        THROW_ERROR(-1, memcached_strerror(&cache->memcache, rc));
+    }
+
+    rc = memcached_flush_buffers(&cache->memcache);
+
+    if (rc != MEMCACHED_SUCCESS) {
+        THROW_ERROR(-1, memcached_strerror(&cache->memcache, rc));
+    }
+
+    return 0;
+}
+
+int
+udaCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
+               LOGMALLOCLIST* logmalloclist,
+               USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
+{
+#ifdef CACHEDEV
+    if (!data_block->cachePermission) {
+        // Test permission for the Client to cache this structure.
+        return -1;
+    }
+#endif
+
+    char* key = generate_cache_key(request_block, environment);
+    UDA_LOG(UDA_LOG_DEBUG, "Caching value for key: %s\n", key);
+
+    if (key == nullptr) {
+        return -1;
+    }
+
+    char* buffer;
+    size_t bufsize = 0;
+
+    FILE* memfile = open_memstream(&buffer, &bufsize);
+
+    writeCacheData(memfile, logmalloclist, userdefinedtypelist, data_block, protocolVersion);
+
+    int rc = memcache_put(cache, key, buffer, bufsize);
+
+    free(key);
+    return rc;
+}
+
+FILE* create_mem_file(const char* value, size_t len)
+{
+    char* buffer;
+    size_t bufsize = 0;
+
+    FILE* memfile = open_memstream(&buffer, &bufsize);
+
+    fwrite(value, sizeof(char), len, memfile);
+    fseek(memfile, 0L, SEEK_SET);
+
+    return memfile;
+}
+
+std::pair<char*, size_t> get_cache_value(UDA_CACHE* cache, const char* key)
+{
+    UDA_LOG(UDA_LOG_DEBUG, "Retrieving value for key: %s\n", key);
+    memcached_return rc;
+    size_t len = 0;
+    u_int32_t flags = 0;
+    char* value = memcached_get(&cache->memcache, key, strlen(key), &len, &flags, &rc);
+
+    if (rc != MEMCACHED_SUCCESS) {
+        UDA_LOG(UDA_LOG_ERROR, "Couldn't retrieve key: %s\n", memcached_strerror(&cache->memcache, rc));
+        return { nullptr, 0 };
+    }
+
+    return { value, len };
+}
+
+DATA_BLOCK* udaCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
+                          USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion)
+{
+    char* key = generate_cache_key(request_block, environment);
+    if (key == nullptr) {
+        return nullptr;
+    }
+
+    char* value;
+    size_t len;
+    std::tie(value, len) = get_cache_value(cache, key);
+    free(key);
+    if (value == nullptr) {
+        return nullptr;
+    }
+
+    FILE* memfile = create_mem_file(value, len);
+
+    return readCacheData(memfile, logmalloclist, userdefinedtypelist, protocolVersion);
+}
+
+#endif // NOLIBMEMCACHED
diff --git a/source/cache/memcache.h b/source/cache/memcache.h
new file mode 100755
index 00000000..1abc0bc0
--- /dev/null
+++ b/source/cache/memcache.h
@@ -0,0 +1,48 @@
+#ifndef UDA_CACHE_MEMCACHE_H
+#define UDA_CACHE_MEMCACHE_H
+
+#include <clientserver/udaStructs.h>
+#include <structures/genStructs.h>
+#include <clientserver/export.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define UDA_CACHE_NOT_OPENED    1
+#define UDA_CACHE_NOT_AVAILABLE 2
+#define UDA_CACHE_AVAILABLE     3
+
+#define UDA_CACHE_HOST     "localhost"     // Override these with environment variables with the same name
+#define UDA_CACHE_PORT     11211
+#define UDA_CACHE_EXPIRY   86400           //24*3600       // Lifetime of the object in Secs
+
+// Cache permissions
+
+#define UDA_PLUGIN_NOT_OK_TO_CACHE  0   // Plugin state management incompatible with client side cacheing
+#define UDA_PLUGIN_OK_TO_CACHE      1   // Data are OK for the Client to Cache
+
+#define UDA_PLUGIN_CACHE_DEFAULT  UDA_PLUGIN_NOT_OK_TO_CACHE // The cache permission to use as the default
+
+#define UDA_PLUGIN_NO_CACHE_TYPE   0
+#define UDA_PLUGIN_MEM_CACHE_TYPE  1
+#define UDA_PLUGIN_FILE_CACHE_TYPE 2
+
+typedef struct UdaCache UDA_CACHE;
+
+LIBRARY_API UDA_CACHE* udaOpenCache();
+
+LIBRARY_API void udaFreeCache();
+
+LIBRARY_API int udaCacheWrite(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, DATA_BLOCK* data_block,
+        LOGMALLOCLIST* logmalloclist, USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment,
+        int protocolVersion);
+
+LIBRARY_API DATA_BLOCK* udaCacheRead(UDA_CACHE* cache, const REQUEST_BLOCK* request_block, LOGMALLOCLIST* logmalloclist,
+        USERDEFINEDTYPELIST* userdefinedtypelist, ENVIRONMENT environment, int protocolVersion);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // UDA_CACHE_MEMCACHE_H
diff --git a/source/client/CMakeLists.txt b/source/client/CMakeLists.txt
index a0abc118..976b52bc 100755
--- a/source/client/CMakeLists.txt
+++ b/source/client/CMakeLists.txt
@@ -11,6 +11,12 @@ if( WIN32 OR MINGW )
   if( NOT MINGW )
     find_package( dlfcn-win32 CONFIG REQUIRED )
   endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 add_definitions( -DNOTGENERICENABLED )
@@ -111,6 +117,9 @@ if( MINGW OR WIN32 )
   else()
     set( CLIENT_LINK_LIBS ${CLIENT_LINK_LIBS} dlfcn-win32::dl )
   endif()
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
+  set( CLIENT_LINK_LIBS ${CLIENT_LINK_LIBS} ${TIRPC_LIBRARIES})
 endif()
 
 target_link_libraries( client-static PRIVATE ${CLIENT_LINK_LIBS} )
diff --git a/source/client/accAPI.cpp b/source/client/accAPI.cpp
index f8239b3b..66959f1f 100755
--- a/source/client/accAPI.cpp
+++ b/source/client/accAPI.cpp
@@ -23,16 +23,15 @@
 
 #include <logging/logging.h>
 #include <clientserver/initStructs.h>
-#include <clientserver/errorLog.h>
 #include <clientserver/stringUtils.h>
 #include <clientserver/allocData.h>
 #include <clientserver/protocol.h>
 #include <clientserver/memstream.h>
 #include <clientserver/xdrlib.h>
-#include <clientserver/socketStructs.h>
 #include <structures/struct.h>
 #include <structures/accessors.h>
-#include <cache/cache.h>
+#include <cache/memcache.h>
+#include <version.h>
 
 #include "generateErrors.h"
 #include "getEnvironment.h"
@@ -455,8 +454,8 @@ void setIdamProperty(const char* property)
                 if (IsNumber(value)) user_timeout = atoi(value);
             }
         } else {
-            if (STR_IEQUALS(property, "verbose")) idamSetLogLevel(UDA_LOG_INFO);
-            if (STR_IEQUALS(property, "debug")) idamSetLogLevel(UDA_LOG_DEBUG);
+            if (STR_IEQUALS(property, "verbose")) udaSetLogLevel(UDA_LOG_INFO);
+            if (STR_IEQUALS(property, "debug")) udaSetLogLevel(UDA_LOG_DEBUG);
             if (STR_IEQUALS(property, "altData")) clientFlags = clientFlags | CLIENTFLAG_ALTDATA;
             if (!strncasecmp(property, "altRank", 7)) {
                 strncpy(name, property, 55);
@@ -473,6 +472,7 @@ void setIdamProperty(const char* property)
         }
         if (STR_IEQUALS(property, "reuseLastHandle")) clientFlags = clientFlags | CLIENTFLAG_REUSELASTHANDLE;
         if (STR_IEQUALS(property, "freeAndReuseLastHandle")) clientFlags = clientFlags | CLIENTFLAG_FREEREUSELASTHANDLE;
+        if (STR_IEQUALS(property, "fileCache")) clientFlags = clientFlags | CLIENTFLAG_FILECACHE;
     }
 }
 
@@ -501,12 +501,12 @@ int getIdamProperty(const char* property)
     } else {
         if (STR_IEQUALS(property, "timeout")) return user_timeout;
         if (STR_IEQUALS(property, "altRank")) return altRank;
-        if (STR_IEQUALS(property, "reuseLastHandle")) return (int)(clientFlags | CLIENTFLAG_REUSELASTHANDLE);
-        if (STR_IEQUALS(property, "freeAndReuseLastHandle")) return (int)(clientFlags | CLIENTFLAG_FREEREUSELASTHANDLE);
-        if (STR_IEQUALS(property, "verbose")) return idamGetLogLevel() == UDA_LOG_INFO;
-        if (STR_IEQUALS(property, "debug")) return idamGetLogLevel() == UDA_LOG_DEBUG;
-        if (STR_IEQUALS(property, "altData")) return (int)(clientFlags | CLIENTFLAG_ALTDATA);
-
+        if (STR_IEQUALS(property, "reuseLastHandle")) return (int)(clientFlags & CLIENTFLAG_REUSELASTHANDLE);
+        if (STR_IEQUALS(property, "freeAndReuseLastHandle")) return (int)(clientFlags & CLIENTFLAG_FREEREUSELASTHANDLE);
+        if (STR_IEQUALS(property, "verbose")) return udaGetLogLevel() == UDA_LOG_INFO;
+        if (STR_IEQUALS(property, "debug")) return udaGetLogLevel() == UDA_LOG_DEBUG;
+        if (STR_IEQUALS(property, "altData")) return (int)(clientFlags & CLIENTFLAG_ALTDATA);
+        if (STR_IEQUALS(property, "fileCache")) return (int)(clientFlags & CLIENTFLAG_FILECACHE);
     }
     return 0;
 }
@@ -535,14 +535,15 @@ void resetIdamProperty(const char* property)
         if (STR_IEQUALS(property, "get_scalar")) get_scalar = 0;
         if (STR_IEQUALS(property, "get_nodimdata")) get_nodimdata = 0;
     } else {
-        if (STR_IEQUALS(property, "verbose")) idamSetLogLevel(UDA_LOG_NONE);
-        if (STR_IEQUALS(property, "debug")) idamSetLogLevel(UDA_LOG_NONE);
+        if (STR_IEQUALS(property, "verbose")) udaSetLogLevel(UDA_LOG_NONE);
+        if (STR_IEQUALS(property, "debug")) udaSetLogLevel(UDA_LOG_NONE);
         if (STR_IEQUALS(property, "altData")) clientFlags = clientFlags & !CLIENTFLAG_ALTDATA;
         if (STR_IEQUALS(property, "altRank")) altRank = 0;
         if (STR_IEQUALS(property, "reuseLastHandle")) clientFlags = clientFlags & !CLIENTFLAG_REUSELASTHANDLE;
         if (STR_IEQUALS(property, "freeAndReuseLastHandle")) {
             clientFlags = clientFlags & !CLIENTFLAG_FREEREUSELASTHANDLE;
         }
+        if (STR_IEQUALS(property, "fileCache")) clientFlags = clientFlags & !CLIENTFLAG_FILECACHE;
     }
 }
 
@@ -566,10 +567,12 @@ void resetIdamProperties()
     get_scalar = 0;
     get_bytes = 0;
     get_nodimdata = 0;
-    idamSetLogLevel(UDA_LOG_NONE);
+    udaSetLogLevel(UDA_LOG_NONE);
     user_timeout = TIMEOUT;
-    if (getenv("UDA_TIMEOUT")) user_timeout = atoi(getenv("UDA_TIMEOUT"));
-    clientFlags = clientFlags & !CLIENTFLAG_ALTDATA;
+    if (getenv("UDA_TIMEOUT")) {
+        user_timeout = atoi(getenv("UDA_TIMEOUT"));
+    }
+    clientFlags = 0;
     altRank = 0;
 }
 
@@ -757,6 +760,16 @@ int getIdamServerPort()
     return environment->server_port;                             // Active UDA server service port number
 }
 
+const char* getUdaBuildVersion()
+{
+    return UDA_BUILD_VERSION;
+}
+
+const char* getUdaBuildDate()
+{
+    return UDA_BUILD_DATE;
+}
+
 //! the UDA server connection socket ID
 /**
 * @return the connection socket ID
diff --git a/source/client/accAPI.h b/source/client/accAPI.h
index 1c1cd3a6..84355a02 100755
--- a/source/client/accAPI.h
+++ b/source/client/accAPI.h
@@ -5,12 +5,7 @@
 
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -78,7 +73,7 @@ LIBRARY_API void putIdamServerSocket(int socket);
 
 LIBRARY_API void getIdamServer(const char** host, int* port, int* socket);
 
-LIBRARY_API IDAMERRORSTACK* getIdamServerErrorStack();
+LIBRARY_API UDA_ERROR_STACK* getIdamServerErrorStack();
 
 LIBRARY_API int getIdamErrorCode(int handle);
 
diff --git a/source/client/clientAPI.cpp b/source/client/clientAPI.cpp
index 8e61488f..4063a6fe 100755
--- a/source/client/clientAPI.cpp
+++ b/source/client/clientAPI.cpp
@@ -231,6 +231,10 @@ int idamClientFileAPI2(const char* file, const char* format, const char* owner,
             strcpy(request_block.file, file);
             strcpy(request_block.signal, signal);
             break;
+
+        default:
+            // do nothing;
+            break;
     }
 
     //-------------------------------------------------------------------------
diff --git a/source/client/clientAPI.h b/source/client/clientAPI.h
index 4bc13152..c0dd29d8 100755
--- a/source/client/clientAPI.h
+++ b/source/client/clientAPI.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENT_CLIENTAPI_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/clientMDS.h b/source/client/clientMDS.h
index ef894bfb..53e2fcc3 100755
--- a/source/client/clientMDS.h
+++ b/source/client/clientMDS.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENT_CLIENTMDS_H
 #define UDA_CLIENT_CLIENTMDS_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/clientXDRStream.cpp b/source/client/clientXDRStream.cpp
index 4915eff5..41e19c66 100755
--- a/source/client/clientXDRStream.cpp
+++ b/source/client/clientXDRStream.cpp
@@ -12,7 +12,7 @@
 #include "connection.h"
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-#  include <authentication/udaSSL.h>
+#  include <authentication/udaClientSSL.h>
 #endif
 
 static XDR clientXDRinput;
@@ -27,7 +27,7 @@ extern "C" XDR* clientOutput = &clientXDRoutput;
 #endif
 
 
-void idamCreateXDRStream()
+void createXDRStream()
 {
     clientOutput->x_ops = nullptr;
     clientInput->x_ops = nullptr;
@@ -36,62 +36,62 @@ void idamCreateXDRStream()
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
 
-    if(getUdaClientSSLDisabled()){
+    if (getUdaClientSSLDisabled()) {
     
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
        xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(void*, void*, int))clientReadin,
-                     (int (*)(void*, void*, int))clientWriteout);
+                     reinterpret_cast<int (*)(void *, void *, int)>(clientReadin),
+                     reinterpret_cast<int (*)(void *, void *, int)>(clientWriteout));
 
        xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(void*, void*, int))clientReadin,
-                     (int (*)(void*, void*, int))clientWriteout);
+                     reinterpret_cast<int (*)(void *, void *, int)>(clientReadin),
+                     reinterpret_cast<int (*)(void *, void *, int)>(clientWriteout));
 #else
        xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(char*, char*, int)) clientReadin,
-                     (int (*)(char*, char*, int)) clientWriteout);
+                     reinterpret_cast<int (*)(char *, char *, int)>(clientReadin),
+                     reinterpret_cast<int (*)(char *, char *, int)>(clientWriteout));
 
        xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(char*, char*, int)) clientReadin,
-                     (int (*)(char*, char*, int)) clientWriteout);
+                     reinterpret_cast<int (*)(char *, char *, int)>(clientReadin),
+                     reinterpret_cast<int (*)(char *, char *, int)>(clientWriteout));
 #endif    
     } else {
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
        xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(void*, void*, int))readUdaClientSSL,
-                     (int (*)(void*, void*, int))writeUdaClientSSL);
+                     reinterpret_cast<int (*)(void *, void *, int)>(readUdaClientSSL),
+                     reinterpret_cast<int (*)(void *, void *, int)>(writeUdaClientSSL));
 
        xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(void*, void*, int))readUdaClientSSL,
-                     (int (*)(void*, void*, int))writeUdaClientSSL);
+                     reinterpret_cast<int (*)(void *, void *, int)>(readUdaClientSSL),
+                     reinterpret_cast<int (*)(void *, void *, int)>(writeUdaClientSSL));
 #else
        xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(char*, char*, int)) readUdaClientSSL,
-                     (int (*)(char*, char*, int)) writeUdaClientSSL);
+                     reinterpret_cast<int (*)(char *, char *, int)>(readUdaClientSSL),
+                     reinterpret_cast<int (*)(char *, char *, int)>(writeUdaClientSSL));
 
        xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                     (int (*)(char*, char*, int)) readUdaClientSSL,
-                     (int (*)(char*, char*, int)) writeUdaClientSSL);
+                     reinterpret_cast<int (*)(char *, char *, int)>(readUdaClientSSL),
+                     reinterpret_cast<int (*)(char *, char *, int)>(writeUdaClientSSL));
 #endif
     }
 #else
 
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
     xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                  (int (*)(void*, void*, int))clientReadin,
-                  (int (*)(void*, void*, int))clientWriteout);
+                  reinterpret_cast<int (*)(void *, void *, int)>(clientReadin),
+                  reinterpret_cast<int (*)(void *, void *, int)>(clientWriteout));
 
     xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                  (int (*)(void*, void*, int))clientReadin,
-                  (int (*)(void*, void*, int))clientWriteout);
+                  reinterpret_cast<int (*)(void *, void *, int)>(clientReadin),
+                  reinterpret_cast<int (*)(void *, void *, int)>(clientWriteout));
 #else
     xdrrec_create(clientOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                  (int (*)(char*, char*, int)) clientReadin,
-                  (int (*)(char*, char*, int)) clientWriteout);
+                  reinterpret_cast<int (*)(char *, char *, int)>(clientReadin),
+                  reinterpret_cast<int (*)(char *, char *, int)>(clientWriteout));
 
     xdrrec_create(clientInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                  (int (*)(char*, char*, int)) clientReadin,
-                  (int (*)(char*, char*, int)) clientWriteout);
+                  reinterpret_cast<int (*)(char *, char *, int)>(clientReadin),
+                  reinterpret_cast<int (*)(char *, char *, int)>(clientWriteout));
 #endif
 
 #endif   // SSLAUTHENTICATION
diff --git a/source/client/clientXDRStream.h b/source/client/clientXDRStream.h
index 3daa0920..c76959c1 100755
--- a/source/client/clientXDRStream.h
+++ b/source/client/clientXDRStream.h
@@ -1,17 +1,13 @@
 #ifndef UDA_CLIENT_CLIENTXDRSTREAM_H
 #define UDA_CLIENT_CLIENTXDRSTREAM_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API void idamCreateXDRStream();
+LIBRARY_API void createXDRStream();
 
 #ifdef __cplusplus
 }
diff --git a/source/client/closedown.cpp b/source/client/closedown.cpp
index 33dd37c6..3b164df9 100755
--- a/source/client/closedown.cpp
+++ b/source/client/closedown.cpp
@@ -22,22 +22,22 @@
 #endif
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-#  include <authentication/udaSSL.h>
+#  include <authentication/udaClientSSL.h>
 #endif
 
-int idamClosedown(int type, SOCKETLIST* socket_list)
+int closedown(ClosedownType type, SOCKETLIST* socket_list)
 {
     int rc = 0;
 
     UDA_LOG(UDA_LOG_DEBUG, "idamCloseDown called (%d)\n", type);
-    if (type == CLOSE_ALL) {
+    if (type == ClosedownType::CLOSE_ALL) {
         UDA_LOG(UDA_LOG_DEBUG, "Closing Log Files, Streams and Sockets\n");
     } else {
         UDA_LOG(UDA_LOG_DEBUG, "Closing Streams and Sockets\n");
     }
 
-    if (type == CLOSE_ALL) {
-        idamCloseLogging();
+    if (type == ClosedownType::CLOSE_ALL) {
+        udaCloseLogging();
         reopen_logs = TRUE;        // In case the User calls the IDAM API again!
     }
 
@@ -53,7 +53,7 @@ int idamClosedown(int type, SOCKETLIST* socket_list)
     env_port = 1;
 
 #else			// <========================== Fat Client Code Only
-    if (type == 1) {
+    if (type == ClosedownType::CLOSE_ALL) {
         closeServerSockets(socket_list);    // Close the Socket Connections to Other Data Servers
     }
 #endif
diff --git a/source/client/closedown.h b/source/client/closedown.h
index d087f771..bb74fe9e 100755
--- a/source/client/closedown.h
+++ b/source/client/closedown.h
@@ -2,27 +2,22 @@
 #define UDA_CLIENT_CLOSEDOWN_H
 
 #include <clientserver/socketStructs.h>
+#include <clientserver/export.h>
 
 #ifdef FATCLIENT
-#  define idamClosedown idamClosedownFat
-#endif
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
+#  define closedown closedownFat
 #endif
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-enum ClosedownType {
+enum class ClosedownType {
     CLOSE_SOCKETS = 0,
     CLOSE_ALL = 1,
 };
 
-LIBRARY_API int idamClosedown(int type, SOCKETLIST* socket_list);
+LIBRARY_API int closedown(ClosedownType type, SOCKETLIST* socket_list);
 
 #ifdef __cplusplus
 }
diff --git a/source/client/connection.cpp b/source/client/connection.cpp
index 95c8b428..e0488dcf 100755
--- a/source/client/connection.cpp
+++ b/source/client/connection.cpp
@@ -50,7 +50,7 @@
 #include "getEnvironment.h"
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-#  include <authentication/udaSSL.h>
+#  include <authentication/udaClientSSL.h>
 #endif
 
 #if defined(COMPILER_GCC) || defined(__clang__)
@@ -239,12 +239,12 @@ int createConnection()
     const char* hostname = environment->server_host;
     char serviceport[PORT_STRING];
 
-    // Check if the hostname is an alias for an IP address or domain name in the client configuration - replace if found
+    // Check if the host_name is an alias for an IP address or domain name in the client configuration - replace if found
 
     int hostId = udaClientFindHostByAlias(hostname);
     if (hostId >= 0) {
         if ((hostname = udaClientGetHostName(hostId)) == nullptr) {
-            addIdamError(CODEERRORTYPE, __func__, -1, "The hostname is not recognised for the host alias provided!");
+            addIdamError(CODEERRORTYPE, __func__, -1, "The host_name is not recognised for the host alias provided!");
             return -1;
         }
         if (strcasecmp(environment->server_host, hostname) != 0) {
@@ -268,7 +268,8 @@ int createConnection()
     // Does the host name contain the SSL protocol prefix? If so strip this off
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-    if (!strncasecmp(hostname, "SSL://", 6)) {           // Should be stripped already if via the HOST client configuration file
+    if (!strncasecmp(hostname, "SSL://", 6)) {
+        // Should be stripped already if via the HOST client configuration file
         strcpy(environment->server_host, &hostname[6]);  // Replace
         putUdaClientSSLProtocol(1);
     } else {
@@ -368,7 +369,7 @@ int createConnection()
             udaClientPutHostNameId(-1);
             hostname = environment->server_host2;
 
-            // Check if the hostname is an alias for an IP address or name in the client configuration - replace if found
+            // Check if the host_name is an alias for an IP address or name in the client configuration - replace if found
 
             hostId = udaClientFindHostByAlias(hostname);
             if (hostId >= 0) {
@@ -396,7 +397,8 @@ int createConnection()
             // Does the host name contain the SSL protocol prefix? If so strip this off
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-            if (!strncasecmp(hostname, "SSL://", 6)){		// Should be stripped already if via the HOST client configuration file
+            if (!strncasecmp(hostname, "SSL://", 6)){
+                // Should be stripped already if via the HOST client configuration file
                 strcpy(environment->server_host2, &hostname[6]);    // Replace
                 putUdaClientSSLProtocol(1);
             } else {
@@ -521,9 +523,9 @@ int createConnection()
     return 0;
 }
 
-void closeConnection(int type)
+void closeConnection(ClosedownType type)
 {
-    if (clientSocket >= 0 && type != 1) {
+    if (clientSocket >= 0 && type != ClosedownType::CLOSE_ALL) {
         closeClientSocket(&client_socketlist, clientSocket);
     } else {
         closeClientSockets(&client_socketlist);
@@ -543,7 +545,7 @@ int clientWriteout(void* iohandle ALLOW_UNUSED_TYPE, char* buf, int count)
     fd_set wfds;
     struct timeval tv = {};
 
-    idamUpdateSelectParms(clientSocket, &wfds, &tv);
+    udaUpdateSelectParms(clientSocket, &wfds, &tv);
 
     errno = 0;
 
@@ -568,7 +570,7 @@ int clientWriteout(void* iohandle ALLOW_UNUSED_TYPE, char* buf, int count)
             }
         }
 
-        idamUpdateSelectParms(clientSocket, &wfds, &tv);
+        udaUpdateSelectParms(clientSocket, &wfds, &tv);
     }
 
     /* UNIX version
@@ -622,10 +624,10 @@ int clientReadin(void* iohandle ALLOW_UNUSED_TYPE, char* buf, int count)
 
     /* Wait till it is possible to read from socket */
 
-    idamUpdateSelectParms(clientSocket, &rfds, &tv);
+    udaUpdateSelectParms(clientSocket, &rfds, &tv);
 
     while ((select(clientSocket + 1, &rfds, nullptr, nullptr, &tv) <= 0) && maxloop++ < MAXLOOP) {
-        idamUpdateSelectParms(clientSocket, &rfds, &tv);        // Keep trying ...
+        udaUpdateSelectParms(clientSocket, &rfds, &tv);        // Keep trying ...
     }
 
     // Read from it, checking for EINTR, as happens if called from IDL
diff --git a/source/client/connection.h b/source/client/connection.h
index dd9df286..06149b05 100755
--- a/source/client/connection.h
+++ b/source/client/connection.h
@@ -3,12 +3,9 @@
 
 #include <clientserver/socketStructs.h>
 #include <clientserver/udaStructs.h>
+#include <clientserver/export.h>
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "closedown.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -20,7 +17,7 @@ LIBRARY_API extern char clientUsername[STRING_LENGTH];  // Only obtain userid on
 LIBRARY_API int connectionOpen();
 LIBRARY_API int reconnect(ENVIRONMENT* environment);
 LIBRARY_API int createConnection();
-LIBRARY_API void closeConnection(int type);
+LIBRARY_API void closeConnection(ClosedownType type);
 
 LIBRARY_API int clientWriteout(void* iohandle, char* buf, int count);
 LIBRARY_API int clientReadin(void* iohandle, char* buf, int count);
diff --git a/source/client/generateErrors.cpp b/source/client/generateErrors.cpp
index 33e023ac..599ae9cd 100755
--- a/source/client/generateErrors.cpp
+++ b/source/client/generateErrors.cpp
@@ -216,7 +216,7 @@ int generateIdamSyntheticData(int handle)
         }
 
         default:
-            free((void*)data);
+            free(data);
             return 0;
     }
 
@@ -228,7 +228,7 @@ int generateIdamSyntheticData(int handle)
     if (err != 0) {
         addIdamError(CODEERRORTYPE, "generateIdamSyntheticData", err,
                      "Unable to Generate Synthetic Data");
-        free((void*)data);
+        free(data);
         return err;
     }
 
@@ -311,7 +311,7 @@ int generateIdamSyntheticData(int handle)
     //--------------------------------------------------------------------------------------------------------------
     // Housekeeping
 
-    free((void*)data);
+    free(data);
 
     return 0;
 }
@@ -418,7 +418,7 @@ int generateIdamSyntheticDimData(int handle, int ndim)
             break;
         }
         default:
-            free((void*)data);
+            free(data);
             return 0;
     }
 
@@ -430,7 +430,7 @@ int generateIdamSyntheticDimData(int handle, int ndim)
     if (err != 0) {
         addIdamError(CODEERRORTYPE, "generateIdamSyntheticDimData", err,
                      "Unable to Generate Synthetic Dimensional Data");
-        free((void*)data);
+        free(data);
         return err;
     }
 
@@ -513,7 +513,7 @@ int generateIdamSyntheticDimData(int handle, int ndim)
     //--------------------------------------------------------------------------------------------------------------
     // Housekeeping
 
-    free((void*)data);
+    free(data);
 
     return 0;
 }
@@ -619,9 +619,9 @@ int generateIdamDataError(int handle)
             break;
         }
         default:
-            free((void*)data);
-            free((void*)errhi);
-            free((void*)errlo);
+            free(data);
+            free(errhi);
+            free(errlo);
             return 0;
     }
 
@@ -632,9 +632,9 @@ int generateIdamDataError(int handle)
                          (float*)errlo);
 
     if (err != 0) {
-        free((void*)data);
-        free((void*)errhi);
-        free((void*)errlo);
+        free(data);
+        free(errhi);
+        free(errlo);
         return err;
     }
 
@@ -764,9 +764,9 @@ int generateIdamDataError(int handle)
     //--------------------------------------------------------------------------------------------------------------
     // Housekeeping
 
-    free((void*)data);
-    free((void*)errhi);
-    free((void*)errlo);
+    free(data);
+    free(errhi);
+    free(errlo);
 
     return 0;
 }
@@ -875,9 +875,9 @@ int generateIdamDimDataError(int handle, int ndim)
             break;
         }
         default:
-            free((void*)data);
-            free((void*)errhi);
-            free((void*)errlo);
+            free(data);
+            free(errhi);
+            free(errlo);
             return 0;
     }
 
@@ -888,9 +888,9 @@ int generateIdamDimDataError(int handle, int ndim)
                          (float*)errlo);
 
     if (err != 0) {
-        free((void*)data);
-        free((void*)errhi);
-        free((void*)errlo);
+        free(data);
+        free(errhi);
+        free(errlo);
         return err;
     }
 
@@ -1019,9 +1019,9 @@ int generateIdamDimDataError(int handle, int ndim)
     //--------------------------------------------------------------------------------------------------------------
     // Housekeeping
 
-    free((void*)data);
-    free((void*)errhi);
-    free((void*)errlo);
+    free(data);
+    free(errhi);
+    free(errlo);
 
     return 0;
 }
diff --git a/source/client/generateErrors.h b/source/client/generateErrors.h
index fb8e104a..03fb015a 100755
--- a/source/client/generateErrors.h
+++ b/source/client/generateErrors.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENT_GENERATEERRORS_H
 #define UDA_CLIENT_GENERATEERRORS_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/getEnvironment.h b/source/client/getEnvironment.h
index be710b66..645ae1d9 100755
--- a/source/client/getEnvironment.h
+++ b/source/client/getEnvironment.h
@@ -2,6 +2,7 @@
 #define UDA_CLIENT_GETENVIRONMENT_H
 
 #include <clientserver/udaStructs.h>
+#include <clientserver/export.h>
 
 #ifdef FATCLIENT
 #  define printIdamClientEnvironment printIdamClientEnvironmentFat
@@ -9,12 +10,6 @@
 #  define putIdamClientEnvironment putIdamClientEnvironmentFat
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/client/makeClientRequestBlock.h b/source/client/makeClientRequestBlock.h
index 77a85a99..f8533ee2 100755
--- a/source/client/makeClientRequestBlock.h
+++ b/source/client/makeClientRequestBlock.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENT_MAKECLIENTREQUESTBLOCK_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/startup.cpp b/source/client/startup.cpp
index a5e6d615..69d76f7a 100755
--- a/source/client/startup.cpp
+++ b/source/client/startup.cpp
@@ -67,7 +67,7 @@ int idamStartup(int reset)
     //----------------------------------------------------------------
     // Check if Output Requested
 
-    idamSetLogLevel((LOG_LEVEL)environment->loglevel);
+    udaSetLogLevel((LOG_LEVEL)environment->loglevel);
 
     if (environment->loglevel == UDA_LOG_NONE) return 0;
 
@@ -84,26 +84,26 @@ int idamStartup(int reset)
     strcpy(idamFile, environment->logdir);
     strcat(idamFile, "Debug.dbg");
     file = fopen(idamFile, environment->logmode);
-    idamSetLogFile(UDA_LOG_WARN, file);
-    idamSetLogFile(UDA_LOG_DEBUG, file);
-    idamSetLogFile(UDA_LOG_INFO, file);
+    udaSetLogFile(UDA_LOG_WARN, file);
+    udaSetLogFile(UDA_LOG_DEBUG, file);
+    udaSetLogFile(UDA_LOG_INFO, file);
 
     if (errno != 0) {
         addIdamError(SYSTEMERRORTYPE, __func__, errno, "failed to open debug log");
-        idamCloseLogging();
+        udaCloseLogging();
         return -1;
     }
 
-    if (idamGetLogLevel() == UDA_LOG_ERROR) {
+    if (udaGetLogLevel() == UDA_LOG_ERROR) {
         strcpy(idamFile, environment->logdir);
         strcat(idamFile, "Error.err");
         file = fopen(idamFile, environment->logmode);
-        idamSetLogFile(UDA_LOG_ERROR, file);
+        udaSetLogFile(UDA_LOG_ERROR, file);
     }
 
     if (errno != 0) {
         addIdamError(SYSTEMERRORTYPE, __func__, errno, "failed to open error log");
-        idamCloseLogging();
+        udaCloseLogging();
         return -1;
     }
 
diff --git a/source/client/startup.h b/source/client/startup.h
index ad29d75c..f1db943b 100755
--- a/source/client/startup.h
+++ b/source/client/startup.h
@@ -5,11 +5,7 @@
 #  define idamStartup idamStartupFat
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/udaClient.cpp b/source/client/udaClient.cpp
index dceb4e97..bb685bc0 100755
--- a/source/client/udaClient.cpp
+++ b/source/client/udaClient.cpp
@@ -8,19 +8,12 @@
 
 #include "udaClient.h"
 
-#ifdef __GNUC__
-
-#  include <unistd.h>
-
-#endif
-
 #include <cstdlib>
 
 #include <logging/logging.h>
 #include <clientserver/udaErrors.h>
 #include <clientserver/errorLog.h>
 #include <clientserver/initStructs.h>
-#include <clientserver/manageSockets.h>
 #include <clientserver/userid.h>
 #include <clientserver/printStructs.h>
 #include <clientserver/protocol.h>
@@ -34,21 +27,18 @@
 #include "accAPI.h"
 
 #ifdef FATCLIENT
-
 #  include <clientserver/compressDim.h>
 #  include <server/udaServer.h>
-
 #else
 #  include "clientXDRStream.h"
 #  include <clientserver/xdrlib.h>
-#endif
-
-#ifdef MEMCACHE
-#  include <cache/cache.h>
-#endif
-
-#if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-#  include <authentication/udaSSL.h>
+#  ifndef NOLIBMEMCACHED
+#    include <cache/memcache.h>
+#    include <cache/fileCache.h>
+#  endif
+#  ifdef SSLAUTHENTICATION
+#    include <authentication/udaClientSSL.h>
+#  endif
 #endif
 
 //------------------------------------------------ Static Globals ------------------------------------------------------
@@ -191,14 +181,15 @@ int idamClient(REQUEST_BLOCK* request_block)
     int allocMetaHeap = 0;
     int serverside = 0;
 
-#ifdef MEMCACHE
-    static IDAM_CACHE* cache;
-    request_block_ptr = request_block;    // Passed down to middleware player via global pointer
-#endif
-
-#if !defined(FATCLIENT) && !defined(SECURITYENABLED)
+#ifndef FATCLIENT
+#  ifndef NOLIBMEMCACHED
+    static UDA_CACHE* cache;
+    static unsigned int cacheStatus = UDA_CACHE_NOT_OPENED;
+#  endif // !NOLIBMEMCACHED
+#  ifndef SECURITYENABLED
     static int startupStates;
-#endif
+#  endif // !SECURITYENABLED
+#endif // !FATCLIENT
 
     DATA_SYSTEM* data_system = nullptr;
     SYSTEM_CONFIG* system_config = nullptr;
@@ -258,65 +249,70 @@ int idamClient(REQUEST_BLOCK* request_block)
         //-------------------------------------------------------------------------
         // Check the local cache for the data (GET methods only - Note: some GET methods may disguise PUT methods!)
 
-#  ifdef MEMCACHE
+        if (clientFlags & CLIENTFLAG_FILECACHE && !request_block->put) {
+            // Query the cache for the Data
+            DATA_BLOCK* data = udaFileCacheRead(request_block, logmalloclist, userdefinedtypelist, protocolVersion);
 
-        static unsigned int cacheStatus = CACHE_NOT_OPENED;
+            if (data != nullptr) {
+                // Success
+                data_block_idx = acc_getIdamNewDataHandle();
 
-        do {
+                if (data_block_idx < 0) {            // Error
+                    err = -data_block_idx;
+                    break;
+                }
 
-            // Check Client Properties for permission to cache
+                data_block = getIdamDataBlock(data_block_idx);
+
+                memcpy(data_block, data, sizeof(DATA_BLOCK));
+                free(data);
+
+                return data_block_idx;
+            }
+        }
 
+#  ifndef NOLIBMEMCACHED
+        do {
+            // Check Client Properties for permission to cache
             if (clientFlags & CLIENTFLAG_CACHE && !request_block->put &&
-                (cacheStatus == CACHE_AVAILABLE || cacheStatus == CACHE_NOT_OPENED)) {
+                (cacheStatus == UDA_CACHE_AVAILABLE || cacheStatus == UDA_CACHE_NOT_OPENED)) {
 
                 // Open the Cache
-
-                if (cacheStatus == CACHE_NOT_OPENED) {
-                    cache = idamOpenCache();
+                if (cacheStatus == UDA_CACHE_NOT_OPENED) {
+                    cache = udaOpenCache();
 
                     if (cache == nullptr) {
-                        cacheStatus = CACHE_NOT_AVAILABLE;
+                        cacheStatus = UDA_CACHE_NOT_AVAILABLE;
                         break;
                     }
 
-                    cacheStatus = CACHE_AVAILABLE;
+                    cacheStatus = UDA_CACHE_AVAILABLE;
                 }
 
                 // Query the cache for the Data
-
-                DATA_BLOCK* data = idamCacheRead(cache, request_block, logmalloclist, userdefinedtypelist,
+                DATA_BLOCK* data = udaCacheRead(cache, request_block, logmalloclist, userdefinedtypelist,
                                                  *getIdamClientEnvironment(), protocolVersion);
 
-                if (data != nullptr) {    // Success
-
-                    int lastHandle = -1;
-                    if ((clientFlags & CLIENTFLAG_REUSELASTHANDLE || clientFlags & CLIENTFLAG_FREEREUSELASTHANDLE) &&
-                        (lastHandle = getIdamThreadLastHandle()) >= 0) {
-                        if (clientFlags & CLIENTFLAG_FREEREUSELASTHANDLE) {
-                            idamFree(lastHandle);
-                        } else {
-                            initDataBlock(&Data_Block[lastHandle]);
-                        }
-                        // Application has responsibility for freeing heap in the Data Block
-                        Data_Block[lastHandle].handle = lastHandle;
-                        memcpy(&Data_Block[lastHandle], data, sizeof(DATA_BLOCK));
-                        free(data);
-                        return lastHandle;
-
-                    } else {        // re-use or create a new Data Block
-
-                        lastHandle = acc_getIdamNewDataHandle();
-
-                        memcpy(&Data_Block[lastHandle], data, sizeof(DATA_BLOCK));
-                        free(data);
-                        return lastHandle;
+                if (data != nullptr) {
+                    // Success
+                    data_block_idx = acc_getIdamNewDataHandle();
+
+                    if (data_block_idx < 0) {            // Error
+                        err = -data_block_idx;
+                        break;
                     }
+
+                    data_block = getIdamDataBlock(data_block_idx);
+
+                    memcpy(data_block, data, sizeof(DATA_BLOCK));
+                    free(data);
+
+                    return data_block_idx;
                 }
 
             }
         } while (0);
-
-#  endif // MEMCACHE
+#  endif // !NOLIBMEMCACHED
 
         //-------------------------------------------------------------------------
         // Manage Multiple UDA Server connections ...
@@ -352,13 +348,13 @@ int idamClient(REQUEST_BLOCK* request_block)
             UDA_LOG(UDA_LOG_DEBUG, "Server Closed and New Instance Started\n");
 
             // Close the Existing Socket and XDR Stream: Reopening will Instance a New Server
-            idamClosedown(CLOSE_SOCKETS, nullptr);
+            closedown(ClosedownType::CLOSE_SOCKETS, nullptr);
         } else if (connectionOpen()) {
             // Assume the Server is Still Alive
             if (clientOutput->x_ops == nullptr || clientInput->x_ops == nullptr) {
                 addIdamError(CODEERRORTYPE, __func__, 999, "XDR Streams are Closed!");
                 UDA_LOG(UDA_LOG_DEBUG, "XDR Streams are Closed!\n");
-                idamClosedown(CLOSE_SOCKETS, nullptr);
+                closedown(ClosedownType::CLOSE_SOCKETS, nullptr);
                 initServer = true;
             } else {
                 initServer = false;
@@ -388,14 +384,16 @@ int idamClient(REQUEST_BLOCK* request_block)
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
         // Create the SSL binding and context, and verify the server certificate
-        if ((err = startUdaClientSSL()) != 0) break;
+        if ((err = startUdaClientSSL()) != 0) {
+            break;
+        }
 #endif
 
         //-------------------------------------------------------------------------
         // Create the XDR Record Streams
 
         if (initServer) {
-            idamCreateXDRStream();
+            createXDRStream();
         }
 
         //-------------------------------------------------------------------------
@@ -527,18 +525,14 @@ int idamClient(REQUEST_BLOCK* request_block)
             if ((err = protocol2(clientOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                  &client_block, protocolVersion)) != 0) {
                 addIdamError(CODEERRORTYPE, __func__, err, "Protocol 10 Error (Client Block)");
-
                 UDA_LOG(UDA_LOG_DEBUG, "Error Sending Client Block\n");
-
                 break;
             }
 
             if (!(xdrrec_endofrecord(clientOutput, 1))) { // Send data now
                 err = PROTOCOL_ERROR_7;
                 addIdamError(CODEERRORTYPE, __func__, err, "Protocol 7 Error (Client Block)");
-
                 UDA_LOG(UDA_LOG_DEBUG, "Error xdrrec_endofrecord after Client Block\n");
-
                 break;
             }
 
@@ -548,9 +542,7 @@ int idamClient(REQUEST_BLOCK* request_block)
                     clientInput))) { // Wait for data, then position buffer reader to the start of a new record
                 err = PROTOCOL_ERROR_5;
                 addIdamError(CODEERRORTYPE, __func__, err, "Protocol 5 Error (Server Block)");
-
                 UDA_LOG(UDA_LOG_DEBUG, "Error xdrrec_skiprecord prior to Server Block\n");
-
                 break;
             }
 
@@ -561,9 +553,7 @@ int idamClient(REQUEST_BLOCK* request_block)
                 addIdamError(CODEERRORTYPE, __func__, err, "Protocol 11 Error (Server Block #1)");
                 // Assuming the server_block is corrupted, replace with a clean copy to avoid concatonation problems
                 server_block.idamerrorstack.nerrors = 0;
-
                 UDA_LOG(UDA_LOG_DEBUG, "Error receiving Server Block\n");
-
                 break;
             }
 
@@ -625,9 +615,7 @@ int idamClient(REQUEST_BLOCK* request_block)
                 err = 999;
                 addIdamError(CODEERRORTYPE, __func__, err,
                              "Data waiting in the input data buffer when none expected! Please contact the system administrator.");
-
                 UDA_LOG(UDA_LOG_DEBUG, "[%d] excess data bytes waiting in input buffer!\n", count++);
-
                 break;
             }
 
@@ -643,14 +631,11 @@ int idamClient(REQUEST_BLOCK* request_block)
                 err = 999;
                 addIdamError(CODEERRORTYPE, __func__, err,
                              "Corrupted input data stream! Please contact the system administrator.");
-
                 UDA_LOG(UDA_LOG_DEBUG, "Unable to flush input buffer!!!\n");
-
                 break;
             }
 
             UDA_LOG(UDA_LOG_DEBUG, "xdrrec_eof rc = 1 => no more input, buffer flushed.\n");
-
         }
 
         //-------------------------------------------------------------------------
@@ -720,7 +705,6 @@ int idamClient(REQUEST_BLOCK* request_block)
         if ((err = protocol2(clientInput, protocol_id, XDR_RECEIVE, nullptr, logmalloclist, userdefinedtypelist,
                              &server_block, protocolVersion)) != 0) {
             UDA_LOG(UDA_LOG_DEBUG, "Protocol 11 Error (Server Block #2) = %d\n", err);
-
             addIdamError(CODEERRORTYPE, __func__, err, " Protocol 11 Error (Server Block #2)");
             // Assuming the server_block is corrupted, replace with a clean copy to avoid future concatonation problems
             server_block.idamerrorstack.nerrors = 0;
@@ -734,11 +718,8 @@ int idamClient(REQUEST_BLOCK* request_block)
 
         if (server_block.idamerrorstack.nerrors > 0) {
             UDA_LOG(UDA_LOG_DEBUG, "Server Block passed Server Error State %d\n", err);
-
             err = server_block.idamerrorstack.idamerror[0].code;      // Problem on the Server Side!
-
             UDA_LOG(UDA_LOG_DEBUG, "Server Block passed Server Error State %d\n", err);
-
             serverside = 1;        // Most Server Side errors are benign so don't close the server
             break;
         }
@@ -960,18 +941,26 @@ int idamClient(REQUEST_BLOCK* request_block)
 
 #endif      // <========================== End of FatClient Code Only
 
+#ifndef FATCLIENT
         //------------------------------------------------------------------------------
         // Cache the data if the server has passed permission and the application (client) has enabled caching
 
-#ifdef MEMCACHE
+        if (clientFlags & CLIENTFLAG_FILECACHE) {
+            udaFileCacheWrite(data_block, request_block, logmalloclist, userdefinedtypelist, protocolVersion);
+        }
+
+#ifndef NOLIBMEMCACHED
 #ifdef CACHEDEV
-        if (cacheStatus == CACHE_AVAILABLE && clientFlags & CLIENTFLAG_CACHE && Data_Block[acc_getCurrentDataBlockIndex()].cachePermission == PLUGINOKTOCACHE) {
+        if (cacheStatus == UDA_CACHE_AVAILABLE && clientFlags & CLIENTFLAG_CACHE
+            && data_block.cachePermission == UDA_PLUGIN_OK_TO_CACHE) {
 #else
-        if (cacheStatus == CACHE_AVAILABLE && clientFlags & CLIENTFLAG_CACHE) {
+        if (cacheStatus == UDA_CACHE_AVAILABLE && clientFlags & CLIENTFLAG_CACHE) {
 #endif
-            idamCacheWrite(cache, request_block, data_block, logmalloclist, userdefinedtypelist, *environment, protocolVersion);
+            udaCacheWrite(cache, request_block, data_block, logmalloclist, userdefinedtypelist, *environment,
+                          protocolVersion);
         }
-#endif
+#endif // !NOLIBMEMCACHED
+#endif // !FATCLIENT
 
         //------------------------------------------------------------------------------
         // End of Error Trap Loop
@@ -1014,7 +1003,7 @@ int idamClient(REQUEST_BLOCK* request_block)
         UDA_LOG(UDA_LOG_DEBUG, "Handle %d\n", data_block_idx);
 
         if (err != 0 && !serverside) {
-            idamClosedown(CLOSE_SOCKETS, nullptr);    // Close Socket & XDR Streams but Not Files
+            closedown(ClosedownType::CLOSE_SOCKETS, nullptr);    // Close Socket & XDR Streams but Not Files
         }
 
         if (err == 0 && (getIdamDataStatus(data_block_idx)) == MIN_STATUS && !get_bad) {
@@ -1053,17 +1042,17 @@ int idamClient(REQUEST_BLOCK* request_block)
 
     } else {
         if (allocMetaHeap) {
-            free((void*)data_system);
-            free((void*)system_config);
-            free((void*)data_source);
-            free((void*)signal_rec);
-            free((void*)signal_desc);
+            free(data_system);
+            free(system_config);
+            free(data_source);
+            free(signal_rec);
+            free(signal_desc);
         }
 
         UDA_LOG(UDA_LOG_DEBUG, "Returning Error %d\n", err);
 
         if (err != 0 && !serverside) {
-            idamClosedown(CLOSE_SOCKETS, nullptr);
+            closedown(ClosedownType::CLOSE_SOCKETS, nullptr);
         }
 
         concatIdamError(&server_block.idamerrorstack);
@@ -1089,7 +1078,7 @@ int idamClient(REQUEST_BLOCK* request_block)
         UDA_LOG(UDA_LOG_DEBUG, "Handle %d\n", data_block_idx);
 
         if (err != 0) {
-            idamClosedown(0, &socket_list);
+            closedown(ClosedownType::CLOSE_SOCKETS, &socket_list);
         }
 
         if (err == 0 && (getIdamDataStatus(data_block_idx) == MIN_STATUS) && !get_bad) {
@@ -1137,7 +1126,7 @@ int idamClient(REQUEST_BLOCK* request_block)
         UDA_LOG(UDA_LOG_DEBUG, "Returning Error %d\n", err);
 
         if (err != 0) {
-            idamClosedown(0, &socket_list);
+            closedown(ClosedownType::CLOSE_SOCKETS, &socket_list);
         }
 
         concatIdamError(&server_block.idamerrorstack);
@@ -1182,21 +1171,21 @@ void idamFree(int handle)
 
         case UDA_OPAQUE_TYPE_STRUCTURES: {
             if (data_block->opaque_block != nullptr) {
-                GENERAL_BLOCK* general_block = (GENERAL_BLOCK*)data_block->opaque_block;
+                auto general_block = (GENERAL_BLOCK*)data_block->opaque_block;
 
                 if (general_block->userdefinedtypelist != nullptr) {
 #ifndef FATCLIENT
                     if (userdefinedtypelist == general_block->userdefinedtypelist) {  // Is this the current setting?
                         freeUserDefinedTypeList(userdefinedtypelist);
-                        free((void*)userdefinedtypelist);
+                        free(userdefinedtypelist);
                         userdefinedtypelist = nullptr;
                     } else {
                         freeUserDefinedTypeList(general_block->userdefinedtypelist);
-                        free((void*)general_block->userdefinedtypelist);
+                        free(general_block->userdefinedtypelist);
                     }
 #else
                     freeUserDefinedTypeList(general_block->userdefinedtypelist);
-                    free((void*)general_block->userdefinedtypelist);
+                    free(general_block->userdefinedtypelist);
 #endif
                 }
 
@@ -1204,25 +1193,25 @@ void idamFree(int handle)
 #ifndef FATCLIENT
                     if (logmalloclist == general_block->logmalloclist) {
                         freeMallocLogList(logmalloclist);
-                        free((void*)logmalloclist);
+                        free(logmalloclist);
                         logmalloclist = nullptr;
                     } else {
                         freeMallocLogList(general_block->logmalloclist);
-                        free((void*)general_block->logmalloclist);
+                        free(general_block->logmalloclist);
                     }
 #else
                     freeMallocLogList(general_block->logmalloclist);
-                    free((void*)general_block->logmalloclist);
+                    free(general_block->logmalloclist);
 #endif
                 }
 
 #ifndef FATCLIENT
                 if (general_block->userdefinedtype != nullptr) {
                     freeUserDefinedType(general_block->userdefinedtype);
-                    free((void*)general_block->userdefinedtype);
+                    free(general_block->userdefinedtype);
                 }
 
-                free((void*)general_block);
+                free(general_block);
 #endif
             }
 
@@ -1235,20 +1224,7 @@ void idamFree(int handle)
             break;
         }
 
-        case UDA_OPAQUE_TYPE_XDRFILE: {
-            if (data_block->opaque_block != nullptr) {
-                free(data_block->opaque_block);
-            }
-
-            data_block->opaque_block = nullptr;
-            data_block->data_type = UDA_TYPE_UNKNOWN;
-            data_block->opaque_count = 0;
-            data_block->opaque_type = UDA_OPAQUE_TYPE_UNKNOWN;
-            data_block->data = nullptr;
-
-            break;
-        }
-
+        case UDA_OPAQUE_TYPE_XDRFILE:
         case UDA_OPAQUE_TYPE_XDROBJECT: {
             if (data_block->opaque_block != nullptr) {
                 free(data_block->opaque_block);
@@ -1271,66 +1247,66 @@ void idamFree(int handle)
     ddims = data_block->dims;
 
     if ((cptr = data_block->data) != nullptr) {
-        free((void*)cptr);
+        free(cptr);
         data_block->data = nullptr;    // Prevent another Free
     }
 
     if ((cptr = data_block->errhi) != nullptr) {
-        free((void*)cptr);
+        free(cptr);
         data_block->errhi = nullptr;
     }
 
     if ((cptr = data_block->errlo) != nullptr) {
-        free((void*)cptr);
+        free(cptr);
         data_block->errlo = nullptr;
     }
 
     if ((cptr = data_block->synthetic) != nullptr) {
-        free((void*)cptr);
+        free(cptr);
         data_block->synthetic = nullptr;
     }
 
     if (data_block->data_system != nullptr) {
-        free((void*)data_block->data_system);
+        free(data_block->data_system);
         data_block->data_system = nullptr;
     }
 
     if (data_block->system_config != nullptr) {
-        free((void*)data_block->system_config);
+        free(data_block->system_config);
         data_block->system_config = nullptr;
     }
 
     if (data_block->data_source != nullptr) {
-        free((void*)data_block->data_source);
+        free(data_block->data_source);
         data_block->data_source = nullptr;
     }
 
     if (data_block->signal_rec != nullptr) {
-        free((void*)data_block->signal_rec);
+        free(data_block->signal_rec);
         data_block->signal_rec = nullptr;
     }
 
     if (data_block->signal_desc != nullptr) {
-        free((void*)data_block->signal_desc);
+        free(data_block->signal_desc);
         data_block->signal_desc = nullptr;
     }
 
     if (ddims != nullptr && rank > 0) {
         for (int i = 0; i < rank; i++) {
             if ((cptr = data_block->dims[i].dim) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             if ((cptr = data_block->dims[i].synthetic) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             if ((cptr = data_block->dims[i].errhi) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             if ((cptr = data_block->dims[i].errlo) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             data_block->dims[i].dim = nullptr;    // Prevent another Free
@@ -1339,15 +1315,15 @@ void idamFree(int handle)
             data_block->dims[i].errlo = nullptr;
 
             if ((cptr = (char*)data_block->dims[i].sams) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             if ((cptr = data_block->dims[i].offs) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             if ((cptr = data_block->dims[i].ints) != nullptr) {
-                free((void*)cptr);
+                free(cptr);
             }
 
             data_block->dims[i].sams = nullptr;
@@ -1355,7 +1331,7 @@ void idamFree(int handle)
             data_block->dims[i].ints = nullptr;
         }
 
-        free((void*)ddims);
+        free(ddims);
         data_block->dims = nullptr;    // Prevent another Free
     }
 
@@ -1412,8 +1388,7 @@ void idamFreeAll()
 
 #endif // <========================== End of Client Server Code Only
 
-    idamClosedown(CLOSE_ALL, nullptr);        // Close the Socket, XDR Streams and All Files
-
+    closedown(ClosedownType::CLOSE_ALL, nullptr);        // Close the Socket, XDR Streams and All Files
 }
 
 SERVER_BLOCK getIdamThreadServerBlock()
@@ -1618,7 +1593,7 @@ int getIdamServerErrorStackRecordCode(int record)
 const char* getIdamServerErrorStackRecordLocation(int record)
 {
     if (record < 0 || (unsigned int)record >= server_block.idamerrorstack.nerrors) {
-        return 0;
+        return nullptr;
     }
     return server_block.idamerrorstack.idamerror[record].location; // Server Error Stack Record Location
 }
@@ -1633,7 +1608,7 @@ const char* getIdamServerErrorStackRecordMsg(int record)
     UDA_LOG(UDA_LOG_DEBUG, "record %d\n", record);
     UDA_LOG(UDA_LOG_DEBUG, "count  %d\n", server_block.idamerrorstack.nerrors);
     if (record < 0 || (unsigned int)record >= server_block.idamerrorstack.nerrors) {
-        return 0;
+        return nullptr;
     }
     return server_block.idamerrorstack.idamerror[record].msg;   // Server Error Stack Record Message
 }
@@ -1642,7 +1617,7 @@ const char* getIdamServerErrorStackRecordMsg(int record)
 /**
 @return  the error message stack data structure
 */
-IDAMERRORSTACK* getIdamServerErrorStack()
+UDA_ERROR_STACK* getIdamServerErrorStack()
 {
     return &server_block.idamerrorstack;         // Server Error Stack Structure
 }
diff --git a/source/client/udaClient.h b/source/client/udaClient.h
index bf1e39e1..828c4689 100755
--- a/source/client/udaClient.h
+++ b/source/client/udaClient.h
@@ -6,12 +6,7 @@
 
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -76,6 +71,16 @@ LIBRARY_API void idamFree(int handle);
 
 LIBRARY_API void idamFreeAll();
 
+/**
+ * Get the version of the client c-library.
+ */
+LIBRARY_API const char* getUdaBuildVersion();
+
+/**
+ * Get the date that the client c-library was built.
+ */
+LIBRARY_API const char* getUdaBuildDate();
+
 LIBRARY_API const char* getIdamServerHost();
 
 LIBRARY_API int getIdamServerPort();
diff --git a/source/client/udaClientHostList.cpp b/source/client/udaClientHostList.cpp
index 7fc11f51..aeed5304 100755
--- a/source/client/udaClientHostList.cpp
+++ b/source/client/udaClientHostList.cpp
@@ -3,11 +3,13 @@
 * Is user authentication over SSL?
 *---------------------------------------------------------------------------------------------------------------------*/
 
-#include <cstdio>
 #include <cstdlib>
-#include <cerrno>
 #include <vector>
 #include <string>
+#include <fstream>
+#include <boost/algorithm/string/trim.hpp>
+#include <boost/algorithm/string/split.hpp>
+#include <boost/algorithm/string/predicate.hpp>
 
 #ifndef _WIN32
 #  include <strings.h>
@@ -16,9 +18,18 @@
 #include <client/udaClientHostList.h>
 #include <clientserver/stringUtils.h>
 #include <logging/logging.h>
-#include <fstream>
 
-static std::vector<HostData> hostlist;
+struct HostData {
+    std::string host_alias;
+    std::string host_name;
+    std::string certificate;
+    std::string key;
+    std::string ca_certificate;
+    int port;
+    bool isSSL;
+};
+
+static std::vector<HostData> host_list;
 static int hostId = -1;
 
 void udaClientPutHostNameId(int id)
@@ -26,25 +37,9 @@ void udaClientPutHostNameId(int id)
     hostId = id;
 }
 
-int udaClientGetHostNameId()
-{
-    return hostId;
-}
-
 void udaClientFreeHostList()
 {
-    hostlist.clear();
-}
-
-void udaClientInitHostData(HOSTDATA* host)
-{
-    host->hostalias[0] = '\0';
-    host->hostname[0] = '\0';
-    host->port = 0;
-    host->certificate[0] = '\0';
-    host->key[0] = '\0';
-    host->ca_certificate[0] = '\0';
-    host->isSSL = 0;
+    host_list.clear();
 }
 
 int udaClientFindHostByAlias(const char* alias)
@@ -52,8 +47,8 @@ int udaClientFindHostByAlias(const char* alias)
     udaClientInitHostList();
 
     int i = 0;
-    for (const auto& data : hostlist) {
-        if (STR_IEQUALS(data.hostalias, alias)) {
+    for (const auto& data : host_list) {
+        if (boost::iequals(data.host_alias, alias)) {
             return i;
         }
         ++i;
@@ -71,8 +66,8 @@ int udaClientFindHostByName(const char* name)
     }
 
     int i = 0;
-    for (const auto& data : hostlist) {
-        if (STR_IEQUALS(data.hostname, target)) {
+    for (const auto& data : host_list) {
+        if (boost::iequals(data.host_name, target)) {
             return i;
         }
         ++i;
@@ -80,19 +75,10 @@ int udaClientFindHostByName(const char* name)
     return -1;
 }
 
-char* udaClientGetHostName(int id)
+const char* udaClientGetHostName(int id)
 {
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].hostname;
-    } else {
-        return nullptr;
-    }
-}
-
-char* udaClientGetHostAlias(int id)
-{
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].hostalias;
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].host_name.c_str();
     } else {
         return nullptr;
     }
@@ -100,49 +86,13 @@ char* udaClientGetHostAlias(int id)
 
 int udaClientGetHostPort(int id)
 {
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].port;
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].port;
     } else {
         return -1;
     }
 }
 
-char* udaClientGetHostCertificatePath(int id)
-{
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].certificate;
-    } else {
-        return nullptr;
-    }
-}
-
-char* udaClientGetHostKeyPath(int id)
-{
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].key;
-    } else {
-        return nullptr;
-    }
-}
-
-char* udaClientGetHostCAPath(int id)
-{
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].ca_certificate;
-    } else {
-        return nullptr;
-    }
-}
-
-int udaClientGetHostSSL(int id)
-{
-    if (id >= 0 && id < (int)hostlist.size()) {
-        return hostlist[id].isSSL;
-    } else {
-        return 0;
-    }
-}
-
 void udaClientInitHostList()
 {
     static bool hostListInitialised = false;
@@ -179,12 +129,8 @@ void udaClientInitHostList()
 
     // Read the hosts file
 
-    errno = 0;
-    FILE* conf = nullptr;
-    if ((conf = fopen(config_file.c_str(), "r")) == nullptr || errno != 0) {
-        if (conf != nullptr) {
-            fclose(conf);
-        }
+    std::ifstream conf(config_file);
+    if (!conf) {
         return;
     }
 
@@ -193,7 +139,7 @@ void udaClientInitHostList()
     // hostAlias and other attributes are not required
     // ordering is not important
 
-    // The hostname may be either a resolvable name or a numeric IP address. The latter may be in either IPv4 or IPv6 format.
+    // The host_name may be either a resolvable name or a numeric IP address. The latter may be in either IPv4 or IPv6 format.
 
     // The port number must be given separately from the IP address if the format is IPv6
     // The port number may be appended to the host name or IPv4 numeric address using the standard convention host:port pattern
@@ -201,110 +147,145 @@ void udaClientInitHostList()
     // if the host IP address or name is prefixed with SSL:// this is stripped off and the isSSL bool set true
     // if the certificates and private key are defined, the isSSL bool set true
 
-    std::string line;
-    char buffer[HOST_STRING];
-
     bool newHost = false;
     HostData new_data = {};
 
-    while (fgets(buffer, HOST_STRING, conf) != nullptr) {
-        convertNonPrintable2(buffer);                // convert non printable chars to spaces
-        LeftTrimString(TrimString(buffer));                // remove leading and trailing spaces
+    std::string line;
+    while (std::getline(conf, line)) {
+        boost::trim(line);
+        if (line.empty() || line[0] == '#') {
+            continue;
+        }
 
-        if (buffer[0] == '#') continue;
-        if (strlen(buffer) == 0) continue;
+        std::vector<std::string> tokens;
+        boost::split(tokens, line, boost::is_any_of(" "));
+        std::for_each(tokens.begin(), tokens.end(), [](std::string& s){ boost::trim(s); });
 
-        char* next = buffer;
-        char* split = strchr(next, ' ');            // Split the string on the first space character
-        if (split != nullptr) split[0] = '\0';          // Extract the attribute name
-        LeftTrimString(TrimString(next));
+        std::string name = tokens[0];
 
-        if (StringIEquals(next, "hostName")) {            // Trigger a new set of attributes
+        if (boost::iequals(name, "hostName")) {
+            // Trigger a new set of attributes
             if (newHost) {
-                hostlist.push_back(new_data);
+                host_list.push_back(new_data);
                 new_data = {};
             }
             newHost = false;
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                strcpy(new_data.hostname, next);
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.host_name = tokens[1];
                 newHost = true;
             }
-        } else if (newHost && StringIEquals(next, "hostAlias")) {
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                strcpy(new_data.hostalias, next);
+        } else if (newHost && boost::iequals(name, "hostAlias")) {
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.host_alias = tokens[1];
             }
-        } else if (newHost && StringIEquals(next, "port")) {
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                new_data.port = atoi(next);
+        } else if (newHost && boost::iequals(name, "port")) {
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.port = std::stoi(tokens[1]);
             }
-        } else if (newHost && StringIEquals(next, "certificate")) {
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                strcpy(new_data.certificate, next);
+        } else if (newHost && boost::iequals(name, "certificate")) {
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.certificate = tokens[1];
             }
-        } else if (newHost && StringIEquals(next, "privateKey")) {
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                strcpy(new_data.key, next);
+        } else if (newHost && boost::iequals(name, "privateKey")) {
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.key = tokens[1];
             }
-        } else if (newHost && StringIEquals(next, "CA-Certificate")) {
-            next = &split[1];
-            LeftTrimString(TrimString(next));
-            if (next[0] != '\0' && strlen(next) < HOST_STRING) {
-                strcpy(new_data.ca_certificate, next);
+        } else if (newHost && boost::iequals(name, "CA-Certificate")) {
+            if (tokens.size() > 1 && !tokens[1].empty()) {
+                new_data.ca_certificate = tokens[1];
             }
         }
     }
 
     if (newHost) {
-        hostlist.push_back(new_data);
+        host_list.push_back(new_data);
     }
 
-    fclose(conf);
-
     // Flag the connection as with SSL Authentication
-    for (auto& data : hostlist) {
-        if (data.certificate[0] != '\0' && data.key[0] != '\0' && data.ca_certificate[0] != '\0') {
-            data.isSSL = 1;
+    for (auto& data : host_list) {
+        if (!data.certificate.empty() && !data.key.empty() && !data.ca_certificate.empty()) {
+            data.isSSL = true;
         }
 
-        const char* p = strcasestr(data.hostname, "SSL://");
-        if (p && p == data.hostname && strlen(p) > 6) {
-            data.isSSL = 1;
-            strcpy(data.hostname, &data.hostname[6]); // Strip prefix
+        if (boost::starts_with(data.host_name, "SSL://")) {
+            data.isSSL = true;
+            data.host_name = data.host_name.substr(6);
         }
     }
 
     // Extract and Strip the port number from the host name (a.b.c:9999, localhost:9999)
-    for (auto& data : hostlist) {
-        char* p = nullptr;
-        if ((!strcmp(data.hostname, "localhost")
-             || (p = strchr(data.hostname, '.')) != nullptr)
-            && (p = strrchr(data.hostname, ':')) != nullptr
-            && p[1] != '\0') {
-            data.port = atoi(&p[1]);
-            p[0] = '\0';
+    for (auto& data : host_list) {
+        size_t p;
+        if ((boost::iequals(data.host_name, "localhost") || data.host_name.find('.') != std::string::npos)
+            && (p = data.host_name.find(':')) != std::string::npos
+            && data.host_name.size() + 1 < p) {
+            data.port = atoi(&data.host_name[p]);
+            data.host_name.resize(p);
         }
     }
 
-    UDA_LOG(UDA_LOG_DEBUG, "Number of named hosts %d\n", hostlist.size());
+    UDA_LOG(UDA_LOG_DEBUG, "Number of named hosts %d\n", host_list.size());
     int i = 0;
-    for (const auto& data : hostlist) {
-        UDA_LOG(UDA_LOG_DEBUG, "[%d] Host Alias     : %s\n", i, data.hostalias);
-        UDA_LOG(UDA_LOG_DEBUG, "[%d] Host Name      : %s\n", i, data.hostname);
+    for (const auto& data : host_list) {
+        UDA_LOG(UDA_LOG_DEBUG, "[%d] Host Alias     : %s\n", i, data.host_alias.c_str());
+        UDA_LOG(UDA_LOG_DEBUG, "[%d] Host Name      : %s\n", i, data.host_name.c_str());
         UDA_LOG(UDA_LOG_DEBUG, "[%d] Host Port      : %d\n", i, data.port);
-        UDA_LOG(UDA_LOG_DEBUG, "[%d] Certificate    : %s\n", i, data.certificate);
-        UDA_LOG(UDA_LOG_DEBUG, "[%d] Key            : %s\n", i, data.key);
-        UDA_LOG(UDA_LOG_DEBUG, "[%d] CA Certificate : %s\n", i, data.ca_certificate);
+        UDA_LOG(UDA_LOG_DEBUG, "[%d] Certificate    : %s\n", i, data.certificate.c_str());
+        UDA_LOG(UDA_LOG_DEBUG, "[%d] Key            : %s\n", i, data.key.c_str());
+        UDA_LOG(UDA_LOG_DEBUG, "[%d] CA Certificate : %s\n", i, data.ca_certificate.c_str());
         UDA_LOG(UDA_LOG_DEBUG, "[%d] isSSL          : %d\n", i, data.isSSL);
         ++i;
     }
 }
+
+#if defined(SSLAUTHENTICATION)
+int udaClientGetHostNameId()
+{
+    return hostId;
+}
+
+const char* udaClientGetHostAlias(int id)
+{
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].host_alias.c_str();
+    } else {
+        return nullptr;
+    }
+}
+
+const char* udaClientGetHostCertificatePath(int id)
+{
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].certificate.c_str();
+    } else {
+        return nullptr;
+    }
+}
+
+const char* udaClientGetHostKeyPath(int id)
+{
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].key.c_str();
+    } else {
+        return nullptr;
+    }
+}
+
+const char* udaClientGetHostCAPath(int id)
+{
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].ca_certificate.c_str();
+    } else {
+        return nullptr;
+    }
+}
+
+int udaClientGetHostSSL(int id)
+{
+    if (id >= 0 && id < (int)host_list.size()) {
+        return host_list[id].isSSL;
+    } else {
+        return 0;
+    }
+}
+#endif
diff --git a/source/client/udaClientHostList.h b/source/client/udaClientHostList.h
index ef4ee536..5bfac517 100755
--- a/source/client/udaClientHostList.h
+++ b/source/client/udaClientHostList.h
@@ -1,45 +1,28 @@
 #ifndef UDA_CLIENT_HOSTLIST_H
 #define UDA_CLIENT_HOSTLIST_H
 
-#define HOST_MCOUNT		100		// Maximum initial number of hosts that can be registered
-#define HOST_MSTEP		10		// Increase heap by 10 records once the maximum is exceeded
-#define HOST_STRING		256
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-typedef struct HostData {
-    char hostalias[HOST_STRING];
-    char hostname[HOST_STRING];
-    char certificate[HOST_STRING];
-    char key[HOST_STRING];
-    char ca_certificate[HOST_STRING];
-    int port;
-    int isSSL;
-} HOSTDATA;
-
-LIBRARY_API void udaClientAllocHostList(int count);
 LIBRARY_API void udaClientFreeHostList(void);
-LIBRARY_API void udaClientInitHostData(HOSTDATA* host);
 LIBRARY_API int udaClientFindHostByAlias(const char* alias);
 LIBRARY_API int udaClientFindHostByName(const char* name);
 LIBRARY_API void udaClientInitHostList(void);
-LIBRARY_API char* udaClientGetHostName(int id);
-LIBRARY_API char* udaClientGetHostAlias(int id);
+LIBRARY_API const char* udaClientGetHostName(int id);
 LIBRARY_API int udaClientGetHostPort(int id);
-LIBRARY_API char* udaClientGetHostCertificatePath(int id);
-LIBRARY_API char* udaClientGetHostKeyPath(int id);
-LIBRARY_API char* udaClientGetHostCAPath(int id);
-LIBRARY_API int udaClientGetHostSSL(int id);
 LIBRARY_API void udaClientPutHostNameId(int id);
-LIBRARY_API int udaClientGetHostNameId(void);
+
+#if defined(SSLAUTHENTICATION)
+LIBRARY_API const char* udaClientGetHostCertificatePath(int id);
+LIBRARY_API const char* udaClientGetHostAlias(int id);
+LIBRARY_API const char* udaClientGetHostKeyPath(int id);
+LIBRARY_API const char* udaClientGetHostCAPath(int id);
+LIBRARY_API int udaClientGetHostSSL(int id);
+LIBRARY_API int udaClientGetHostNameId();
+#endif
 
 #ifdef __cplusplus
 }
diff --git a/source/client/udaGetAPI.cpp b/source/client/udaGetAPI.cpp
index b58f0e3f..4a620f72 100755
--- a/source/client/udaGetAPI.cpp
+++ b/source/client/udaGetAPI.cpp
@@ -10,7 +10,6 @@
 
 #include "udaGetAPI.h"
 
-#include <stdarg.h>
 #ifndef _WIN32
 #  include <strings.h>
 #endif
diff --git a/source/client/udaGetAPI.h b/source/client/udaGetAPI.h
index 5f1f8bf4..84964191 100755
--- a/source/client/udaGetAPI.h
+++ b/source/client/udaGetAPI.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENT_UDAGETAPI_H
 #define UDA_CLIENT_UDAGETAPI_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/client/udaPutAPI.h b/source/client/udaPutAPI.h
index dade293f..e5c2c62b 100755
--- a/source/client/udaPutAPI.h
+++ b/source/client/udaPutAPI.h
@@ -2,18 +2,13 @@
 #define UDA_CLIENT_UDAPUTAPI_H
 
 #include <clientserver/udaStructs.h>
+#include <clientserver/export.h>
 
 #ifdef FATCLIENT
 #  define idamPutListAPI idamPutListAPIFat
 #  define idamPutAPI idamPutAPIFat
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/client/updateSelectParms.cpp b/source/client/updateSelectParms.cpp
index d90d7a5f..2ee1a30d 100755
--- a/source/client/updateSelectParms.cpp
+++ b/source/client/updateSelectParms.cpp
@@ -4,7 +4,7 @@
 
 #include "updateSelectParms.h"
 
-void idamUpdateSelectParms(int fd, fd_set *rfds, struct timeval *tv) {
+void udaUpdateSelectParms(int fd, fd_set *rfds, struct timeval *tv) {
     FD_ZERO(rfds);
     FD_SET(fd, rfds);
     tv->tv_sec = 0;
diff --git a/source/client/updateSelectParms.h b/source/client/updateSelectParms.h
index b8c5f504..acefb458 100755
--- a/source/client/updateSelectParms.h
+++ b/source/client/updateSelectParms.h
@@ -2,23 +2,19 @@
 #define UDA_CLIENT_UPDATESELECTPARMS_H
 
 #include <time.h>
+#include <clientserver/export.h>
+
 #ifndef _WIN32
 #  include <sys/select.h>
 #else
 #  include <winsock.h>
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API void idamUpdateSelectParms(int fd, fd_set* rfds, struct timeval* tv);
+LIBRARY_API void udaUpdateSelectParms(int fd, fd_set* rfds, struct timeval* tv);
 
 #ifdef __cplusplus
 }
diff --git a/source/clientserver/CMakeLists.txt b/source/clientserver/CMakeLists.txt
index f6aebdd7..0aaaecd6 100755
--- a/source/clientserver/CMakeLists.txt
+++ b/source/clientserver/CMakeLists.txt
@@ -8,6 +8,13 @@ endif()
 
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
+
 endif()
 
 include_directories(
@@ -24,7 +31,6 @@ set( SRC_FILES
   initStructs.cpp
   makeRequestBlock.cpp
   manageSockets.cpp
-  md5Sum.cpp
   parseOperation.cpp
   parseXML.cpp
   printStructs.cpp
@@ -62,7 +68,6 @@ set( HEADER_FILES
   initXMLStructs.h
   makeRequestBlock.h
   manageSockets.h
-  md5Sum.h
   memstream.h
   parseOperation.h
   printStructs.h
@@ -81,6 +86,8 @@ set( HEADER_FILES
   xdrHData.h
   xdrlib.h
   xmlStructs.h
+  export.h
+  nameValueSubstitution.h
 )
 
 if( APPLE )
@@ -98,14 +105,13 @@ endif()
 include_directories(
   ${SRC_DIR}
   ${OPENSSL_INCLUDE_DIR}
+  ${LIBXML2_INCLUDE_DIR}
 )
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
-endif()
-
-if( NOT CLIENT_ONLY )
-  include_directories( ${LIBXML2_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 add_library( clientserver-client-objects OBJECT ${SRC_FILES} ${HEADER_FILES} )
diff --git a/source/clientserver/allocData.h b/source/clientserver/allocData.h
index 7d206243..48dd5c29 100755
--- a/source/clientserver/allocData.h
+++ b/source/clientserver/allocData.h
@@ -2,15 +2,10 @@
 #define UDA_CLIENTSERVER_ALLOCDATA_H
 
 #include "udaStructs.h"
+#include "export.h"
 
 #include <stdlib.h>
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/clientserver/allocXMLData.h b/source/clientserver/allocXMLData.h
index d893630d..3ba7c464 100755
--- a/source/clientserver/allocXMLData.h
+++ b/source/clientserver/allocXMLData.h
@@ -5,12 +5,7 @@
 
 #include "idamclientserver.h"
 #include "idamclientserverxml.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/compressDim.cpp b/source/clientserver/compressDim.cpp
index 51101a2d..059adc63 100755
--- a/source/clientserver/compressDim.cpp
+++ b/source/clientserver/compressDim.cpp
@@ -15,9 +15,9 @@
 
 #include "compressDim.h"
 
-#include <float.h>
-#include <math.h>
-#include <stdlib.h>
+#include <cfloat>
+#include <cmath>
+#include <cstdlib>
 #include <clientserver/udaTypes.h>
 
 #include "udaErrors.h"
diff --git a/source/clientserver/compressDim.h b/source/clientserver/compressDim.h
index 3929513c..39d01781 100755
--- a/source/clientserver/compressDim.h
+++ b/source/clientserver/compressDim.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENTSERVER_COMPRESSDIM_H
 
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/copyStructs.cpp b/source/clientserver/copyStructs.cpp
index bb72d288..569ea6d4 100755
--- a/source/clientserver/copyStructs.cpp
+++ b/source/clientserver/copyStructs.cpp
@@ -1,14 +1,5 @@
-// Copy Data Structures
-//
-//----------------------------------------------------------------------------------
-
 #include "copyStructs.h"
 
-void copyServerBlock(SERVER_BLOCK *out, SERVER_BLOCK in) {
-    *out = in;
-    strcpy(out->msg, in.msg);
-}
-
 void copyRequestBlock(REQUEST_BLOCK *out, REQUEST_BLOCK in) {
     *out = in;
     strcpy(out->tpass,   in.tpass);
@@ -24,38 +15,6 @@ void copyRequestBlock(REQUEST_BLOCK *out, REQUEST_BLOCK in) {
     strcpy(out->api_delim,in.api_delim);
 }
 
-void copyDataBlock(DATA_BLOCK *out, DATA_BLOCK in) {
-    *out = in;
-    strcpy(out->data_units, in.data_units);
-    strcpy(out->data_label, in.data_label);
-    strcpy(out->data_desc,  in.data_desc);
-    strcpy(out->error_msg,  in.error_msg);
-    out->data_system    = in.data_system;
-    out->system_config  = in.system_config;
-    out->data_source    = in.data_source;
-    out->signal_rec     = in.signal_rec;
-    out->signal_desc    = in.signal_desc;
-}
-
-void copyDataSystem(DATA_SYSTEM *out, DATA_SYSTEM in) {
-    *out = in;
-    strcpy(out->device_name, in.device_name);
-    strcpy(out->system_name, in.system_name);
-    strcpy(out->system_desc, in.system_desc);
-    strcpy(out->creation,    in.creation);
-    strcpy(out->xml,         in.xml);
-    strcpy(out->xml_creation,in.xml_creation);
-}
-
-void copySystemConfig(SYSTEM_CONFIG *out, SYSTEM_CONFIG in) {
-    *out = in;
-    strcpy(out->config_name, in.config_name);
-    strcpy(out->config_desc, in.config_desc);
-    strcpy(out->creation,    in.creation);
-    strcpy(out->xml,         in.xml);
-    strcpy(out->xml_creation,in.xml_creation);
-}
-
 void copyDataSource(DATA_SOURCE *out, DATA_SOURCE in) {
     *out = in;
     strcpy(out->source_alias,in.source_alias);
@@ -76,30 +35,6 @@ void copyDataSource(DATA_SOURCE *out, DATA_SOURCE in) {
     strcpy(out->xml_creation,in.xml_creation);
 }
 
-void copySignal(SIGNAL *out, SIGNAL in) {
-    *out = in;
-    strcpy(out->status_desc, in.status_desc);
-    strcpy(out->modified,    in.modified);
-    strcpy(out->creation,    in.creation);
-    strcpy(out->xml,         in.xml);
-    strcpy(out->xml_creation,in.xml_creation);
-}
-
-void copySignalDesc(SIGNAL_DESC *out, SIGNAL_DESC in) {
-    *out = in;
-    strcpy(out->source_alias, in.source_alias);
-    strcpy(out->signal_alias, in.signal_alias);
-    strcpy(out->signal_name,  in.signal_name);
-    strcpy(out->generic_name, in.generic_name);
-    strcpy(out->description,  in.description);
-    strcpy(out->signal_class, in.signal_class);
-    strcpy(out->signal_owner, in.signal_owner);
-    strcpy(out->modified,     in.modified);
-    strcpy(out->creation,     in.creation);
-    strcpy(out->xml,          in.xml);
-    strcpy(out->xml_creation, in.xml_creation);
-}
-
 void copyPluginInterface(IDAM_PLUGIN_INTERFACE* out, IDAM_PLUGIN_INTERFACE* in)
 {
     out->interfaceVersion       = in->interfaceVersion;
diff --git a/source/clientserver/copyStructs.h b/source/clientserver/copyStructs.h
index dee23e3a..9d35675a 100755
--- a/source/clientserver/copyStructs.h
+++ b/source/clientserver/copyStructs.h
@@ -3,33 +3,14 @@
 
 #include <plugins/udaPlugin.h>
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API void copyServerBlock(SERVER_BLOCK* out, SERVER_BLOCK in);
-
 LIBRARY_API void copyRequestBlock(REQUEST_BLOCK* out, REQUEST_BLOCK in);
-
-LIBRARY_API void copyDataBlock(DATA_BLOCK* out, DATA_BLOCK in);
-
-LIBRARY_API void copyDataSystem(DATA_SYSTEM* out, DATA_SYSTEM in);
-
-LIBRARY_API void copySystemConfig(SYSTEM_CONFIG* out, SYSTEM_CONFIG in);
-
 LIBRARY_API void copyDataSource(DATA_SOURCE* out, DATA_SOURCE in);
-
-LIBRARY_API void copySignal(SIGNAL* out, SIGNAL in);
-
-LIBRARY_API void copySignalDesc(SIGNAL_DESC* out, SIGNAL_DESC in);
-
 LIBRARY_API void copyPluginInterface(IDAM_PLUGIN_INTERFACE* out, IDAM_PLUGIN_INTERFACE* in);
 
 #ifdef __cplusplus
diff --git a/source/clientserver/errorLog.cpp b/source/clientserver/errorLog.cpp
index e9edbd00..f11a24e9 100755
--- a/source/clientserver/errorLog.cpp
+++ b/source/clientserver/errorLog.cpp
@@ -12,19 +12,18 @@
 #include <vector>
 
 #include <logging/logging.h>
-#include <clientserver/udaErrors.h>
 #include <clientserver/stringUtils.h>
 
-static std::vector<IDAMERROR> udaerrorstack;
+static std::vector<UDA_ERROR> udaerrorstack;
 
 int udaNumErrors()
 {
     return udaerrorstack.size();
 }
 
-void idamErrorLog(CLIENT_BLOCK client_block, REQUEST_BLOCK request, IDAMERRORSTACK* errorstack)
+void idamErrorLog(CLIENT_BLOCK client_block, REQUEST_BLOCK request, UDA_ERROR_STACK* errorstack)
 {
-    IDAMERROR* errors = nullptr;
+    UDA_ERROR* errors = nullptr;
     unsigned int nerrors;
 
     if (errorstack == nullptr) {
@@ -55,13 +54,13 @@ void idamErrorLog(CLIENT_BLOCK client_block, REQUEST_BLOCK request, IDAMERRORSTA
     convertNonPrintable2(accessdate);
     TrimString(accessdate);
 
-    idamLog(UDA_LOG_ERROR, "0 %s [%s] [%d %s %d %d %s %s %s %s %s %s %s]\n",
+    udaLog(UDA_LOG_ERROR, "0 %s [%s] [%d %s %d %d %s %s %s %s %s %s %s]\n",
             client_block.uid, accessdate, request.request, request.signal, request.exp_number,
             request.pass, request.tpass, request.path, request.file, request.format, request.archive,
             request.device_name, request.server);
 
     for (unsigned int i = 0; i < nerrors; i++) {
-        idamLog(UDA_LOG_ERROR, "1 %s [%s] %d %d [%s] [%s]\n", client_block.uid, accessdate,
+        udaLog(UDA_LOG_ERROR, "1 %s [%s] %d %d [%s] [%s]\n", client_block.uid, accessdate,
                 errors[i].type, errors[i].code, errors[i].location, errors[i].msg);
     }
 }
@@ -73,7 +72,7 @@ void initIdamErrorStack()
     udaerrorstack.clear();
 }
 
-void initErrorRecords(const IDAMERRORSTACK* errorstack)
+void initErrorRecords(const UDA_ERROR_STACK* errorstack)
 {
     for (unsigned int i = 0; i < errorstack->nerrors; i++) {
         errorstack->idamerror[i].type = 0;
@@ -104,7 +103,7 @@ void printIdamErrorStack()
 
 void addIdamError(int type, const char* location, int code, const char* msg)
 {
-    IDAMERROR error;
+    UDA_ERROR error;
 
     error.type = type;
     error.code = code;
@@ -139,7 +138,7 @@ void addIdamError(int type, const char* location, int code, const char* msg)
 
 // Concatenate Error Stack structures
 
-void concatIdamError(IDAMERRORSTACK* errorstackout)
+void concatIdamError(UDA_ERROR_STACK* errorstackout)
 {
     if (udaerrorstack.empty()) {
         return;
@@ -148,7 +147,7 @@ void concatIdamError(IDAMERRORSTACK* errorstackout)
     unsigned int iold = errorstackout->nerrors;
     unsigned int inew = udaerrorstack.size() + errorstackout->nerrors;
 
-    errorstackout->idamerror = (IDAMERROR*)realloc((void*)errorstackout->idamerror, (inew * sizeof(IDAMERROR)));
+    errorstackout->idamerror = (UDA_ERROR*)realloc((void*)errorstackout->idamerror, (inew * sizeof(UDA_ERROR)));
 
     for (unsigned int i = iold; i < inew; i++) {
         errorstackout->idamerror[i] = udaerrorstack[i - iold];
@@ -156,7 +155,7 @@ void concatIdamError(IDAMERRORSTACK* errorstackout)
     errorstackout->nerrors = inew;
 }
 
-void freeIdamErrorStack(IDAMERRORSTACK* errorstack)
+void freeIdamErrorStack(UDA_ERROR_STACK* errorstack)
 {
     // "FIX" : this is causing segfaults when using multiple clients (eg. get and put) 
     //         apparently due to both trying to free the same memory. Needs fixing properly.
diff --git a/source/clientserver/errorLog.h b/source/clientserver/errorLog.h
index 7f35e51e..250f1d04 100755
--- a/source/clientserver/errorLog.h
+++ b/source/clientserver/errorLog.h
@@ -2,7 +2,7 @@
 #define UDA_CLIENTSERVER_ERRORLOG_H
 
 #include <clientserver/udaStructs.h>
-
+#include "export.h"
 #include <time.h>
 
 #define DATELENGTH	27
@@ -14,30 +14,26 @@
 #define CODEERRORTYPE       2
 #define PLUGINERRORTYPE     3
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 LIBRARY_API int udaNumErrors(void);
-LIBRARY_API void idamErrorLog(CLIENT_BLOCK client_block, REQUEST_BLOCK request, IDAMERRORSTACK* errorstack);
+LIBRARY_API void idamErrorLog(CLIENT_BLOCK client_block, REQUEST_BLOCK request, UDA_ERROR_STACK* errorstack);
 LIBRARY_API void initIdamErrorStack(void);
-LIBRARY_API void initErrorRecords(const IDAMERRORSTACK* errorstack);
+LIBRARY_API void initErrorRecords(const UDA_ERROR_STACK* errorstack);
 LIBRARY_API void printIdamErrorStack(void);
 LIBRARY_API void addIdamError(int type, const char* location, int code, const char* msg);
-LIBRARY_API void concatIdamError(IDAMERRORSTACK* errorstackout);
-LIBRARY_API void freeIdamErrorStack(IDAMERRORSTACK* errorstack);
+LIBRARY_API void concatIdamError(UDA_ERROR_STACK* errorstackout);
+LIBRARY_API void freeIdamErrorStack(UDA_ERROR_STACK* errorstack);
 LIBRARY_API void closeIdamError(void);
 
 #ifdef __cplusplus
 }
 #endif
 
+#define ADD_ERROR(ERR, MSG) addIdamError(CODEERRORTYPE, __func__, ERR, MSG)
+#define ADD_SYS_ERROR(MSG) addIdamError(SYSTEMERRORTYPE, __func__, errno, MSG)
 #define THROW_ERROR(ERR, MSG) addIdamError(CODEERRORTYPE, __func__, ERR, MSG); return ERR;
 
 #endif // UDA_CLIENTSERVER_ERRORLOG_H
diff --git a/source/clientserver/expand_path.cpp b/source/clientserver/expand_path.cpp
index d178dae4..7928210e 100755
--- a/source/clientserver/expand_path.cpp
+++ b/source/clientserver/expand_path.cpp
@@ -116,9 +116,9 @@ void freeTokenList(char*** tokenListArray, int* tokenCount)
     char** list = *tokenListArray;
     if (*tokenCount == 0 || *tokenListArray == nullptr) return;
     for (int i = 0; i < *tokenCount; i++) {
-        free((void*)list[i]);
+        free(list[i]);
     }
-    free((void*)list);
+    free(list);
     *tokenListArray = nullptr;        // Reset to avoid double free.
     *tokenCount = 0;
 }
@@ -159,7 +159,7 @@ int tokenList(const char* delims, char* input, char*** tokenListArray)
         strcpy(list[listCount++], item);
     }
 
-    free((void*)work);
+    free(work);
     *tokenListArray = list;
 
     return listCount;
diff --git a/source/clientserver/expand_path.h b/source/clientserver/expand_path.h
index 694d172f..96a1dbcc 100755
--- a/source/clientserver/expand_path.h
+++ b/source/clientserver/expand_path.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENTSERVER_EXPAND_PATH_H
 
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/export.h b/source/clientserver/export.h
new file mode 100644
index 00000000..7409629e
--- /dev/null
+++ b/source/clientserver/export.h
@@ -0,0 +1,14 @@
+#ifndef UDA_CLIENTSERVER_EXPORT_H
+#define UDA_CLIENTSERVER_EXPORT_H
+
+#ifdef _WIN32
+#  ifdef UDA_EXPORT
+#    define LIBRARY_API __declspec(dllexport)
+#  else
+#    define LIBRARY_API __declspec(dllimport)
+#  endif
+#else
+#  define LIBRARY_API
+#endif
+
+#endif // UDA_CLIENTSERVER_EXPORT_H
diff --git a/source/clientserver/freeDataBlock.cpp b/source/clientserver/freeDataBlock.cpp
index 99716b56..54d33b33 100755
--- a/source/clientserver/freeDataBlock.cpp
+++ b/source/clientserver/freeDataBlock.cpp
@@ -3,7 +3,7 @@
 
 #include "freeDataBlock.h"
 
-#include <stdlib.h>
+#include <cstdlib>
 
 #include <logging/logging.h>
 #include <structures/struct.h>
diff --git a/source/clientserver/freeDataBlock.h b/source/clientserver/freeDataBlock.h
index 7dd8b0a8..83001cf8 100755
--- a/source/clientserver/freeDataBlock.h
+++ b/source/clientserver/freeDataBlock.h
@@ -3,14 +3,7 @@
 
 #include <structures/genStructs.h>
 #include "udaStructs.h"
-
-// Forward declarations
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/initStructs.cpp b/source/clientserver/initStructs.cpp
index 595596fe..8f1839f4 100755
--- a/source/clientserver/initStructs.cpp
+++ b/source/clientserver/initStructs.cpp
@@ -46,7 +46,6 @@ void initRequestBlock(REQUEST_BLOCK* str)
 
     str->put = 0;
     initIdamPutDataBlockList(&str->putDataBlockList);
-
 }
 
 #ifdef _WIN32
diff --git a/source/clientserver/initStructs.h b/source/clientserver/initStructs.h
index 1a072365..5c16ed4b 100755
--- a/source/clientserver/initStructs.h
+++ b/source/clientserver/initStructs.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENTSERVER_INITSTRUCTS_H
 
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/initXMLStructs.h b/source/clientserver/initXMLStructs.h
index 8b0a79e5..1dcf6848 100755
--- a/source/clientserver/initXMLStructs.h
+++ b/source/clientserver/initXMLStructs.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENTSERVER_INITXMLSTRUCTS_H
 
 #include "xmlStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/makeRequestBlock.cpp b/source/clientserver/makeRequestBlock.cpp
index a7523195..d1046d90 100644
--- a/source/clientserver/makeRequestBlock.cpp
+++ b/source/clientserver/makeRequestBlock.cpp
@@ -1,46 +1,61 @@
 #include "makeRequestBlock.h"
 
-#include <stdbool.h>
-#include <errno.h>
+#include <cerrno>
+
 #if defined(__GNUC__)
+
 #  include <unistd.h>
+
 #endif
 
 #if defined(__GNUC__)
+
 #  include <libgen.h>
+
 #endif
 
 #include <logging/logging.h>
 #include <plugins/pluginStructs.h>
 
 #include "errorLog.h"
-#include "initStructs.h"
-#include "protocol.h"
 #include "stringUtils.h"
 #include "udaErrors.h"
 #include "udaStructs.h"
 
 #if !defined(__GNUC__) && defined(_WIN32)
 #  include <direct.h>
-
 #  define strcasecmp _stricmp
 #  define strncasecmp _strnicmp
 #  define getcwd _getcwd
 #  define chdir _chdir
 #endif
 
+#define MAXMAPDEPTH     10  // Maximum number of chained signal name mappings (Recursive depth)
+#define MAXREQDEPTH     4   // Maximum number of Device Name to Server Protocol and Host substitution
+
+static void extract_function_name(const char* str, REQUEST_BLOCK* request_block);
+
+static int source_file_format_test(const char* source, REQUEST_BLOCK* request_block, PLUGINLIST pluginList,
+                                   const ENVIRONMENT* environment);
 
-static int localFindPluginIdByFormat(const char* format, const PLUGINLIST* plugin_list)
+static int extract_archive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRONMENT* environment);
+
+static int generic_request_test(const char* source, REQUEST_BLOCK* request_block);
+
+static int extract_subset(REQUEST_BLOCK* request_block);
+
+static int find_plugin_id_by_format(const char* format, const PLUGINLIST* plugin_list)
 {
     for (int i = 0; i < plugin_list->count; i++) {
-        if (STR_IEQUALS(plugin_list->plugin[i].format, format)) return i;
+        if (STR_IEQUALS(plugin_list->plugin[i].format, format)) {
+            return i;
+        }
     }
     return -1;
 }
 
-int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const ENVIRONMENT* environment)
+int make_request_block(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const ENVIRONMENT* environment)
 {
-    int rc;
     int ldelim;
     int err = 0;
     char work[MAXMETA];
@@ -78,9 +93,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                      STR_IEQUALS(request_block->source, work2));            // default device name + delimiting string
 
     if ((request_block->signal[0] == '\0' || STR_IEQUALS(request_block->signal, work)) && noSource) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err, "Neither Data Object nor Source specified!");
-        return err;
+        THROW_ERROR(999, "Neither Data Object nor Source specified!");
     }
 
     //------------------------------------------------------------------------------
@@ -190,7 +203,8 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
             break;
         }
 
-        if (test == nullptr || STR_IEQUALS(work2, environment->api_device)) {    // No delimiter present or default device?
+        if (test == nullptr ||
+            STR_IEQUALS(work2, environment->api_device)) {    // No delimiter present or default device?
 
             UDA_LOG(UDA_LOG_DEBUG, "No device name or format or protocol or library is present\n");
 
@@ -198,7 +212,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
             // Regular request: pulse or pulse/pass ==> Generic request
 
-            if (genericRequestTest(work, request_block)) break;
+            if (generic_request_test(work, request_block)) break;
 
             // Not a Server Side Function? 		Note: /a/b/fun(aaa) is a (bad!)file path and fun(a/b/c) is a function
 
@@ -221,7 +235,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
                 UDA_LOG(UDA_LOG_DEBUG, "No File Format has been specified. Selecting ....\n");
 
-                rc = sourceFileFormatTest(request_block->source, request_block, pluginList, environment);
+                int rc = source_file_format_test(request_block->source, request_block, pluginList, environment);
 
 #ifdef JETSERVER
                 if (rc < 0) {
@@ -240,14 +254,11 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
                 if (rc <= 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "File Format NOT identified from name extension!\n");
-                    //if(rc < 0) return -rc;
-                    err = 999;
-                    addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                                 "No File Format identified: Please specify.");
-                    return err;
+                    THROW_ERROR(999, "No File Format identified: Please specify.");
                 }
 
-                expandEnvironmentVariables(request_block->path);            // Resolve any Serverside environment variables
+                // Resolve any Serverside environment variables
+                expand_environment_variables(request_block->path);
 
                 UDA_LOG(UDA_LOG_DEBUG, "File Format identified from name extension!\n");
                 break;
@@ -264,23 +275,20 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                     TrimString(work2);
 
                     request_block->request = REQUEST_READ_SERVERSIDE;
-                    extractFunctionName(work, request_block);
+                    extract_function_name(work, request_block);
 
                     UDA_LOG(UDA_LOG_DEBUG, "**** Server Side Function ??? ****\n");
 
                     // Extract Name Value pairs
 
-                    if (nameValuePairs(work2, &request_block->nameValueList, strip) == -1) {
-                        err = 999;
-                        addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                                     "Name Value pair syntax is incorrect!");
-                        return err;
+                    if (name_value_pairs(work2, &request_block->nameValueList, strip) == -1) {
+                        THROW_ERROR(999, "Name Value pair syntax is incorrect!");
                     }
 
                     // Test for external library functions using the Archive name as the library name identifier
 
                     reduceSignal = false;
-                    extractArchive(request_block, reduceSignal, environment);
+                    extract_archive(request_block, reduceSignal, environment);
 
                     for (int i = 0; i < pluginList.count; i++) {
                         if (STR_IEQUALS(request_block->archive, pluginList.plugin[i].format)) {
@@ -292,10 +300,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                     break;
 
                 } else {
-
-                    err = 999;
-                    addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err, "No Data Access Plugin Identified!");
-                    return err;
+                    THROW_ERROR(999, "No Data Access Plugin Identified!");
                 }
             }
 
@@ -319,15 +324,15 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                                    test + ldelim);            // Complete String following :: delimiter
                             strcpy(request_block->file, "");                // Clean the filename
                             if (pluginList.plugin[i].plugin_class == UDA_PLUGIN_CLASS_FUNCTION) {
-                                isFunction = 1;
-                                extractFunctionName(work, request_block);
+                                isFunction = true;
+                                extract_function_name(work, request_block);
                             }
                         } else {
 #ifndef __GNUC__
-							char base[1024] = { 0 };
-							_splitpath(test + ldelim, NULL, base, NULL, NULL);
+                            char base[1024] = { 0 };
+                            _splitpath(test + ldelim, NULL, base, NULL, NULL);
 #else
-							char* base = basename(test + ldelim);
+                            char* base = basename(test + ldelim);
 #endif
                             strcpy(request_block->file, base);    // Final token
                         }
@@ -342,7 +347,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
                         static int depth = 0;
                         //int id = findPluginRequestByFormat(pluginList.plugin[i].deviceProtocol, &pluginList);
-                        int id = localFindPluginIdByFormat(pluginList.plugin[i].deviceProtocol, &pluginList);
+                        int id = find_plugin_id_by_format(pluginList.plugin[i].deviceProtocol, &pluginList);
                         if (id >= 0 && pluginList.plugin[id].plugin_class == UDA_PLUGIN_CLASS_SERVER) {
 
                             sprintf(work, "%s%s%s", pluginList.plugin[i].deviceProtocol, request_block->api_delim,
@@ -370,11 +375,9 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
                             strcpy(request_block->source, work);
                             if (depth++ > MAXREQDEPTH) {
-                                err = 999;
-                                addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                                             "Too many chained Device Name to Server Protocol Host subtitutions!");
+                                THROW_ERROR(999, "Too many chained Device Name to Server Protocol Host subtitutions!");
                             }
-                            err = makeRequestBlock(request_block, pluginList, environment);
+                            err = make_request_block(request_block, pluginList, environment);
                             depth--;
                             return err;
                         }
@@ -388,7 +391,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
             if (request_block->request == REQUEST_READ_UNKNOWN) {
                 UDA_LOG(UDA_LOG_DEBUG, "No plugin was identified for the format: %s\n", work2);
-                isForeign = 1;
+                isForeign = true;
                 strcpy(request_block->device_name, work2);                // Copy the DEVICE prefix
                 request_block->request = REQUEST_READ_GENERIC;            // The database will identify the target
 
@@ -401,7 +404,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
             if (isFile) {                                    // Resolve any Serverside environment variables
                 UDA_LOG(UDA_LOG_DEBUG, "File Format has been specified.\n");
-                expandEnvironmentVariables(request_block->path);
+                expand_environment_variables(request_block->path);
                 break;
             }
 
@@ -420,10 +423,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
             if (p == nullptr || p2 == nullptr || (p != nullptr && p2 == nullptr) || (p == nullptr && p2 != nullptr) ||
                 (p0 != nullptr && p != nullptr && p0 < p) || (p1 != nullptr && p2 != nullptr && p1 > p2)) {
-                err = 999;
-                addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                             "Not a function when one is expected! - A Library plugin has been specified.");
-                return err;
+                THROW_ERROR(999, "Not a function when one is expected! - A Library plugin has been specified.");
             }
 
             // ToDo: Extract Data subset operations specified within the source argument
@@ -439,24 +439,17 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
                 // Extract Name Value pairs
 
-                if (nameValuePairs(work, &request_block->nameValueList, strip) == -1) {
-                    err = 999;
-                    addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                                 "Name Value pair syntax is incorrect!");
-                    return err;
+                if (name_value_pairs(work, &request_block->nameValueList, strip) == -1) {
+                    THROW_ERROR(999, "Name Value pair syntax is incorrect!");
                 }
 
                 // ToDo: Extract Data subset operations specified as a named value pair, tagged 'subset'
 
             } else {
-                err = 999;
-                addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err, "Function syntax error - please correct");
-                return err;
+                THROW_ERROR(999, "Function syntax error - please correct");
             }
         }
-
     } while (0);
-      
 
     UDA_LOG(UDA_LOG_DEBUG, "Signal Argument\n");
 
@@ -492,10 +485,9 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
     //------------------------------------------------------------------------------
     // Extract Data subset operations from the data object (signal) string
 
-    if ((rc = extractSubset(request_block)) == -1) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err, "Subset operation is incorrect!");
-        return err;
+    int rc = 0;
+    if ((rc = extract_subset(request_block)) == -1) {
+        THROW_ERROR(999, "Subset operation is incorrect!");
     }
 
     // as at 19Apr2011 no signals recorded in the IDAM database use either [ or { characters
@@ -515,11 +507,11 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
     // the Plugin Name is synonymous with the Archive Name and takes priority (The archive name is discarded as unimportant)
 
     if (request_block->request == REQUEST_READ_IDAM) {
-        reduceSignal = 0;
-        err = extractArchive(request_block, reduceSignal, environment);
+        reduceSignal = false;
+        err = extract_archive(request_block, reduceSignal, environment);
     } else {
         reduceSignal = !isForeign;                // Don't detach if a foreign device
-        err = extractArchive(request_block, reduceSignal, environment);
+        err = extract_archive(request_block, reduceSignal, environment);
     }
     if (request_block->archive[0] == '\0') {
         strcpy(request_block->archive, environment->api_archive);
@@ -532,8 +524,8 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
     // with function requests. However, for all these cases a source term would be specified. No library
     // would be part of this specification so there would be no ambiguity.
 
-    isFunction = 0;
-    
+    isFunction = false;
+
     if (!isServer && (p = strchr(request_block->signal, '(')) != nullptr && strchr(p, ')') != nullptr &&
         strcasecmp(request_block->archive, environment->api_archive) != 0) {
         strcpy(work, &p[1]);
@@ -541,13 +533,11 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
             p[0] = '\0';
             LeftTrimString(work);
             TrimString(work);
-            isFunction = 1;
-            if (nameValuePairs(work, &request_block->nameValueList, strip) == -1) {
-                err = 999;
-                addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err, "Name Value pair syntax is incorrect!");
-                return err;
+            isFunction = true;
+            if (name_value_pairs(work, &request_block->nameValueList, strip) == -1) {
+                THROW_ERROR(999, "Name Value pair syntax is incorrect!");
             }
-            extractFunctionName(request_block->signal, request_block);
+            extract_function_name(request_block->signal, request_block);
         }
     }
 
@@ -561,7 +551,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
         // If the signal could be a function call, check the archive name against the function library plugins
 
         if (isFunction && err == 0) {        // Test for known Function Libraries
-            isFunction = 0;
+            isFunction = false;
             for (int i = 0; i < pluginList.count; i++) {
                 if (STR_IEQUALS(request_block->archive, pluginList.plugin[i].format)) {
                     request_block->request = pluginList.plugin[i].request;            // Found
@@ -581,7 +571,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                         pluginList.plugin[i].library[0] == '\0') {
                         request_block->request = REQUEST_READ_SERVERSIDE;            // Found
                         strcpy(request_block->format, pluginList.plugin[i].format);
-                        isFunction = 1;
+                        isFunction = true;
                         break;
                     }
                 }
@@ -591,13 +581,9 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
             UDA_LOG(UDA_LOG_DEBUG, "B request: %d\n", request_block->request);
 
         } else {
-
             // Select the Generic plugin: No source => no format or protocol or library was specified.
-
             request_block->request = REQUEST_READ_GENERIC;
-
             UDA_LOG(UDA_LOG_DEBUG, "C request: %d\n", request_block->request);
-
         }
 
     } else {
@@ -606,7 +592,7 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
         // Exception is Serverside function
 
         if (isFunction && strcasecmp(request_block->archive, environment->api_archive) != 0) {
-            int id = localFindPluginIdByFormat(request_block->archive, &pluginList);
+            int id = find_plugin_id_by_format(request_block->archive, &pluginList);
             if (id >= 0 && pluginList.plugin[id].plugin_class == UDA_PLUGIN_CLASS_FUNCTION &&
                 strcasecmp(pluginList.plugin[id].symbol, "serverside") != 0) {
                 if (request_block->request == REQUEST_READ_GENERIC ||
@@ -614,7 +600,6 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
                     request_block->request = pluginList.plugin[id].request;    // Found
                     strcpy(request_block->format, pluginList.plugin[id].format);
                     UDA_LOG(UDA_LOG_DEBUG, "D request: %d\n", request_block->request);
-
                 } else {
                     if (request_block->request != pluginList.plugin[id].request) {    // Inconsistent
                         // Let Source have priority over the Signal?
@@ -645,15 +630,14 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
 
         char* token;
         if ((token = strtok(work, "/")) != nullptr) {        // Tokenise
-
             if (IsNumber(token)) {                // This should be the tree Number otherwise only the server is passed
                 reverseString(token, work2);            // Un-Reverse the token
                 request_block->exp_number = (int)strtol(work2, nullptr, 10);    // Extract the Data Tree Number
                 if ((token = strtok(nullptr, "/")) != nullptr) {
                     reverseString(token, request_block->file);    // This should be the Tree Name
                     work2[0] = '\0';
-                    while ((token = strtok(nullptr, "/")) !=
-                           nullptr) {    // Everything Else is the Server Host and URL Path to the Tree
+                    while ((token = strtok(nullptr, "/")) != nullptr) {
+                        // Everything Else is the Server Host and URL Path to the Tree
                         strcat(work2, token);
                         strcat(work2, "/");
                     }
@@ -676,10 +660,8 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
         }
 
         if (err != 0) {
-            err = NO_SERVER_SPECIFIED;
-            addIdamError(CODEERRORTYPE, "makeServerRequestBlock", err,
-                         "The MDSPlus Data Source does not comply with the naming models: server/tree/number or server/path/to/data/tree/number");
-            return err;
+            THROW_ERROR(NO_SERVER_SPECIFIED,
+                        "The MDSPlus Data Source does not comply with the naming models: server/tree/number or server/path/to/data/tree/number");
         }
     }
 
@@ -692,24 +674,24 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
         // Isolate the Server from the source IDAM::server:port/source or SSL://server:port/source
 
         strcpy(request_block->server, work);
-	
+
         char* s = nullptr;
         if ((s = strstr(work, "SSL://")) != nullptr) {
             char* token;
             if ((token = strstr(s + 6, "/")) != nullptr) {
-                token[0] = '\0';				// Break the String (work)
-                strcpy(request_block->server, s);		// Extract the Server Name and Port (with SSL:// prefix)
-                strcpy(request_block->file, token + 1);		// Extract the Source URL Argument
-            } 
+                token[0] = '\0';                // Break the String (work)
+                strcpy(request_block->server, s);        // Extract the Server Name and Port (with SSL:// prefix)
+                strcpy(request_block->file, token + 1);        // Extract the Source URL Argument
+            }
         } else {
             char* token;
             if ((token = strstr(work, "/")) != nullptr) {
-                token[0] = '\0';                		// Break the String (work)
-                strcpy(request_block->server, work);		// Extract the Server Name and Port
-                strcpy(request_block->file, token + 1);		// Extract the Source URL Argument
-            } 
+                token[0] = '\0';                        // Break the String (work)
+                strcpy(request_block->server, work);        // Extract the Server Name and Port
+                strcpy(request_block->file, token + 1);        // Extract the Source URL Argument
+            }
         }
-	
+
         UDA_LOG(UDA_LOG_DEBUG, "Server: %s\n", request_block->server);
         UDA_LOG(UDA_LOG_DEBUG, "Source: %s\n", request_block->file);
     }
@@ -730,14 +712,18 @@ int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const
     return 0;
 }
 
-void extractFunctionName(char* str, REQUEST_BLOCK* request_block)
+void extract_function_name(const char* str, REQUEST_BLOCK* request_block)
 {
     int lstr;
     char* p;
-    if (str[0] == '\0') return;
+    if (str[0] == '\0') {
+        return;
+    }
     char* work = (char*)malloc((strlen(str) + 1) * sizeof(char));
     strcpy(work, str);
-    if ((p = strchr(work, '(')) == nullptr) return;
+    if ((p = strchr(work, '(')) == nullptr) {
+        return;
+    }
     p[0] = '\0';
     p = strstr(work, request_block->api_delim);
     if (p != nullptr) {
@@ -751,16 +737,15 @@ void extractFunctionName(char* str, REQUEST_BLOCK* request_block)
         } while ((p = strstr(work, request_block->api_delim)) != nullptr);
     }
     strcpy(request_block->function, work);
-    free((void*)work);
+    free(work);
 }
 
-int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGINLIST pluginList,
-                         const ENVIRONMENT* environment)
+/**
+ * returns true if a format was identified, false otherwise.
+ */
+int source_file_format_test(const char* source, REQUEST_BLOCK* request_block, PLUGINLIST pluginList,
+                            const ENVIRONMENT* environment)
 {
-
-    // returns 1 (TRUE) if a format was identified, 0 (FALSE) otherwise.
-    // return negative error code if a problem occured.
-
     int rc = 0;
     const char* test;
 
@@ -784,13 +769,15 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
 
     // Does the path contain any Illegal (or problem) characters
 
-    if (!IsLegalFilePath((char*)source)) return rc;        // Not compliant with Portable Filename character set
+    if (!IsLegalFilePath((char*)source)) {
+        return rc;        // Not compliant with Portable Filename character set
+    }
 
     // Does the source have a file extension? If so choose the format using the extension, otherwise investigate the file.
 
     if ((test = strrchr(source, '.')) == nullptr) {
 
-    // No extension => test the first line of file, e.g. head -c10 <file>, but both netcdf and hdf5 use the same label HDF!
+        // No extension => test the first line of file, e.g. head -c10 <file>, but both netcdf and hdf5 use the same label HDF!
 
 #ifndef _WIN32
         const char* nc = " nc";
@@ -806,7 +793,7 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
             if (errno != 0) addIdamError(SYSTEMERRORTYPE, "sourceFileFormatTest", errno, "");
             addIdamError(CODEERRORTYPE, "sourceFileFormatTest", 999,
                          "Unable to Identify the File's Format");
-            free((void*)cmd);
+            free(cmd);
             return -999;
         }
 
@@ -833,7 +820,7 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
                         }
                         addIdamError(CODEERRORTYPE, "sourceFileFormatTest", 999,
                                      "Unable to Identify the File's Format");
-                        free((void*)cmd);
+                        free(cmd);
                         return -999;
                     }
 
@@ -857,11 +844,10 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
                     errno = 0;
                     if ((ph = popen(cmd, "r")) == nullptr) {
                         if (errno != 0) {
-                            addIdamError(SYSTEMERRORTYPE, "sourceFileFormatTest", errno, "");
+                            ADD_SYS_ERROR("");
                         }
-                        addIdamError(CODEERRORTYPE, "sourceFileFormatTest", 999,
-                                     "Unable to Identify the File's Format");
-                        free((void*)cmd);
+                        ADD_ERROR(999, "Unable to Identify the File's Format");
+                        free(cmd);
                         return -999;
                     }
 
@@ -882,7 +868,7 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
                 }
             }
         }
-        free((void*)cmd);
+        free(cmd);
 
 #else
         return rc;
@@ -942,7 +928,7 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
         }
 
         if (source[0] == '/' && source[1] != '\0' && isdigit(source[1])) {        // Default File Format?
-            if (genericRequestTest(&source[1], request_block)) {        // Matches 99999/999
+            if (generic_request_test(&source[1], request_block)) {        // Matches 99999/999
                 request_block->request = REQUEST_READ_UNKNOWN;
                 strcpy(request_block->format, environment->api_format);        // the default Server File Format
                 break;
@@ -965,10 +951,10 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
                 strcpy(request_block->file, "");                        // Clean the filename
             } else {
 #ifndef __GNUC__
-				char base[1024] = { 0 };
-				_splitpath(request_block->source, NULL, base, NULL, NULL);
+                char base[1024] = { 0 };
+                _splitpath(request_block->source, NULL, base, NULL, NULL);
 #else
-				char* base = basename(request_block->source);
+                char* base = basename(request_block->source);
 #endif
                 strcpy(request_block->file, base);    // Final token
             }
@@ -979,10 +965,11 @@ int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGI
     return rc;
 }
 
-int genericRequestTest(const char* source, REQUEST_BLOCK* request_block)
+/**
+ * Return true if the Generic plugin was selected, false otherwise
+ */
+int generic_request_test(const char* source, REQUEST_BLOCK* request_block)
 {
-    // Return 1 (TRUE) if the Generic plugin was selected, 0 (FALSE) otherwise
-
     int rc = 0;
     char* token = nullptr;
     char work[STRING_LENGTH];
@@ -1044,9 +1031,8 @@ int genericRequestTest(const char* source, REQUEST_BLOCK* request_block)
 // Input Argument: reduceSignal - If TRUE (1) then extract the archive name and return the data object name
 //                                without the prefixed archive name.
 
-int extractArchive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRONMENT* environment)
+int extract_archive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRONMENT* environment)
 {
-
     int err = 0, test1, test2;
     int ldelim = (int)strlen(request_block->api_delim);
     char* test, * token, * work;
@@ -1060,21 +1046,20 @@ int extractArchive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRON
         if ((test = strstr(request_block->signal, request_block->api_delim)) != nullptr) {
 
             if (test - request_block->signal >= STRING_LENGTH - 1 || strlen(test + ldelim) >= MAXMETA - 1) {
-                err = ARCHIVE_NAME_TOO_LONG;
-                addIdamError(CODEERRORTYPE, "extractArchive", err, "The ARCHIVE Name is too long!");
+                ADD_ERROR(ARCHIVE_NAME_TOO_LONG, "The ARCHIVE Name is too long!");
                 return err;
             }
             strncpy(request_block->archive, request_block->signal, test - request_block->signal);
             request_block->archive[test - request_block->signal] = '\0';
             TrimString(request_block->archive);
-	    
-	    // If a plugin is prefixed by the local archive name then discard the archive name
-	    if(reduceSignal && !strcasecmp(request_block->archive, environment->api_archive)){
-	       request_block->archive[0] = '\0';
-	       strcpy(request_block->signal, &test[ldelim]);
-	       return extractArchive(request_block, reduceSignal, environment);
+
+            // If a plugin is prefixed by the local archive name then discard the archive name
+            if (reduceSignal && !strcasecmp(request_block->archive, environment->api_archive)) {
+                request_block->archive[0] = '\0';
+                strcpy(request_block->signal, &test[ldelim]);
+                return extract_archive(request_block, reduceSignal, environment);
             }
-	     
+
             if (!IsLegalFilePath(request_block->archive)) {
                 request_block->archive[0] = '\0';
                 return 0;
@@ -1121,7 +1106,7 @@ int extractArchive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRON
 //------------------------------------------------------------------------------
 // Does the Path contain with an Environment variable
 
-void expandEnvironmentVariables(char* path)
+void expand_environment_variables(char* path)
 {
     size_t lcwd = STRING_LENGTH - 1;
     char work[STRING_LENGTH];
@@ -1139,7 +1124,8 @@ void expandEnvironmentVariables(char* path)
     }
 
     if (chdir(path) == 0) {            // Change to path directory
-        char* pcwd = getcwd(cwd, lcwd);                    // The Current Working Directory is now the resolved directory name
+        // The Current Working Directory is now the resolved directory name
+        char* pcwd = getcwd(cwd, lcwd);
 
         UDA_LOG(UDA_LOG_DEBUG, "Expanding embedded environment variable:\n");
         UDA_LOG(UDA_LOG_DEBUG, "from: %s\n", path);
@@ -1210,7 +1196,7 @@ void expandEnvironmentVariables(char* path)
 //
 // Signal should avoid using subset like components in their name
 
-int extractSubset(REQUEST_BLOCK* request_block)
+int extract_subset(REQUEST_BLOCK* request_block)
 {
     // Return codes:
     //
@@ -1218,7 +1204,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
     //	0 => Not a subset operation - Not compliant with syntax
     //     -1 => Error
 
-    int err, rc = 1, lwork, subsetCount = 1;        // Number of subsetting operations
+    int rc = 1, lwork, subsetCount = 1;        // Number of subsetting operations
     char* p, * work, * token = nullptr;
 
     request_block->subset[0] = '\0';
@@ -1226,11 +1212,11 @@ int extractSubset(REQUEST_BLOCK* request_block)
 
     if ((token = strchr(request_block->signal, '[')) == nullptr &&
         (token = strchr(request_block->signal, '{')) == nullptr) {
-            return 0;
+        return 0;
     }
     if ((work = strrchr(request_block->signal, ']')) == nullptr &&
         (work = strrchr(request_block->signal, '}')) == nullptr) {
-            return 0;
+        return 0;
     }
     if (work < token) return 0;
 
@@ -1264,7 +1250,8 @@ int extractSubset(REQUEST_BLOCK* request_block)
     //		[a:*:c]		all items starting at a with stride c
     //		[a:b:c]		all items starting at a, ending at b with stride c
 
-    while ((token = strstr(work, "][")) != nullptr || (token = strstr(work, "}{")) != nullptr) {    // Adopt a single syntax
+    while ((token = strstr(work, "][")) != nullptr ||
+           (token = strstr(work, "}{")) != nullptr) {    // Adopt a single syntax
         token[0] = ',';
         token[1] = ' ';
     }
@@ -1303,7 +1290,9 @@ int extractSubset(REQUEST_BLOCK* request_block)
     subsetCount = 0;
     if ((token = strtok(work, ",")) != nullptr) {    // Process each subset instruction separately (work2)
         strcpy(work2[subsetCount++], token);
-        while (subsetCount < MAXRANK2 && (token = strtok(nullptr, ",")) != nullptr) strcpy(work2[subsetCount++], token);
+        while (subsetCount < MAXRANK2 && (token = strtok(nullptr, ",")) != nullptr) {
+            strcpy(work2[subsetCount++], token);
+        }
 
         do {
             for (int i = 0; i < subsetCount; i++) {
@@ -1359,9 +1348,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
                             break;
                         }
                         if (request_block->datasubset.start[i] < 0) {
-                            err = 999;
-                            addIdamError(CODEERRORTYPE, "extractSubset", err,
-                                         "Invalid Start Index in subset operation");
+                            ADD_ERROR(999, "Invalid Start Index in subset operation");
                             rc = -1;
                             break;
                         }
@@ -1384,9 +1371,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
                             break;
                         }
                         if (request_block->datasubset.stop[i] < 0) {
-                            err = 999;
-                            addIdamError(CODEERRORTYPE, "extractSubset", err,
-                                         "Invalid sample End Index in subset operation");
+                            ADD_ERROR(999, "Invalid sample End Index in subset operation");
                             rc = -1;
                             break;
                         }
@@ -1395,9 +1380,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
                         request_block->datasubset.subset[i] = 1;
 
                         if (request_block->datasubset.stop[i] < request_block->datasubset.start[i]) {
-                            err = 999;
-                            addIdamError(CODEERRORTYPE, "extractSubset", err,
-                                         "Invalid Stop Index in subset operation");
+                            ADD_ERROR(999, "Invalid Stop Index in subset operation");
                             rc = -1;
                             break;
                         }
@@ -1421,9 +1404,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
                                 break;
                             }
                             if (request_block->datasubset.stride[i] <= 0) {
-                                err = 999;
-                                addIdamError(CODEERRORTYPE, "extractSubset", err,
-                                             "Invalid sample stride length in subset operation");
+                                ADD_ERROR(999, "Invalid sample stride length in subset operation");
                                 rc = -1;
                                 break;
                             }
@@ -1460,9 +1441,7 @@ int extractSubset(REQUEST_BLOCK* request_block)
                                 break;
                             }
                             if (request_block->datasubset.start[i] < 0) {
-                                err = 999;
-                                addIdamError(CODEERRORTYPE, "extractSubset", err,
-                                             "Invalid start index in subset operation");
+                                ADD_ERROR(999, "Invalid start index in subset operation");
                                 rc = -1;
                                 break;
                             }
@@ -1503,22 +1482,22 @@ int extractSubset(REQUEST_BLOCK* request_block)
 //
 // The returned value is the count of the name value pairs. If an error occurs, the returned value of the
 // pair count is -1.
-void freeNameValueList(NAMEVALUELIST* nameValueList)
+void free_name_value_list(NAMEVALUELIST* nameValueList)
 {
     if (nameValueList->nameValue != nullptr) {
         for (int i = 0; i < nameValueList->pairCount; i++) {
-            if (nameValueList->nameValue[i].pair != nullptr) free((void*)nameValueList->nameValue[i].pair);
-            if (nameValueList->nameValue[i].name != nullptr) free((void*)nameValueList->nameValue[i].name);
-            if (nameValueList->nameValue[i].value != nullptr) free((void*)nameValueList->nameValue[i].value);
+            if (nameValueList->nameValue[i].pair != nullptr) free(nameValueList->nameValue[i].pair);
+            if (nameValueList->nameValue[i].name != nullptr) free(nameValueList->nameValue[i].name);
+            if (nameValueList->nameValue[i].value != nullptr) free(nameValueList->nameValue[i].value);
         }
     }
-    free((void*)nameValueList->nameValue);
+    free(nameValueList->nameValue);
     nameValueList->pairCount = 0;
     nameValueList->listSize = 0;
     nameValueList->nameValue = nullptr;
 }
 
-void parseNameValue(char* pair, NAMEVALUE* nameValue, unsigned short strip)
+void parse_name_value(const char* pair, NAMEVALUE* nameValue, unsigned short strip)
 {
     int lstr;
     char* p, * copy;
@@ -1561,13 +1540,13 @@ void parseNameValue(char* pair, NAMEVALUE* nameValue, unsigned short strip)
     TrimString(nameValue->name);
     TrimString(nameValue->value);
     UDA_LOG(UDA_LOG_DEBUG, "Name: %s     Value: %s\n", nameValue->name, nameValue->value);
-    
+
     // Regardless of whether or not the Value is not enclosed in quotes, strip out a possible closing parenthesis character (seen in placeholder value substitution)
     // This would not be a valid value unless at the end of a string enclosed in quotes!
     lstr = (int)strlen(nameValue->value);
-    if (nameValue->value[lstr - 1] == ')') nameValue->value[lstr - 1] = '\0'; 
+    if (nameValue->value[lstr - 1] == ')') nameValue->value[lstr - 1] = '\0';
     UDA_LOG(UDA_LOG_DEBUG, "Name: %s     Value: %s\n", nameValue->name, nameValue->value);
-    
+
     if (strip) {            // remove enclosing single or double quotes
         lstr = (int)strlen(nameValue->name);
         if ((nameValue->name[0] == '\'' && nameValue->name[lstr - 1] == '\'') ||
@@ -1578,21 +1557,20 @@ void parseNameValue(char* pair, NAMEVALUE* nameValue, unsigned short strip)
             TrimString(nameValue->name);
         }
         lstr = (int)strlen(nameValue->value);
-	if ((nameValue->value[0] == '\'' && nameValue->value[lstr - 1] == '\'') ||
+        if ((nameValue->value[0] == '\'' && nameValue->value[lstr - 1] == '\'') ||
             (nameValue->value[0] == '"' && nameValue->value[lstr - 1] == '"')) {
             nameValue->value[0] = ' ';
             nameValue->value[lstr - 1] = ' ';
             LeftTrimString(nameValue->value);
             TrimString(nameValue->value);
         }
-	UDA_LOG(UDA_LOG_DEBUG, "Name: %s     Value: %s\n", nameValue->name, nameValue->value);
-
+        UDA_LOG(UDA_LOG_DEBUG, "Name: %s     Value: %s\n", nameValue->name, nameValue->value);
     }
 
-    free((void*)copy);
+    free(copy);
 }
 
-int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short strip)
+int name_value_pairs(const char* pairList, NAMEVALUELIST* nameValueList, unsigned short strip)
 {
     // Ignore delimiter in anything enclosed in single or double quotes
     // Recognise /name as name=TRUE
@@ -1621,7 +1599,7 @@ int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short
 
     UDA_LOG(UDA_LOG_DEBUG, "Parsing name values from argument: %s\n", pairList);
 
-// Locate the delimiter name value pair if present - use default character ',' if not
+    // Locate the delimiter name value pair if present - use default character ',' if not
 
     if ((p = strcasestr(copy, "delimiter")) != nullptr) {
         strcpy(buffer, &p[9]);
@@ -1650,8 +1628,8 @@ int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short
                         TrimString(buffer);            // Check for non alpha-numeric character
                         lstr = (int)strlen(buffer);
                         if (!isalpha(buffer[lstr - 1]) && !isdigit(buffer[lstr - 1])) {    // Probable syntax error!
-                            free((void*)buffer);
-                            free((void*)copy);
+                            free(buffer);
+                            free(copy);
                             return -1;                // Flag an Error
                         }
                     }
@@ -1694,11 +1672,12 @@ int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short
         }
 
         UDA_LOG(UDA_LOG_DEBUG, "Parsing name value: %s\n", buffer);
-        parseNameValue(buffer, &nameValue, strip);
+        parse_name_value(buffer, &nameValue, strip);
         UDA_LOG(UDA_LOG_DEBUG, "Name %s, Value: %s\n", nameValue.name, nameValue.value);
 
         //if (nameValue.name != nullptr && nameValue.value != nullptr) {
-        if (nameValue.name != nullptr) {        // Values may be nullptr for use case where placeholder substitution is used
+        if (nameValue.name !=
+            nullptr) {        // Values may be nullptr for use case where placeholder substitution is used
             pairCount++;
             if (pairCount > nameValueList->listSize) {
                 nameValueList->nameValue = (NAMEVALUE*)realloc((void*)nameValueList->nameValue,
@@ -1712,8 +1691,8 @@ int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short
 
     // housekeeping
 
-    free((void*)buffer);
-    free((void*)copy);
+    free(buffer);
+    free(copy);
 
     for (int i = 0; i < nameValueList->pairCount; i++) {
         if (STR_IEQUALS(nameValueList->nameValue[i].name, "delimiter")) {        // replace with correct delimiter value
@@ -1741,6 +1720,6 @@ int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short
             }
         }
     }
-    
+
     return pairCount;
 }
diff --git a/source/clientserver/makeRequestBlock.h b/source/clientserver/makeRequestBlock.h
index 7bd2988b..03020ea4 100644
--- a/source/clientserver/makeRequestBlock.h
+++ b/source/clientserver/makeRequestBlock.h
@@ -4,33 +4,16 @@
 #include <plugins/pluginStructs.h>
 
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#define MAXMAPDEPTH     10  // Maximum number of chained signal name mappings (Recursive depth)
-#define MAXREQDEPTH     4   // Maximum number of Device Name to Server Protocol and Host substitution
-
-LIBRARY_API int makeRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const ENVIRONMENT* environment);
-LIBRARY_API void extractFunctionName(char* str, REQUEST_BLOCK* request_block);
-LIBRARY_API int sourceFileFormatTest(const char* source, REQUEST_BLOCK* request_block, PLUGINLIST pluginList,
-                         const ENVIRONMENT* environment);
-LIBRARY_API int genericRequestTest(const char* source, REQUEST_BLOCK* request_block);
-LIBRARY_API int extractArchive(REQUEST_BLOCK* request_block, int reduceSignal, const ENVIRONMENT* environment);
-LIBRARY_API void expandEnvironmentVariables(char* path);
-LIBRARY_API int extractSubset(REQUEST_BLOCK* request_block);
-LIBRARY_API void freeNameValueList(NAMEVALUELIST* nameValueList);
-LIBRARY_API void parseNameValue(char* pair, NAMEVALUE* nameValue, unsigned short strip);
-LIBRARY_API int nameValuePairs(char* pairList, NAMEVALUELIST* nameValueList, unsigned short strip);
-LIBRARY_API int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass);
-LIBRARY_API void embeddedValueSubstitution(NAMEVALUELIST* nameValueList);
+LIBRARY_API int make_request_block(REQUEST_BLOCK* request_block, PLUGINLIST pluginList, const ENVIRONMENT* environment);
+LIBRARY_API int name_value_pairs(const char* pairList, NAMEVALUELIST* nameValueList, unsigned short strip);
+LIBRARY_API void free_name_value_list(NAMEVALUELIST* nameValueList);
+LIBRARY_API void expand_environment_variables(char* path);
 
 #ifdef __cplusplus
 }
diff --git a/source/clientserver/manageSockets.cpp b/source/clientserver/manageSockets.cpp
index eb4308f5..dba12aad 100755
--- a/source/clientserver/manageSockets.cpp
+++ b/source/clientserver/manageSockets.cpp
@@ -4,11 +4,11 @@
 //
 //----------------------------------------------------------------------------------
 
-#ifndef _WIN32
+#include <cstdlib>
 
+#ifndef _WIN32
 #  include <unistd.h>
 #  include <strings.h>
-
 #else
 #  include <Windows.h>
 #  define strcasecmp _stricmp
@@ -16,11 +16,6 @@
 #endif
 
 #include "manageSockets.h"
-
-#include <stdlib.h>
-#include <memory.h>
-#include <stdio.h>
-
 #include "stringUtils.h"
 
 // Initialise
@@ -107,6 +102,6 @@ void closeClientSockets(SOCKETLIST* socks)
     for (int i = 0; i < socks->nsocks; i++) {
         closeClientSocket(socks, socks->sockets[i].fh);
     }
-    free((void*)socks->sockets);
+    free(socks->sockets);
     initSocketList(socks);
 }
diff --git a/source/clientserver/manageSockets.h b/source/clientserver/manageSockets.h
index 465892aa..541e39de 100755
--- a/source/clientserver/manageSockets.h
+++ b/source/clientserver/manageSockets.h
@@ -1,13 +1,8 @@
 #ifndef UDA_CLIENTSERVER_MANAGESOCKETS_H
 #define UDA_CLIENTSERVER_MANAGESOCKETS_H
 
-#include <clientserver/socketStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "socketStructs.h"
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/memstream.h b/source/clientserver/memstream.h
index ad3bcf94..48be0c46 100755
--- a/source/clientserver/memstream.h
+++ b/source/clientserver/memstream.h
@@ -2,12 +2,7 @@
 #define UDA_CLIENTSERVER_MAC_MEMSTREAM_H
 
 #include <stdio.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C"
diff --git a/source/clientserver/mkstemp.h b/source/clientserver/mkstemp.h
index 6eb5e6e4..b8930f21 100644
--- a/source/clientserver/mkstemp.h
+++ b/source/clientserver/mkstemp.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENTSERVER_MKSTEMP_H
 #define UDA_CLIENTSERVER_MKSTEMP_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/nameValueSubstitution.cpp b/source/clientserver/nameValueSubstitution.cpp
index 8abe48bd..52fdafd8 100644
--- a/source/clientserver/nameValueSubstitution.cpp
+++ b/source/clientserver/nameValueSubstitution.cpp
@@ -1,13 +1,11 @@
-#include "makeRequestBlock.h"
+#include "nameValueSubstitution.h"
 
-#include <stdlib.h>
-#include <errno.h>
+#include <cstdlib>
+#include <cerrno>
 
 #if defined(__GNUC__)
-
 #  include <unistd.h>
 #  include <strings.h>
-
 #endif
 
 #include <clientserver/udaErrors.h>
@@ -17,6 +15,8 @@
 #include <clientserver/errorLog.h>
 #include <logging/logging.h>
 
+static void embedded_value_substitution(NAMEVALUELIST* nameValueList);
+
 // Deconstruct the text pass parameter (tpass) for name value placeholder substitution values
 // Identify name value placeholders in the signal argument and replace with substitution values
 // Add additional name-value pairs and keywords to the plugin input 
@@ -24,7 +24,7 @@
 // shot/tpass data source pattern: "12345/a,b,c, name=value, name=value, d, e, delimiter=',', placeholder='$'" 
 //				
 
-int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
+int name_value_substitution(NAMEVALUELIST* nameValueList, char* tpass)
 {
     int err = 0;
 
@@ -39,14 +39,14 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
     initNameValueList(&newNameValueList);
 
     unsigned short strip = 0;        // Do Not Remove enclosing quotes from name value pairs
-    if (nameValuePairs(tpass, &newNameValueList, strip) == -1) {
+    if (name_value_pairs(tpass, &newNameValueList, strip) == -1) {
         err = 999;
         addIdamError(CODEERRORTYPE, "nameValueSubstitution", err, "Name Value pair syntax is incorrect!");
         return err;
     }
 
     if (newNameValueList.pairCount == 0) {    // No passed substitution values or additional name value pairs
-        if (newNameValueList.nameValue != NULL) freeNameValueList(&newNameValueList);
+        if (newNameValueList.nameValue != nullptr) free_name_value_list(&newNameValueList);
         return 0;
     }
 
@@ -58,8 +58,8 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
     // How many placeholders? [beginning with a '$' character. Placeholders may be numbered, named or simply a single naked $ character]
 
     int placeholderCount = 0;
-    int* placeholderIndex = NULL;
-    int* tpassIndex = NULL;
+    int* placeholderIndex = nullptr;
+    int* tpassIndex = nullptr;
     int tpassPosition = 0;
     unsigned short usedCount = 0;
 
@@ -70,7 +70,7 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
 
             for (int i = 0; i < nameValueList->pairCount; i++) {
                 // Is it a placeholder? (Not a keyword and begining '$')
-                if (nameValueList->nameValue[i].value != NULL && nameValueList->nameValue[i].value[0] == '$') {
+                if (nameValueList->nameValue[i].value != nullptr && nameValueList->nameValue[i].value[0] == '$') {
                     placeholderIndex[placeholderCount] = i;                    // Identify which pair
                     tpassIndex[placeholderCount] = tpassPosition++;            // Ordering: Default substitution value to use - list position
                     if (nameValueList->nameValue[i].value[1] != '\0') {
@@ -117,8 +117,8 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
                 break;
             }
 
-// Replace placeholders with identifed values
-// Replacement values can be used multiple times
+            // Replace placeholders with identifed values
+            // Replacement values can be used multiple times
 
             for (int i = 0; i < placeholderCount; i++) {
                 if (tpassIndex[i] < 0 || tpassIndex[i] > newNameValueList.pairCount) {
@@ -130,10 +130,10 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
                     break;
                 }
 
-                if (nameValueList->nameValue[placeholderIndex[i]].value != NULL)
+                if (nameValueList->nameValue[placeholderIndex[i]].value != nullptr)
                     free(nameValueList->nameValue[placeholderIndex[i]].value);
                 nameValueList->nameValue[placeholderIndex[i]].value = newNameValueList.nameValue[tpassIndex[i]].value;
-                newNameValueList.nameValue[tpassIndex[i]].value = NULL;
+                newNameValueList.nameValue[tpassIndex[i]].value = nullptr;
                 usedCount++;
 
                 UDA_LOG(UDA_LOG_DEBUG, "Placeholder: [%d][%d] %s, Substitution Value [%d] %s\n", i, placeholderIndex[i],
@@ -143,15 +143,15 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
 
             // Remove all used NV pairs used in placeholder substitution
             for (int i = 0; i < placeholderCount; i++) {
-                if (newNameValueList.nameValue[tpassIndex[i]].pair != NULL)
+                if (newNameValueList.nameValue[tpassIndex[i]].pair != nullptr)
                     free(newNameValueList.nameValue[tpassIndex[i]].pair);
-                if (newNameValueList.nameValue[tpassIndex[i]].name != NULL)
+                if (newNameValueList.nameValue[tpassIndex[i]].name != nullptr)
                     free(newNameValueList.nameValue[tpassIndex[i]].name);
-                if (newNameValueList.nameValue[tpassIndex[i]].value != NULL)
+                if (newNameValueList.nameValue[tpassIndex[i]].value != nullptr)
                     free(newNameValueList.nameValue[tpassIndex[i]].value);
-                newNameValueList.nameValue[tpassIndex[i]].pair = NULL;
-                newNameValueList.nameValue[tpassIndex[i]].name = NULL;
-                newNameValueList.nameValue[tpassIndex[i]].value = NULL;
+                newNameValueList.nameValue[tpassIndex[i]].pair = nullptr;
+                newNameValueList.nameValue[tpassIndex[i]].name = nullptr;
+                newNameValueList.nameValue[tpassIndex[i]].value = nullptr;
             }
 
         } while (0);
@@ -160,7 +160,7 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
     free(tpassIndex);
     free(placeholderIndex);
     if (err != 0) {
-        freeNameValueList(&newNameValueList);
+        free_name_value_list(&newNameValueList);
         return err;
     }
 
@@ -174,25 +174,25 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
     }
 
     for (int i = 0; i < newNameValueList.pairCount; i++) {
-        if (newNameValueList.nameValue[i].name != NULL) {
+        if (newNameValueList.nameValue[i].name != nullptr) {
             nameValueList->nameValue[nameValueList->pairCount].pair = newNameValueList.nameValue[i].pair;
-            if (nameValueList->nameValue[nameValueList->pairCount].pair == NULL)
+            if (nameValueList->nameValue[nameValueList->pairCount].pair == nullptr)
                 nameValueList->nameValue[nameValueList->pairCount].pair = strdup("");
             nameValueList->nameValue[nameValueList->pairCount].name = newNameValueList.nameValue[i].name;
             nameValueList->nameValue[nameValueList->pairCount++].value = newNameValueList.nameValue[i].value;
             UDA_LOG(UDA_LOG_DEBUG, "[%d] Name = %s, Value = %s\n", i, newNameValueList.nameValue[i].name,
                     newNameValueList.nameValue[i].value);
-            newNameValueList.nameValue[i].pair = NULL;
-            newNameValueList.nameValue[i].name = NULL;
-            newNameValueList.nameValue[i].value = NULL;
+            newNameValueList.nameValue[i].pair = nullptr;
+            newNameValueList.nameValue[i].name = nullptr;
+            newNameValueList.nameValue[i].value = nullptr;
         }
     }
 
-    freeNameValueList(&newNameValueList);
+    free_name_value_list(&newNameValueList);
 
     // Scan all values for embedded placeholders and substitute
 
-    embeddedValueSubstitution(nameValueList);
+    embedded_value_substitution(nameValueList);
 
     return 0;
 }
@@ -202,7 +202,7 @@ int nameValueSubstitution(NAMEVALUELIST* nameValueList, char* tpass)
 
 // patterns with name values: string="UDA::getdata(variable='/a/b/c', shot=$shot, tstart=$tstart, tend=$tend)"	substitution for named string elements: $shot, $tstart, $tend
 
-void embeddedValueSubstitution(NAMEVALUELIST* nameValueList)
+void embedded_value_substitution(NAMEVALUELIST* nameValueList)
 {
     int m;
     NAMEVALUELIST newNameValueList;
@@ -231,7 +231,7 @@ void embeddedValueSubstitution(NAMEVALUELIST* nameValueList)
 
         // Extract NV pairs and keywords from the input placeholder value
 
-        int rc = nameValuePairs(work, &newNameValueList, strip);
+        int rc = name_value_pairs(work, &newNameValueList, strip);
         free(work);
         if (rc == -1) continue;
 
@@ -300,6 +300,6 @@ void embeddedValueSubstitution(NAMEVALUELIST* nameValueList)
             }
         }
     }
-    freeNameValueList(&newNameValueList);
+    free_name_value_list(&newNameValueList);
 }   
 
diff --git a/source/clientserver/nameValueSubstitution.h b/source/clientserver/nameValueSubstitution.h
new file mode 100644
index 00000000..5dbeb073
--- /dev/null
+++ b/source/clientserver/nameValueSubstitution.h
@@ -0,0 +1,9 @@
+#ifndef UDA_CLIENTSERVER_NAMEVALUESUBSTITUTION_H
+#define UDA_CLIENTSERVER_NAMEVALUESUBSTITUTION_H
+
+#include "export.h"
+#include "udaStructs.h"
+
+LIBRARY_API int name_value_substitution(NAMEVALUELIST* nameValueList, char* tpass);
+
+#endif // UDA_CLIENTSERVER_NAMEVALUESUBSTITUTION_H
diff --git a/source/clientserver/parseOperation.cpp b/source/clientserver/parseOperation.cpp
index f1ff42bb..2b13477b 100755
--- a/source/clientserver/parseOperation.cpp
+++ b/source/clientserver/parseOperation.cpp
@@ -1,14 +1,12 @@
 #include "parseOperation.h"
 
-#include <errno.h>
-#include <stdlib.h>
-
-#include <clientserver/udaErrors.h>
+#include <cerrno>
+#include <cstdlib>
 
 #include "stringUtils.h"
 #include "errorLog.h"
 
-int idamParseOperation(SUBSET* sub)
+int parseOperation(SUBSET* sub)
 {
     char* p, * t1, * t2;
     char* endp = nullptr;
@@ -30,8 +28,12 @@ int idamParseOperation(SUBSET* sub)
 
         strcpy(opcopy, sub->operation[i]);
 
-        if ((p = strchr(opcopy, '[')) != nullptr) p[0] = ' ';
-        if ((p = strchr(opcopy, ']')) != nullptr) p[0] = ' ';
+        if ((p = strchr(opcopy, '[')) != nullptr) {
+            p[0] = ' ';
+        }
+        if ((p = strchr(opcopy, ']')) != nullptr) {
+            p[0] = ' ';
+        }
         LeftTrimString(opcopy);
         TrimString(opcopy);
 
@@ -50,16 +52,10 @@ int idamParseOperation(SUBSET* sub)
                 if (IsNumber(t1)) {
                     sub->lbindex[i] = strtol(t1, &endp, 0);        // the Lower Index Value of the Bound
                     if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                     "Server Side Operation Syntax Error: Lower Index Bound ");
-                        return ierr;
+                        THROW_ERROR(9999, "Server Side Operation Syntax Error: Lower Index Bound");
                     }
                 } else {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                 "Server Side Operation Syntax Error: Lower Index Bound ");
-                    return ierr;
+                    THROW_ERROR(9999, "Server Side Operation Syntax Error: Lower Index Bound");
                 }
             }
 
@@ -67,25 +63,18 @@ int idamParseOperation(SUBSET* sub)
                 if (IsNumber(t2)) {
                     sub->ubindex[i] = strtol(t2, &endp, 0);        // the Upper Index Value of the Bound
                     if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                     "Server Side Operation Syntax Error: Upper Index Bound ");
-                        return ierr;
+                        THROW_ERROR(9999, "Server Side Operation Syntax Error: Upper Index Bound");
                     }
                 } else {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                 "Server Side Operation Syntax Error: Upper Index Bound ");
-                    return ierr;
+                    THROW_ERROR(9999, "Server Side Operation Syntax Error: Upper Index Bound");
                 }
             }
 
             strcpy(sub->operation[i], ":");            // Define Simple Operation
             continue;
-
         }
 
-        if ((p = strstr(opcopy, "*")) != nullptr) {        // Ignore this Dimension
+        if (strstr(opcopy, "*") != nullptr) {        // Ignore this Dimension
             sub->isindex[i] = 1;
             sub->ubindex[i] = -1;
             sub->lbindex[i] = -1;
@@ -93,7 +82,7 @@ int idamParseOperation(SUBSET* sub)
             continue;
         }
 
-        if ((p = strstr(opcopy, "#")) != nullptr) {        // Last Value in Dimension
+        if (strstr(opcopy, "#") != nullptr) {        // Last Value in Dimension
             sub->isindex[i] = 1;
             sub->ubindex[i] = -1;
             sub->lbindex[i] = -1;
@@ -106,7 +95,7 @@ int idamParseOperation(SUBSET* sub)
             sub->ubindex[i] = strtol(opcopy, &endp, 0);        // the Index Value of the Bound
             if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
                 ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
+                addIdamError(CODEERRORTYPE, "serverParseServerSide", ierr,
                              "Server Side Operation Syntax Error: Single Index Bound ");
                 return ierr;
             }
diff --git a/source/clientserver/parseOperation.h b/source/clientserver/parseOperation.h
index ec1f88f1..6b0706c0 100755
--- a/source/clientserver/parseOperation.h
+++ b/source/clientserver/parseOperation.h
@@ -2,18 +2,13 @@
 #define UDA_CLIENTSERVER_PARSEOPERATION_H
 
 #include "parseXML.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int idamParseOperation(SUBSET* sub);
+LIBRARY_API int parseOperation(SUBSET* sub);
 
 #ifdef __cplusplus
 }
diff --git a/source/clientserver/parseXML.cpp b/source/clientserver/parseXML.cpp
index 3a7e62f6..d7b9c9a1 100755
--- a/source/clientserver/parseXML.cpp
+++ b/source/clientserver/parseXML.cpp
@@ -24,10 +24,33 @@
 #include <clientserver/parseOperation.h>
 #include <clientserver/errorLog.h>
 
+static double deScale(char* scale);
+static void parse_target_value(xmlDocPtr doc, xmlNodePtr cur, const char* target, double* value);
+static void parse_target_string(xmlDocPtr doc, xmlNodePtr cur, const char* target, char* str);
+static void parse_fixed_length_array(xmlNodePtr cur, const char* target, void* array, int arraytype, int* n);
+static void parse_documentation(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
+static void parse_calibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
+static void parse_time_offset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
+static void parse_error_model(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
+static void parse_subset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
+static void print_dimensions(int ndim, DIMENSION* dims);
+static void init_dim_calibration(DIMCALIBRATION* act);
+static void init_dim_composite(DIMCOMPOSITE* act);
+static void init_dim_documentation(DIMDOCUMENTATION* act);
+static void init_dim_error_model(DIMERRORMODEL* act);
+static void init_dimension(DIMENSION* act);
+static void init_time_offset(TIMEOFFSET* act);
+static void init_calibration(CALIBRATION* act);
+static void init_documentation(DOCUMENTATION* act);
+static void init_composite(COMPOSITE* act);
+static void init_error_model(ERRORMODEL* act);
+
 // Simple Tags with Delimited List of Floating Point Values
 // Assume No Attributes
 
-float* parseFloatArray(xmlDocPtr doc, xmlNodePtr cur, const char* target, int* n)
+static float* parse_float_array(xmlDocPtr doc, xmlNodePtr cur, const char* target, int* n);
+
+float* parse_float_array(xmlDocPtr doc, xmlNodePtr cur, const char* target, int* n)
 {
     xmlChar* key = nullptr;
     float* value = nullptr;
@@ -38,22 +61,22 @@ float* parseFloatArray(xmlDocPtr doc, xmlNodePtr cur, const char* target, int* n
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) target))) {
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)target))) {
             key = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
-            convertNonPrintable((char*) key);
-            if (strlen((char*) key) > 0) {
-                int lkey = (int) strlen((char*) key);
+            convertNonPrintable((char*)key);
+            if (strlen((char*)key) > 0) {
+                int lkey = (int)strlen((char*)key);
                 UDA_LOG(UDA_LOG_DEBUG, "parseFloatArray: [%d] %s %s \n", lkey, target, key);
-                item = strtok((char*) key, delim);
+                item = strtok((char*)key, delim);
                 if (item != nullptr) {
                     nco++;
                     UDA_LOG(UDA_LOG_DEBUG, "parseFloatArray: [%d] %s \n", nco, item);
-                    value = (float*) realloc((void*) value, nco * sizeof(float));
+                    value = (float*)realloc((void*)value, nco * sizeof(float));
                     value[nco - 1] = atof(item);
                     UDA_LOG(UDA_LOG_DEBUG, "parseFloatArray: [%d] %s %f\n", nco, item, value[nco - 1]);
                     while ((item = strtok(nullptr, delim)) != nullptr && nco <= XMLMAXLOOP) {
                         nco++;
-                        value = (float*) realloc((void*) value, nco * sizeof(float));
+                        value = (float*)realloc((void*)value, nco * sizeof(float));
                         value[nco - 1] = atof(item);
                         UDA_LOG(UDA_LOG_DEBUG, "parseFloatArray: [%d] %s %f\n", nco, item, value[nco - 1]);
                     }
@@ -68,8 +91,7 @@ float* parseFloatArray(xmlDocPtr doc, xmlNodePtr cur, const char* target, int* n
     return value;
 }
 
-
-void parseFixedLengthArray(xmlNodePtr cur, const char* target, void* array, int arraytype, int* n)
+void parse_fixed_length_array(xmlNodePtr cur, const char* target, void* array, int arraytype, int* n)
 {
     xmlChar* att = nullptr;
     *n = 0;
@@ -77,64 +99,63 @@ void parseFixedLengthArray(xmlNodePtr cur, const char* target, void* array, int
     char* item;
     int nco = 0;
 
-    double* dp;
-    float* fp;
-    int* ip;
-    long* lp;
-
-    if ((att = xmlGetProp(cur, (xmlChar*) target)) != nullptr) {
-        convertNonPrintable((char*) att);
-        if (strlen((char*) att) > 0) {
-            int l = (int) strlen((char*) att);
+    if ((att = xmlGetProp(cur, (xmlChar*)target)) != nullptr) {
+        convertNonPrintable((char*)att);
+        if (strlen((char*)att) > 0) {
+            int l = (int)strlen((char*)att);
             UDA_LOG(UDA_LOG_DEBUG, "parseFixedLengthArray: [%d] %s %s \n", l, target, att);
-            item = strtok((char*) att, delim);
+            item = strtok((char*)att, delim);
             if (item != nullptr) {
                 nco++;
                 switch (arraytype) {
-                    case UDA_TYPE_FLOAT:
-                        fp = (float*) array;
+                    case UDA_TYPE_FLOAT: {
+                        auto fp = (float*)array;
                         fp[nco - 1] = atof(item);
                         break;
-                    case UDA_TYPE_DOUBLE:
-                        dp = (double*) array;
+                    }
+                    case UDA_TYPE_DOUBLE: {
+                        auto dp = (double*)array;
                         dp[nco - 1] = strtod(item, nullptr);
                         break;
+                    }
                     case UDA_TYPE_CHAR: {
-                        char* p = (char*) array;
-                        p[nco - 1] = (char) atoi(item);
+                        auto p = (char*)array;
+                        p[nco - 1] = (char)atoi(item);
                         break;
                     }
                     case UDA_TYPE_SHORT: {
-                        short* p = (short*) array;
-                        p[nco - 1] = (short) atoi(item);
+                        auto p = (short*)array;
+                        p[nco - 1] = (short)atoi(item);
                         break;
                     }
-                    case UDA_TYPE_INT:
-                        ip = (int*) array;
-                        ip[nco - 1] = (int) atoi(item);
+                    case UDA_TYPE_INT: {
+                        auto ip = (int*)array;
+                        ip[nco - 1] = (int)atoi(item);
                         break;
-                    case UDA_TYPE_LONG:
-                        lp = (long*) array;
-                        lp[nco - 1] = (long) atol(item);
+                    }
+                    case UDA_TYPE_LONG: {
+                        auto lp = (long*)array;
+                        lp[nco - 1] = (long)atol(item);
                         break;
+                    }
                     case UDA_TYPE_UNSIGNED_CHAR: {
-                        unsigned char* p = (unsigned char*) array;
-                        p[nco - 1] = (unsigned char) atoi(item);
+                        auto p = (unsigned char*)array;
+                        p[nco - 1] = (unsigned char)atoi(item);
                         break;
                     }
                     case UDA_TYPE_UNSIGNED_SHORT: {
-                        unsigned short* p = (unsigned short*) array;
-                        p[nco - 1] = (unsigned short) atoi(item);
+                        auto p = (unsigned short*)array;
+                        p[nco - 1] = (unsigned short)atoi(item);
                         break;
                     }
                     case UDA_TYPE_UNSIGNED_INT: {
-                        unsigned int* p = (unsigned int*) array;
-                        p[nco - 1] = (unsigned int) atoi(item);
+                        auto p = (unsigned int*)array;
+                        p[nco - 1] = (unsigned int)atoi(item);
                         break;
                     }
                     case UDA_TYPE_UNSIGNED_LONG: {
-                        unsigned long* p = (unsigned long*) array;
-                        p[nco - 1] = (unsigned long) atol(item);
+                        auto p = (unsigned long*)array;
+                        p[nco - 1] = (unsigned long)atol(item);
                         break;
                     }
                     default:
@@ -144,50 +165,54 @@ void parseFixedLengthArray(xmlNodePtr cur, const char* target, void* array, int
                 while ((item = strtok(nullptr, delim)) != nullptr && nco <= MAXDATARANK) {
                     nco++;
                     switch (arraytype) {
-                        case UDA_TYPE_FLOAT:
-                            fp = (float*) array;
+                        case UDA_TYPE_FLOAT: {
+                            auto fp = (float*)array;
                             fp[nco - 1] = atof(item);
                             break;
-                        case UDA_TYPE_DOUBLE:
-                            dp = (double*) array;
+                        }
+                        case UDA_TYPE_DOUBLE: {
+                            auto dp = (double*)array;
                             dp[nco - 1] = strtod(item, nullptr);
                             break;
+                        }
                         case UDA_TYPE_CHAR: {
-                            char* p = (char*) array;
-                            p[nco - 1] = (char) atoi(item);
+                            auto p = (char*)array;
+                            p[nco - 1] = (char)atoi(item);
                             break;
                         }
                         case UDA_TYPE_SHORT: {
-                            short* p = (short*) array;
-                            p[nco - 1] = (short) atoi(item);
+                            auto p = (short*)array;
+                            p[nco - 1] = (short)atoi(item);
                             break;
                         }
-                        case UDA_TYPE_INT:
-                            ip = (int*) array;
-                            ip[nco - 1] = (int) atoi(item);
+                        case UDA_TYPE_INT: {
+                            auto ip = (int*)array;
+                            ip[nco - 1] = (int)atoi(item);
                             break;
-                        case UDA_TYPE_LONG:
-                            lp = (long*) array;
-                            lp[nco - 1] = (long) atol(item);
+                        }
+                        case UDA_TYPE_LONG: {
+                            auto lp = (long*)array;
+                            lp[nco - 1] = (long)atol(item);
                             break;
+                        }
                         case UDA_TYPE_UNSIGNED_CHAR: {
-                            unsigned char* p = (unsigned char*) array;
-                            p[nco - 1] = (unsigned char) atoi(item);
+                            auto p = (unsigned char*)array;
+                            p[nco - 1] = (unsigned char)atoi(item);
                             break;
                         }
                         case UDA_TYPE_UNSIGNED_SHORT: {
-                            unsigned short* p = (unsigned short*) array;
-                            p[nco - 1] = (unsigned short) atoi(item);
+                            auto p = (unsigned short*)array;
+                            p[nco - 1] = (unsigned short)atoi(item);
                             break;
                         }
                         case UDA_TYPE_UNSIGNED_INT: {
-                            unsigned int* p = (unsigned int*) array;
-                            p[nco - 1] = (unsigned int) atoi(item);
+                            auto p = (unsigned int*)array;
+                            p[nco - 1] = (unsigned int)atoi(item);
                             break;
                         }
                         case UDA_TYPE_UNSIGNED_LONG: {
-                            unsigned long* p = (unsigned long*) array;
-                            p[nco - 1] = (unsigned long) atol(item);
+                            auto p = (unsigned long*)array;
+                            p[nco - 1] = (unsigned long)atol(item);
                             break;
                         }
                         default:
@@ -201,8 +226,7 @@ void parseFixedLengthArray(xmlNodePtr cur, const char* target, void* array, int
     }
 }
 
-
-void parseFixedLengthStrArray(xmlNodePtr cur, const char* target, char array[MAXDATARANK][SXMLMAXSTRING], int* n)
+void parse_fixed_length_str_array(xmlNodePtr cur, const char* target, char array[MAXDATARANK][SXMLMAXSTRING], int* n)
 {
     xmlChar* att = nullptr;
     *n = 0;
@@ -210,11 +234,11 @@ void parseFixedLengthStrArray(xmlNodePtr cur, const char* target, char array[MAX
     char* item;
     int nco = 0;
 
-    if ((att = xmlGetProp(cur, (xmlChar*) target)) != nullptr) {
-        if (strlen((char*) att) > 0) {
-            int l = (int) strlen((char*) att);
+    if ((att = xmlGetProp(cur, (xmlChar*)target)) != nullptr) {
+        if (strlen((char*)att) > 0) {
+            int l = (int)strlen((char*)att);
             UDA_LOG(UDA_LOG_DEBUG, "parseFixedLengthStrArray: [%d] %s %s \n", l, target, att);
-            item = strtok((char*) att, delim);
+            item = strtok((char*)att, delim);
             if (item != nullptr) {
                 nco++;
                 if (strlen(item) < SXMLMAXSTRING) {
@@ -263,17 +287,17 @@ double deScale(char* scale)
 // Locate and extract Named Parameter (Numerical and String) Values
 // Assume only 1 tag per document
 
-void parseTargetValue(xmlDocPtr doc, xmlNodePtr cur, const char* target, double* value)
+void parse_target_value(xmlDocPtr doc, xmlNodePtr cur, const char* target, double* value)
 {
     xmlChar* key = nullptr;
     xmlChar* scale = nullptr;
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) target))) {
-            scale = xmlGetProp(cur, (xmlChar*) "scale");
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)target))) {
+            scale = xmlGetProp(cur, (xmlChar*)"scale");
             key = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
-            if (key != nullptr) *value = (double) atof((char*) key);
-            if (scale != nullptr) *value = *value * deScale((char*) scale);
+            if (key != nullptr) *value = (double)atof((char*)key);
+            if (scale != nullptr) *value = *value * deScale((char*)scale);
             xmlFree(key);
             xmlFree(scale);
             break;
@@ -282,14 +306,14 @@ void parseTargetValue(xmlDocPtr doc, xmlNodePtr cur, const char* target, double*
     }
 }
 
-void parseTargetString(xmlDocPtr doc, xmlNodePtr cur, const char* target, char* str)
+void parse_target_string(xmlDocPtr doc, xmlNodePtr cur, const char* target, char* str)
 {
     xmlChar* key = nullptr;
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) target))) {
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)target))) {
             key = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
-            if (key != nullptr) strcpy(str, (char*) key);
+            if (key != nullptr) strcpy(str, (char*)key);
             xmlFree(key);
             break;
         }
@@ -297,7 +321,7 @@ void parseTargetString(xmlDocPtr doc, xmlNodePtr cur, const char* target, char*
     }
 }
 
-void parseTimeOffset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
+void parse_time_offset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 {
 
     xmlChar* att;    // General Input of tag attribute values
@@ -307,80 +331,80 @@ void parseTimeOffset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseTimeOffset: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "time_offset"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "%s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"time_offset"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = TIMEOFFSETTYPE;
-            initTimeOffset(&str[n - 1].timeoffset);
+            init_time_offset(&str[n - 1].timeoffset);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range Start: %d\n", str[n - 1].exp_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range End : %d\n", str[n - 1].exp_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range Start: %d\n", str[n - 1].pass_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range End  : %d\n", str[n - 1].pass_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "value")) != nullptr) {
-                if (strlen((char*) att) > 0) {
-                    str[n - 1].timeoffset.offset = (double) atof((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"value")) != nullptr) {
+                if (strlen((char*)att) > 0) {
+                    str[n - 1].timeoffset.offset = (double)atof((char*)att);
                     UDA_LOG(UDA_LOG_DEBUG, "Time Offset  : %f\n", str[n - 1].timeoffset.offset);
                 }
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "method")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].timeoffset.method = (int) atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"method")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].timeoffset.method = (int)atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Time Offset Method  : %d\n", str[n - 1].timeoffset.method);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "start")) != nullptr) {
-                if (strlen((char*) att) > 0) {
-                    str[n - 1].timeoffset.offset = (double) atof((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"start")) != nullptr) {
+                if (strlen((char*)att) > 0) {
+                    str[n - 1].timeoffset.offset = (double)atof((char*)att);
                     UDA_LOG(UDA_LOG_DEBUG, "Start Time  : %f\n", str[n - 1].timeoffset.offset);
                 }
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "interval")) != nullptr) {
-                if (strlen((char*) att) > 0) {
-                    str[n - 1].timeoffset.interval = (double) atof((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"interval")) != nullptr) {
+                if (strlen((char*)att) > 0) {
+                    str[n - 1].timeoffset.interval = (double)atof((char*)att);
                     UDA_LOG(UDA_LOG_DEBUG, "Time Interval: %f\n", str[n - 1].timeoffset.interval);
                 }
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "scale")) != nullptr) {
-                if (strlen((char*) att) > 0)
-                    str[n - 1].timeoffset.offset = deScale((char*) att) * str[n - 1].timeoffset.offset;
+            if ((att = xmlGetProp(cur, (xmlChar*)"scale")) != nullptr) {
+                if (strlen((char*)att) > 0)
+                    str[n - 1].timeoffset.offset = deScale((char*)att) * str[n - 1].timeoffset.offset;
                 UDA_LOG(UDA_LOG_DEBUG, "Scaled Time Offset  : %f\n", str[n - 1].timeoffset.offset);
                 xmlFree(att);
             }
@@ -405,62 +429,62 @@ void parseCompositeSubset(xmlDocPtr doc, xmlNodePtr cur, COMPOSITE* comp)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseCompositeSubset: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "subset"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseCompositeSubset: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"subset"))) {
             n++;
-            str = (SUBSET*) realloc((void*) str, n * sizeof(SUBSET));
+            str = (SUBSET*)realloc((void*)str, n * sizeof(SUBSET));
 
             initSubset(&str[n - 1]);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "data")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].data_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"data")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].data_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset Signal: %s\n", str[n - 1].data_signal);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "reform")) != nullptr) {
+            if ((att = xmlGetProp(cur, (xmlChar*)"reform")) != nullptr) {
                 if (att[0] == 'Y' || att[0] == 'y') str[n - 1].reform = 1;
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "member")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].member, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"member")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].member, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset member: %s\n", str[n - 1].member);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "function")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].function, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"function")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].function, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset function: %s\n", str[n - 1].function);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "order")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].order = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"order")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].order = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset order: %d\n", str[n - 1].order);
                 xmlFree(att);
             }
 
             // Fixed Length Attribute Arrays
 
-            parseFixedLengthStrArray(cur, "operation", str[n - 1].operation, &str[n - 1].nbound);
+            parse_fixed_length_str_array(cur, "operation", str[n - 1].operation, &str[n - 1].nbound);
             for (int i = 0; i < str[n - 1].nbound; i++)
                 str[n - 1].dimid[i] = i;                    // Ordering is as DATA[4][3][2][1][0]
 
-            parseFixedLengthArray(cur, "bound", (void*) str[n - 1].bound, UDA_TYPE_DOUBLE, &n0);
-            parseFixedLengthArray(cur, "dimid", (void*) str[n - 1].dimid, UDA_TYPE_INT, &n1);
+            parse_fixed_length_array(cur, "bound", (void*)str[n - 1].bound, UDA_TYPE_DOUBLE, &n0);
+            parse_fixed_length_array(cur, "dimid", (void*)str[n - 1].dimid, UDA_TYPE_INT, &n1);
 
-            if (idamParseOperation(&str[n - 1]) != 0) return;
+            if (parseOperation(&str[n - 1]) != 0) return;
 
             for (int i = 0; i < str[n - 1].nbound; i++) {
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Bounding Values : %e\n", str[n - 1].bound[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Operation       : %s\n", str[n - 1].operation[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension ID               : %d\n", str[n - 1].dimid[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Is Index?       : %d\n", str[n - 1].isindex[i]);
-                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Lower Index     : %d\n", (int) str[n - 1].lbindex[i]);
-                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Upper Index     : %d\n", (int) str[n - 1].ubindex[i]);
+                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Lower Index     : %d\n", (int)str[n - 1].lbindex[i]);
+                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Upper Index     : %d\n", (int)str[n - 1].ubindex[i]);
             }
         }
         cur = cur->next;
@@ -485,57 +509,57 @@ void parseDimComposite(xmlDocPtr doc, xmlNodePtr cur, COMPOSITE* comp)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseDimComposite: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "composite_dim"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseDimComposite: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"composite_dim"))) {
             n++;
-            str = (DIMENSION*) realloc((void*) str, n * sizeof(DIMENSION));
+            str = (DIMENSION*)realloc((void*)str, n * sizeof(DIMENSION));
 
-            initDimension(&str[n - 1]);
+            init_dimension(&str[n - 1]);
             str[n - 1].dimType = DIMCOMPOSITETYPE;
-            initDimComposite(&str[n - 1].dimcomposite);
+            init_dim_composite(&str[n - 1].dimcomposite);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "to_dim")) != nullptr) {            // Target Dimension
-                if (strlen((char*) att) > 0) {
-                    str[n - 1].dimid = atoi((char*) att);                // Duplicate these tags for convenience
-                    str[n - 1].dimcomposite.to_dim = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"to_dim")) != nullptr) {            // Target Dimension
+                if (strlen((char*)att) > 0) {
+                    str[n - 1].dimid = atoi((char*)att);                // Duplicate these tags for convenience
+                    str[n - 1].dimcomposite.to_dim = atoi((char*)att);
                 }
                 UDA_LOG(UDA_LOG_DEBUG, "To Dimension  : %d\n", str[n - 1].dimid);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "from_dim")) !=
+            if ((att = xmlGetProp(cur, (xmlChar*)"from_dim")) !=
                 nullptr) {        // Swap with this Dimension otherwise swap with Data
-                if (strlen((char*) att) > 0) str[n - 1].dimcomposite.from_dim = atoi((char*) att);
+                if (strlen((char*)att) > 0) str[n - 1].dimcomposite.from_dim = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "From Dimension  : %d\n", str[n - 1].dimcomposite.from_dim);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "dim")) != nullptr ||
-                (att = xmlGetProp(cur, (xmlChar*) "data")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].dimcomposite.dim_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"dim")) != nullptr ||
+                (att = xmlGetProp(cur, (xmlChar*)"data")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].dimcomposite.dim_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension Signal  : %s\n", str[n - 1].dimcomposite.dim_signal);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "error")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].dimcomposite.dim_error, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"error")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].dimcomposite.dim_error, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Error Signal  : %s\n", str[n - 1].dimcomposite.dim_error);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "aserror")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].dimcomposite.dim_aserror, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"aserror")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].dimcomposite.dim_aserror, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Error Signal  : %s\n", str[n - 1].dimcomposite.dim_aserror);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "file")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].dimcomposite.file, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"file")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].dimcomposite.file, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension Source File: %s\n", str[n - 1].dimcomposite.file);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "format")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].dimcomposite.format, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"format")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].dimcomposite.format, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension Source File Format: %s\n", str[n - 1].dimcomposite.format);
                 xmlFree(att);
             }
@@ -558,84 +582,84 @@ void parseComposite(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseComposite: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "composite"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseComposite: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"composite"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = COMPOSITETYPE;
-            initComposite(&str[n - 1].composite);
+            init_composite(&str[n - 1].composite);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range Start: %d\n", str[n - 1].exp_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range End : %d\n", str[n - 1].exp_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range Start: %d\n", str[n - 1].pass_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range End  : %d\n", str[n - 1].pass_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "data")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.data_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"data")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.data_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Data Signal  : %s\n", str[n - 1].composite.data_signal);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "file")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.file, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"file")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.file, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Data Source File: %s\n", str[n - 1].composite.file);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "format")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.format, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"format")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.format, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Source File Format: %s\n", str[n - 1].composite.format);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "error")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.error_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"error")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.error_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Error Signal  : %s\n", str[n - 1].composite.error_signal);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "aserror")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.aserror_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"aserror")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.aserror_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Error Signal  : %s\n", str[n - 1].composite.aserror_signal);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "mapto")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].composite.aserror_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"mapto")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].composite.aserror_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Map to Signal  : %s\n", str[n - 1].composite.map_to_signal);
                 xmlFree(att);
             }
 
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "order")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].composite.order = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"order")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].composite.order = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Time Dimension: %d\n", str[n - 1].composite.order);
                 xmlFree(att);
             }
@@ -669,37 +693,37 @@ void parseDimErrorModel(xmlDocPtr doc, xmlNodePtr cur, ERRORMODEL* mod)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseDimErrorModel: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "dimension"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseDimErrorModel: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"dimension"))) {
             n++;
-            str = (DIMENSION*) realloc((void*) str, n * sizeof(DIMENSION));
+            str = (DIMENSION*)realloc((void*)str, n * sizeof(DIMENSION));
 
-            initDimension(&str[n - 1]);
+            init_dimension(&str[n - 1]);
             str[n - 1].dimType = DIMERRORMODELTYPE;
-            initDimErrorModel(&str[n - 1].dimerrormodel);
+            init_dim_error_model(&str[n - 1].dimerrormodel);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "dimid")) != nullptr) {            // Target Dimension
-                if (strlen((char*) att) > 0) str[n - 1].dimid = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"dimid")) != nullptr) {            // Target Dimension
+                if (strlen((char*)att) > 0) str[n - 1].dimid = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension : %d\n", str[n - 1].dimid);
                 xmlFree(att);
             }
-            if ((att = xmlGetProp(cur, (xmlChar*) "model")) != nullptr) {            // Error Model
-                if (strlen((char*) att) > 0) str[n - 1].dimerrormodel.model = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"model")) != nullptr) {            // Error Model
+                if (strlen((char*)att) > 0) str[n - 1].dimerrormodel.model = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Model : %d\n", str[n - 1].dimerrormodel.model);
                 xmlFree(att);
             }
 
             // Child Tags
 
-            params = parseFloatArray(doc, cur, "params", &str[n - 1].dimerrormodel.param_n);
+            params = parse_float_array(doc, cur, "params", &str[n - 1].dimerrormodel.param_n);
             if (params != nullptr) {
                 if (str[n - 1].dimerrormodel.param_n > MAXERRPARAMS) str[n - 1].dimerrormodel.param_n = MAXERRPARAMS;
                 for (int i = 0; i < str[n - 1].dimerrormodel.param_n; i++) {
                     str[n - 1].dimerrormodel.params[i] = params[i];
                 }
-                free((void*) params);
+                free(params);
             }
 
 
@@ -711,7 +735,7 @@ void parseDimErrorModel(xmlDocPtr doc, xmlNodePtr cur, ERRORMODEL* mod)
 }
 
 
-void parseErrorModel(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
+void parse_error_model(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 {
     xmlChar* att;    // General Input of tag attribute values
     float* params;
@@ -721,62 +745,62 @@ void parseErrorModel(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseErrorModel: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "errormodel"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseErrorModel: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"errormodel"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = ERRORMODELTYPE;
-            initErrorModel(&str[n - 1].errormodel);
+            init_error_model(&str[n - 1].errormodel);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range Start: %d\n", str[n - 1].exp_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range End : %d\n", str[n - 1].exp_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range Start: %d\n", str[n - 1].pass_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range End  : %d\n", str[n - 1].pass_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "model")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].errormodel.model = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"model")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].errormodel.model = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Error Distribution Model: %d\n", str[n - 1].errormodel.model);
                 xmlFree(att);
             }
 
             // Child Tags
 
-            params = parseFloatArray(doc, cur, "params", &str[n - 1].errormodel.param_n);
+            params = parse_float_array(doc, cur, "params", &str[n - 1].errormodel.param_n);
             if (params != nullptr) {
                 if (str[n - 1].errormodel.param_n > MAXERRPARAMS) str[n - 1].errormodel.param_n = MAXERRPARAMS;
                 for (int i = 0; i < str[n - 1].errormodel.param_n; i++) {
                     str[n - 1].errormodel.params[i] = params[i];
                 }
-                free((void*) params);
+                free(params);
             }
 
             parseDimErrorModel(doc, cur, &str[n - 1].errormodel);
@@ -797,27 +821,27 @@ void parseDimDocumentation(xmlDocPtr doc, xmlNodePtr cur, DOCUMENTATION* documen
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseDimDocumentation: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "dimension"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseDimDocumentation: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"dimension"))) {
             n++;
-            str = (DIMENSION*) realloc((void*) str, n * sizeof(DIMENSION));
+            str = (DIMENSION*)realloc((void*)str, n * sizeof(DIMENSION));
 
-            initDimension(&str[n - 1]);
+            init_dimension(&str[n - 1]);
             str[n - 1].dimType = DIMDOCUMENTATIONTYPE;
-            initDimDocumentation(&str[n - 1].dimdocumentation);
+            init_dim_documentation(&str[n - 1].dimdocumentation);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "dimid")) != nullptr) {            // Target Dimension
-                if (strlen((char*) att) > 0) str[n - 1].dimid = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"dimid")) != nullptr) {            // Target Dimension
+                if (strlen((char*)att) > 0) str[n - 1].dimid = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "To Dimension  : %d\n", str[n - 1].dimid);
                 xmlFree(att);
             }
 
             // Child Tags
 
-            parseTargetString(doc, cur, "label", str[n - 1].dimdocumentation.label);
-            parseTargetString(doc, cur, "units", str[n - 1].dimdocumentation.units);
+            parse_target_string(doc, cur, "label", str[n - 1].dimdocumentation.label);
+            parse_target_string(doc, cur, "units", str[n - 1].dimdocumentation.units);
 
         }
         cur = cur->next;
@@ -826,7 +850,7 @@ void parseDimDocumentation(xmlDocPtr doc, xmlNodePtr cur, DOCUMENTATION* documen
     document->dimensions = str;    // Array of Composite Signal Actions on Dimensions
 }
 
-void parseDocumentation(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
+void parse_documentation(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 {
     xmlChar* att;    // General Input of tag attribute values
 
@@ -835,52 +859,52 @@ void parseDocumentation(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseDocumentation: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "documentation"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseDocumentation: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"documentation"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = DOCUMENTATIONTYPE;
-            initDocumentation(&str[n - 1].documentation);
+            init_documentation(&str[n - 1].documentation);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range Start: %d\n", str[n - 1].exp_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range End : %d\n", str[n - 1].exp_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range Start: %d\n", str[n - 1].pass_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range End  : %d\n", str[n - 1].pass_range[1]);
                 xmlFree(att);
             }
 
             // Child Tags
 
-            parseTargetString(doc, cur, "description", str[n - 1].documentation.description);
-            parseTargetString(doc, cur, "label", str[n - 1].documentation.label);
-            parseTargetString(doc, cur, "units", str[n - 1].documentation.units);
+            parse_target_string(doc, cur, "description", str[n - 1].documentation.description);
+            parse_target_string(doc, cur, "label", str[n - 1].documentation.label);
+            parse_target_string(doc, cur, "units", str[n - 1].documentation.units);
 
             parseDimDocumentation(doc, cur, &str[n - 1].documentation);
 
@@ -900,24 +924,24 @@ void parseDimCalibration(xmlDocPtr doc, xmlNodePtr cur, CALIBRATION* cal)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseDimCalibration: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "dimension"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseDimCalibration: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"dimension"))) {
             n++;
-            str = (DIMENSION*) realloc((void*) str, n * sizeof(DIMENSION));
+            str = (DIMENSION*)realloc((void*)str, n * sizeof(DIMENSION));
 
-            initDimension(&str[n - 1]);
+            init_dimension(&str[n - 1]);
             str[n - 1].dimType = DIMCALIBRATIONTYPE;
-            initDimCalibration(&str[n - 1].dimcalibration);
+            init_dim_calibration(&str[n - 1].dimcalibration);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "dimid")) != nullptr) {            // Target Dimension
-                if (strlen((char*) att) > 0) str[n - 1].dimid = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"dimid")) != nullptr) {            // Target Dimension
+                if (strlen((char*)att) > 0) str[n - 1].dimid = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "To Dimension  : %d\n", str[n - 1].dimid);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "invert")) != nullptr) {
+            if ((att = xmlGetProp(cur, (xmlChar*)"invert")) != nullptr) {
                 if (att[0] == 'y' || att[0] == 'Y') str[n - 1].dimcalibration.invert = 1;
                 UDA_LOG(UDA_LOG_DEBUG, "Calibration Invert: %d\n", str[n - 1].dimcalibration.invert);
                 xmlFree(att);
@@ -925,9 +949,9 @@ void parseDimCalibration(xmlDocPtr doc, xmlNodePtr cur, CALIBRATION* cal)
 
             // Child Tags
 
-            parseTargetString(doc, cur, "units", str[n - 1].dimcalibration.units);
-            parseTargetValue(doc, cur, "factor", &str[n - 1].dimcalibration.factor);
-            parseTargetValue(doc, cur, "offset", &str[n - 1].dimcalibration.offset);
+            parse_target_string(doc, cur, "units", str[n - 1].dimcalibration.units);
+            parse_target_value(doc, cur, "factor", &str[n - 1].dimcalibration.factor);
+            parse_target_value(doc, cur, "offset", &str[n - 1].dimcalibration.offset);
 
             UDA_LOG(UDA_LOG_DEBUG, "Dimension Units               : %s\n", str[n - 1].dimcalibration.units);
             UDA_LOG(UDA_LOG_DEBUG, "Dimension Calibration Factor  : %f\n", str[n - 1].dimcalibration.factor);
@@ -939,7 +963,7 @@ void parseDimCalibration(xmlDocPtr doc, xmlNodePtr cur, CALIBRATION* cal)
     cal->dimensions = str;    // Array of Composite Signal Actions on Dimensions
 }
 
-void parseCalibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
+void parse_calibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 {
     xmlChar* att;    // General Input of tag attribute values
 
@@ -948,54 +972,54 @@ void parseCalibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseCalibration: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "calibration"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseCalibration: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"calibration"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = CALIBRATIONTYPE;
-            initCalibration(&str[n - 1].calibration);
+            init_calibration(&str[n - 1].calibration);
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range Start: %d\n", str[n - 1].exp_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "exp_number_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].exp_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"exp_number_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].exp_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Exp Number Range End : %d\n", str[n - 1].exp_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_start")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[0] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_start")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[0] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range Start: %d\n", str[n - 1].pass_range[0]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "pass_end")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].pass_range[1] = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"pass_end")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].pass_range[1] = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Pass Number Range End  : %d\n", str[n - 1].pass_range[1]);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "target")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(str[n - 1].calibration.target, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"target")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(str[n - 1].calibration.target, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Calibration Target: %s\n", str[n - 1].calibration.target);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "invert")) != nullptr) {
+            if ((att = xmlGetProp(cur, (xmlChar*)"invert")) != nullptr) {
                 if (att[0] == 'y' || att[0] == 'Y') str[n - 1].calibration.invert = 1;
                 UDA_LOG(UDA_LOG_DEBUG, "Calibration Invert: %d\n", str[n - 1].calibration.invert);
                 xmlFree(att);
@@ -1003,9 +1027,9 @@ void parseCalibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
             // Child Tags
 
-            parseTargetString(doc, cur, "units", str[n - 1].calibration.units);
-            parseTargetValue(doc, cur, "factor", &str[n - 1].calibration.factor);
-            parseTargetValue(doc, cur, "offset", &str[n - 1].calibration.offset);
+            parse_target_string(doc, cur, "units", str[n - 1].calibration.units);
+            parse_target_value(doc, cur, "factor", &str[n - 1].calibration.factor);
+            parse_target_value(doc, cur, "offset", &str[n - 1].calibration.offset);
 
             UDA_LOG(UDA_LOG_DEBUG, "Data Units               : %s\n", str[n - 1].calibration.units);
             UDA_LOG(UDA_LOG_DEBUG, "Data Calibration Factor  : %f\n", str[n - 1].calibration.factor);
@@ -1021,7 +1045,7 @@ void parseCalibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 }
 
 
-void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
+void parse_subset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 {
     xmlChar* att;    // General Input of tag attribute values
 
@@ -1032,10 +1056,10 @@ void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
-        UDA_LOG(UDA_LOG_DEBUG, "parseSubset: %s\n", (char*) cur->name);
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "subset"))) {
+        UDA_LOG(UDA_LOG_DEBUG, "parseSubset: %s\n", (char*)cur->name);
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"subset"))) {
             n++;
-            str = (ACTION*) realloc((void*) str, n * sizeof(ACTION));
+            str = (ACTION*)realloc((void*)str, n * sizeof(ACTION));
 
             initAction(&str[n - 1]);
             str[n - 1].actionType = SUBSETTYPE;
@@ -1044,14 +1068,14 @@ void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "id")) != nullptr) {
-                if (strlen((char*) att) > 0) str[n - 1].actionId = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"id")) != nullptr) {
+                if (strlen((char*)att) > 0) str[n - 1].actionId = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Action ID: %d\n", str[n - 1].actionId);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "data")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(sub->data_signal, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"data")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(sub->data_signal, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Data Signal  : %s\n", sub->data_signal);
                 xmlFree(att);
             }
@@ -1060,47 +1084,47 @@ void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
 
             // Attributes
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "reform")) != nullptr) {
+            if ((att = xmlGetProp(cur, (xmlChar*)"reform")) != nullptr) {
                 if (att[0] == 'Y' || att[0] == 'y') sub->reform = 1;
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "member")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(sub->member, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"member")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(sub->member, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset Member: %s\n", sub->member);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "function")) != nullptr) {
-                if (strlen((char*) att) > 0) strcpy(sub->function, (char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"function")) != nullptr) {
+                if (strlen((char*)att) > 0) strcpy(sub->function, (char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset function: %s\n", sub->function);
                 xmlFree(att);
             }
 
-            if ((att = xmlGetProp(cur, (xmlChar*) "order")) != nullptr) {
-                if (strlen((char*) att) > 0) sub->order = atoi((char*) att);
+            if ((att = xmlGetProp(cur, (xmlChar*)"order")) != nullptr) {
+                if (strlen((char*)att) > 0) sub->order = atoi((char*)att);
                 UDA_LOG(UDA_LOG_DEBUG, "Subset order: %d\n", sub->order);
                 xmlFree(att);
             }
 
             // Fixed Length Attribute Arrays
 
-            parseFixedLengthStrArray(cur, "operation", &sub->operation[0], &sub->nbound);
+            parse_fixed_length_str_array(cur, "operation", &sub->operation[0], &sub->nbound);
             for (int i = 0; i < sub->nbound; i++)
                 sub->dimid[i] = i;                    // Ordering is as DATA[4][3][2][1][0]
 
-            parseFixedLengthArray(cur, "bound", (void*) sub->bound, UDA_TYPE_DOUBLE, &n0);
-            parseFixedLengthArray(cur, "dimid", (void*) sub->dimid, UDA_TYPE_INT, &n1);
+            parse_fixed_length_array(cur, "bound", (void*)sub->bound, UDA_TYPE_DOUBLE, &n0);
+            parse_fixed_length_array(cur, "dimid", (void*)sub->dimid, UDA_TYPE_INT, &n1);
 
-            if (idamParseOperation(sub) != 0) return;
+            if (parseOperation(sub) != 0) return;
 
             for (int i = 0; i < sub->nbound; i++) {
                 UDA_LOG(UDA_LOG_DEBUG, "Dimension ID               : %d\n", sub->dimid[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Bounding Values : %e\n", sub->bound[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Operation       : %s\n", sub->operation[i]);
                 UDA_LOG(UDA_LOG_DEBUG, "Subsetting Is Index?       : %d\n", sub->isindex[i]);
-                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Lower Index     : %d\n", (int) sub->lbindex[i]);
-                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Upper Index     : %d\n", (int) sub->ubindex[i]);
+                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Lower Index     : %d\n", (int)sub->lbindex[i]);
+                UDA_LOG(UDA_LOG_DEBUG, "Subsetting Upper Index     : %d\n", (int)sub->ubindex[i]);
             }
         }
         cur = cur->next;
@@ -1110,10 +1134,6 @@ void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
     actions->action = str;    // Array of Actions bounded by a Ranges
 }
 
-void parseMap(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions)
-{
-}
-
 int parseDoc(char* docname, ACTIONS* actions)
 {
     xmlDocPtr doc;
@@ -1128,7 +1148,7 @@ int parseDoc(char* docname, ACTIONS* actions)
 
     xmlInitParser();
 
-    if ((doc = xmlParseDoc((xmlChar*) docname)) == nullptr) {
+    if ((doc = xmlParseDoc((xmlChar*)docname)) == nullptr) {
         xmlFreeDoc(doc);
         xmlCleanupParser();
         addIdamError(CODEERRORTYPE, "parseDoc", 1, "XML Not Parsed");
@@ -1142,7 +1162,7 @@ int parseDoc(char* docname, ACTIONS* actions)
         return 1;
     }
 
-    if (xmlStrcmp(cur->name, (const xmlChar*) "action")) {        //If No Action Tag then Nothing to be done!
+    if (xmlStrcmp(cur->name, (const xmlChar*)"action")) {        //If No Action Tag then Nothing to be done!
         xmlFreeDoc(doc);
         xmlCleanupParser();
         return 1;
@@ -1151,15 +1171,15 @@ int parseDoc(char* docname, ACTIONS* actions)
     cur = cur->xmlChildrenNode;
     while (cur != nullptr) {
 
-        if ((!xmlStrcmp(cur->name, (const xmlChar*) "signal"))) {
+        if ((!xmlStrcmp(cur->name, (const xmlChar*)"signal"))) {
 
             parseComposite(doc, cur, actions);        // Composite can have SUBSET as a child
-            parseDocumentation(doc, cur, actions);
-            parseCalibration(doc, cur, actions);
-            parseTimeOffset(doc, cur, actions);
-            parseErrorModel(doc, cur, actions);
+            parse_documentation(doc, cur, actions);
+            parse_calibration(doc, cur, actions);
+            parse_time_offset(doc, cur, actions);
+            parse_error_model(doc, cur, actions);
 
-            parseSubset(doc, cur, actions);        // Single Subset
+            parse_subset(doc, cur, actions);        // Single Subset
         }
         cur = cur->next;
     }
@@ -1177,7 +1197,7 @@ int parseDoc(char* docname, ACTIONS* actions)
 
 //==================================================================================================
 
-void printDimensions(int ndim, DIMENSION* dims)
+void print_dimensions(int ndim, DIMENSION* dims)
 {
     UDA_LOG(UDA_LOG_DEBUG, "No. Dimensions     : %d\n", ndim);
     for (int i = 0; i < ndim; i++) {
@@ -1241,7 +1261,7 @@ void printAction(ACTION action)
             UDA_LOG(UDA_LOG_DEBUG, "Description: %s\n", action.documentation.description);
             UDA_LOG(UDA_LOG_DEBUG, "Data Label : %s\n", action.documentation.label);
             UDA_LOG(UDA_LOG_DEBUG, "Data Units : %s\n", action.documentation.units);
-            printDimensions(action.documentation.ndimensions, action.documentation.dimensions);
+            print_dimensions(action.documentation.ndimensions, action.documentation.dimensions);
             break;
         case CALIBRATIONTYPE:
             UDA_LOG(UDA_LOG_DEBUG, "CALIBRATION xml\n");
@@ -1250,7 +1270,7 @@ void printAction(ACTION action)
             UDA_LOG(UDA_LOG_DEBUG, "Offset     : %f\n", action.calibration.offset);
             UDA_LOG(UDA_LOG_DEBUG, "Invert     : %d\n", action.calibration.invert);
             UDA_LOG(UDA_LOG_DEBUG, "Data Units : %s\n", action.calibration.units);
-            printDimensions(action.calibration.ndimensions, action.calibration.dimensions);
+            print_dimensions(action.calibration.ndimensions, action.calibration.dimensions);
             break;
         case COMPOSITETYPE:
             UDA_LOG(UDA_LOG_DEBUG, "COMPOSITE xml\n");
@@ -1261,7 +1281,7 @@ void printAction(ACTION action)
             UDA_LOG(UDA_LOG_DEBUG, "Composite Source File    : %s\n", action.composite.file);
             UDA_LOG(UDA_LOG_DEBUG, "Composite Source Format  : %s\n", action.composite.format);
             UDA_LOG(UDA_LOG_DEBUG, "Composite Time Dimension : %d\n", action.composite.order);
-            printDimensions(action.composite.ndimensions, action.composite.dimensions);
+            print_dimensions(action.composite.ndimensions, action.composite.dimensions);
             break;
         case ERRORMODELTYPE:
             UDA_LOG(UDA_LOG_DEBUG, "ERRORMODEL xml\n");
@@ -1269,7 +1289,7 @@ void printAction(ACTION action)
             UDA_LOG(UDA_LOG_DEBUG, "Number of Model Parameters: %d\n", action.errormodel.param_n);
             for (int i = 0; i < action.errormodel.param_n; i++)
                 UDA_LOG(UDA_LOG_DEBUG, "Parameters[%d] = %.12f\n", i, action.errormodel.params[i]);
-            printDimensions(action.errormodel.ndimensions, action.errormodel.dimensions);
+            print_dimensions(action.errormodel.ndimensions, action.errormodel.dimensions);
             break;
 
         case SERVERSIDETYPE:
@@ -1281,7 +1301,8 @@ void printAction(ACTION action)
                 UDA_LOG(UDA_LOG_DEBUG, "Member                         : %s\n", action.serverside.subsets[i].member);
                 UDA_LOG(UDA_LOG_DEBUG, "Function                       : %s\n", action.serverside.subsets[i].function);
                 UDA_LOG(UDA_LOG_DEBUG, "Order                          : %d\n", action.serverside.subsets[i].order);
-                UDA_LOG(UDA_LOG_DEBUG, "Signal                         : %s\n", action.serverside.subsets[i].data_signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal                         : %s\n",
+                        action.serverside.subsets[i].data_signal);
                 for (int j = 0; j < action.serverside.subsets[i].nbound; j++) {
                     UDA_LOG(UDA_LOG_DEBUG, "Bounding Value: %e\n", action.serverside.subsets[i].bound[j]);
                     UDA_LOG(UDA_LOG_DEBUG, "Operation     : %s\n", action.serverside.subsets[i].operation[j]);
@@ -1323,15 +1344,15 @@ void printActions(ACTIONS actions)
 
 // Initialise an Action Structure and Child Structures
 
-void initDimCalibration(DIMCALIBRATION* act)
+void init_dim_calibration(DIMCALIBRATION* act)
 {
-    act->factor = (double) 1.0E0;    // Data Calibration Correction/Scaling factor
-    act->offset = (double) 0.0E0;    // Data Calibration Correction/Scaling offset
+    act->factor = (double)1.0E0;    // Data Calibration Correction/Scaling factor
+    act->offset = (double)0.0E0;    // Data Calibration Correction/Scaling offset
     act->invert = 0;            // Don't Invert the data
     act->units[0] = '\0';
 }
 
-void initDimComposite(DIMCOMPOSITE* act)
+void init_dim_composite(DIMCOMPOSITE* act)
 {
     act->to_dim = -1;                // Swap to Dimension ID
     act->from_dim = -1;                // Swap from Dimension ID
@@ -1342,13 +1363,13 @@ void initDimComposite(DIMCOMPOSITE* act)
     act->dim_aserror[0] = '\0';            // Asymmetric Error Source Signal
 }
 
-void initDimDocumentation(DIMDOCUMENTATION* act)
+void init_dim_documentation(DIMDOCUMENTATION* act)
 {
     act->label[0] = '\0';
     act->units[0] = '\0';            // Lower in priority than Calibration Units
 }
 
-void initDimErrorModel(DIMERRORMODEL* act)
+void init_dim_error_model(DIMERRORMODEL* act)
 {
     act->model = ERROR_MODEL_UNKNOWN;    // No Error Model
     act->param_n = 0;            // No. Model parameters
@@ -1357,23 +1378,23 @@ void initDimErrorModel(DIMERRORMODEL* act)
     }
 }
 
-void initDimension(DIMENSION* act)
+void init_dimension(DIMENSION* act)
 {
     act->dimid = -1;        // Dimension Id
     act->dimType = 0;        // Structure Type
 }
 
-void initTimeOffset(TIMEOFFSET* act)
+void init_time_offset(TIMEOFFSET* act)
 {
     act->method = 0;            // Correction Method: Standard offset correction only
-    act->offset = (double) 0.0E0;    // Time Dimension offset correction or start time
-    act->interval = (double) 0.0E0;    // Time Dimension Interval correction
+    act->offset = (double)0.0E0;    // Time Dimension offset correction or start time
+    act->interval = (double)0.0E0;    // Time Dimension Interval correction
 }
 
-void initCalibration(CALIBRATION* act)
+void init_calibration(CALIBRATION* act)
 {
-    act->factor = (double) 1.0E0;    // Data Calibration Correction/Scaling factor
-    act->offset = (double) 0.0E0;    // Data Calibration Correction/Scaling offset
+    act->factor = (double)1.0E0;    // Data Calibration Correction/Scaling factor
+    act->offset = (double)0.0E0;    // Data Calibration Correction/Scaling offset
     act->units[0] = '\0';
     act->target[0] = '\0';        // Which data Component to apply calibration? (all, data, error, aserror)
     act->invert = 0;        // No Inversion
@@ -1381,7 +1402,7 @@ void initCalibration(CALIBRATION* act)
     act->dimensions = nullptr;
 }
 
-void initDocumentation(DOCUMENTATION* act)
+void init_documentation(DOCUMENTATION* act)
 {
     act->label[0] = '\0';
     act->units[0] = '\0';        // Lower in priority than Calibration Units
@@ -1390,7 +1411,7 @@ void initDocumentation(DOCUMENTATION* act)
     act->dimensions = nullptr;
 }
 
-void initComposite(COMPOSITE* act)
+void init_composite(COMPOSITE* act)
 {
     act->data_signal[0] = '\0';            // Derived Data using this Data Source
     act->error_signal[0] = '\0';            // Use Errors from this Source
@@ -1415,7 +1436,7 @@ void initServerside(SERVERSIDE* act)
     act->maps = nullptr;
 }
 
-void initErrorModel(ERRORMODEL* act)
+void init_error_model(ERRORMODEL* act)
 {
     act->model = ERROR_MODEL_UNKNOWN;    // No Error Model
     act->param_n = 0;            // No. Model parameters
@@ -1442,17 +1463,6 @@ void initSubset(SUBSET* act)
     act->order = -1;                // Explicitly set the order of the time dimension if >= 0
 }
 
-void initMap(MAP* act)
-{
-    for (int i = 0; i < MAXDATARANK; i++) {
-        act->value[i] = 0.0;
-        act->dimid[i] = -1;                // Dimension IDs
-        act->mapping[i][0] = '\0';            // Mapping Operations
-    }
-    act->data_signal[0] = '\0';                // Data
-    act->nmap = 0;                // The number of Mapping Operations
-}
-
 // Initialise an Action Structure
 
 void initAction(ACTION* act)
@@ -1490,18 +1500,18 @@ void freeActions(ACTIONS* actions)
         switch (actions->action[i].actionType) {
 
             case COMPOSITETYPE:
-                if ((cptr = (void*) actions->action[i].composite.dimensions) != nullptr) {
+                if ((cptr = (void*)actions->action[i].composite.dimensions) != nullptr) {
                     free(cptr);
                     actions->action[i].composite.dimensions = nullptr;
                     actions->action[i].composite.ndimensions = 0;
                 }
                 if (actions->action[i].composite.nsubsets > 0) {
-                    if ((cptr = (void*) actions->action[i].composite.subsets) != nullptr) free(cptr);
+                    if ((cptr = (void*)actions->action[i].composite.subsets) != nullptr) free(cptr);
                     actions->action[i].composite.subsets = nullptr;
                     actions->action[i].composite.nsubsets = 0;
                 }
                 if (actions->action[i].composite.nmaps > 0) {
-                    if ((cptr = (void*) actions->action[i].composite.maps) != nullptr) free(cptr);
+                    if ((cptr = (void*)actions->action[i].composite.maps) != nullptr) free(cptr);
                     actions->action[i].composite.maps = nullptr;
                     actions->action[i].composite.nmaps = 0;
                 }
@@ -1511,7 +1521,7 @@ void freeActions(ACTIONS* actions)
                 actions->action[i].errormodel.param_n = 0;
 
                 for (int j = 0; j < actions->action[i].errormodel.ndimensions; j++)
-                    if ((cptr = (void*) actions->action[i].errormodel.dimensions) != nullptr) {
+                    if ((cptr = (void*)actions->action[i].errormodel.dimensions) != nullptr) {
                         free(cptr);
                         actions->action[i].errormodel.dimensions = nullptr;
                         actions->action[i].errormodel.ndimensions = 0;
@@ -1520,7 +1530,7 @@ void freeActions(ACTIONS* actions)
                 break;
 
             case CALIBRATIONTYPE:
-                if ((cptr = (void*) actions->action[i].calibration.dimensions) != nullptr) {
+                if ((cptr = (void*)actions->action[i].calibration.dimensions) != nullptr) {
                     free(cptr);
                     actions->action[i].calibration.dimensions = nullptr;
                     actions->action[i].calibration.ndimensions = 0;
@@ -1528,7 +1538,7 @@ void freeActions(ACTIONS* actions)
                 break;
 
             case DOCUMENTATIONTYPE:
-                if ((cptr = (void*) actions->action[i].documentation.dimensions) != nullptr) {
+                if ((cptr = (void*)actions->action[i].documentation.dimensions) != nullptr) {
                     free(cptr);
                     actions->action[i].documentation.dimensions = nullptr;
                     actions->action[i].documentation.ndimensions = 0;
@@ -1537,12 +1547,12 @@ void freeActions(ACTIONS* actions)
 
             case SERVERSIDETYPE:
                 if (actions->action[i].serverside.nsubsets > 0) {
-                    if ((cptr = (void*) actions->action[i].serverside.subsets) != nullptr) free(cptr);
+                    if ((cptr = (void*)actions->action[i].serverside.subsets) != nullptr) free(cptr);
                     actions->action[i].serverside.subsets = nullptr;
                     actions->action[i].serverside.nsubsets = 0;
                 }
                 if (actions->action[i].serverside.nmaps > 0) {
-                    if ((cptr = (void*) actions->action[i].serverside.maps) != nullptr) free(cptr);
+                    if ((cptr = (void*)actions->action[i].serverside.maps) != nullptr) free(cptr);
                     actions->action[i].serverside.maps = nullptr;
                     actions->action[i].serverside.nmaps = 0;
                 }
@@ -1553,7 +1563,7 @@ void freeActions(ACTIONS* actions)
         }
     }
 
-    if ((cptr = (void*) actions->action) != nullptr) free(cptr);
+    if ((cptr = (void*)actions->action) != nullptr) free(cptr);
     actions->nactions = 0;
     actions->action = nullptr;
 
diff --git a/source/clientserver/parseXML.h b/source/clientserver/parseXML.h
index b8defb5a..d09de358 100755
--- a/source/clientserver/parseXML.h
+++ b/source/clientserver/parseXML.h
@@ -5,12 +5,7 @@
 #include <libxml/parser.h>
 
 #include "udaDefines.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -180,80 +175,16 @@ typedef struct Actions {
     ACTION* action;                         // Array of Actions
 } ACTIONS;
 
-LIBRARY_API double deScale(char* scale);
-
-LIBRARY_API void parseTargetValue(xmlDocPtr doc, xmlNodePtr cur, const char* target, double* value);
-
-LIBRARY_API void parseTargetString(xmlDocPtr doc, xmlNodePtr cur, const char* target, char* str);
-
-LIBRARY_API void parseDimension(xmlDocPtr doc, xmlNodePtr cur, ACTION* action);
-
-LIBRARY_API void parseSwapDim(xmlDocPtr doc, xmlNodePtr cur, ACTION* action);
-
-LIBRARY_API void parseSwap(xmlDocPtr doc, xmlNodePtr cur, ACTION* action);
-
-LIBRARY_API void parseActionRange(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseFixedLengthArray(xmlNodePtr cur, const char* target, void* array, int arraytype, int* n);
-
-LIBRARY_API void parseFixedLengthStrArray(xmlNodePtr cur, const char* target, char array[MAXDATARANK][SXMLMAXSTRING], int* n);
-
 LIBRARY_API int parseDoc(char* docname, ACTIONS* actions);
-
-//void parseComposite(xmlDocPtr doc, xmlNodePtr cur, ACTIONS * actions);
-
-LIBRARY_API void parseDocumentation(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseCalibration(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseTimeOffset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseErrorModel(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseSubset(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
-LIBRARY_API void parseMap(xmlDocPtr doc, xmlNodePtr cur, ACTIONS* actions);
-
 LIBRARY_API void printAction(ACTION action);
-
 LIBRARY_API void printActions(ACTIONS actions);
-
 LIBRARY_API void initAction(ACTION* act);
-
 LIBRARY_API void initActions(ACTIONS* act);
-
 LIBRARY_API void freeActions(ACTIONS* actions);
-
 LIBRARY_API void copyActions(ACTIONS* actions_out, ACTIONS* actions_in);
-
-LIBRARY_API void printDimensions(int ndim, DIMENSION* dims);
-
-LIBRARY_API void initDimCalibration(DIMCALIBRATION* act);
-
-LIBRARY_API void initDimComposite(DIMCOMPOSITE* act);
-
-LIBRARY_API void initDimDocumentation(DIMDOCUMENTATION* act);
-
-LIBRARY_API void initDimErrorModel(DIMERRORMODEL* act);
-
-LIBRARY_API void initDimension(DIMENSION* act);
-
-LIBRARY_API void initTimeOffset(TIMEOFFSET* act);
-
-LIBRARY_API void initCalibration(CALIBRATION* act);
-
-LIBRARY_API void initDocumentation(DOCUMENTATION* act);
-
-LIBRARY_API void initComposite(COMPOSITE* act);
-
 LIBRARY_API void initServerside(SERVERSIDE* act);
-
-LIBRARY_API void initErrorModel(ERRORMODEL* act);
-
 LIBRARY_API void initSubset(SUBSET* act);
 
-LIBRARY_API void initMap(MAP* act);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/source/clientserver/printStructs.h b/source/clientserver/printStructs.h
index c6698ba5..4ee864b2 100755
--- a/source/clientserver/printStructs.h
+++ b/source/clientserver/printStructs.h
@@ -2,33 +2,20 @@
 #define UDA_CLIENTSERVER_PRINTSTRUCTS_H
 
 #include "udaStructs.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 LIBRARY_API void printRequestBlock(REQUEST_BLOCK str);
-
 LIBRARY_API void printClientBlock(CLIENT_BLOCK str);
-
 LIBRARY_API void printServerBlock(SERVER_BLOCK str);
-
 LIBRARY_API void printDataBlock(DATA_BLOCK str);
-
 LIBRARY_API void printSystemConfig(SYSTEM_CONFIG str);
-
 LIBRARY_API void printDataSystem(DATA_SYSTEM str);
-
 LIBRARY_API void printDataSource(DATA_SOURCE str);
-
 LIBRARY_API void printSignal(SIGNAL str);
-
 LIBRARY_API void printSignalDesc(SIGNAL_DESC str);
 
 #ifdef __cplusplus
diff --git a/source/clientserver/protocol.cpp b/source/clientserver/protocol.cpp
index 1b259a99..3fd661e2 100755
--- a/source/clientserver/protocol.cpp
+++ b/source/clientserver/protocol.cpp
@@ -767,8 +767,8 @@ int protocol(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOCLIS
 
                     if (server_block->idamerrorstack.nerrors > 0) {    // No Data to Receive?
 
-                        server_block->idamerrorstack.idamerror = (IDAMERROR*) malloc(
-                                server_block->idamerrorstack.nerrors * sizeof(IDAMERROR));
+                        server_block->idamerrorstack.idamerror = (UDA_ERROR*) malloc(
+                                server_block->idamerrorstack.nerrors * sizeof(UDA_ERROR));
                         initErrorRecords(&server_block->idamerrorstack);
 
                         if (!xdr_server2(xdrs, server_block)) {
diff --git a/source/clientserver/protocol.h b/source/clientserver/protocol.h
index 55de907f..29533155 100755
--- a/source/clientserver/protocol.h
+++ b/source/clientserver/protocol.h
@@ -4,12 +4,7 @@
 #include <rpc/types.h>
 #include <rpc/xdr.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -62,33 +57,6 @@ extern "C" {
 //---------------------------------------------------------------------------------------------------
 // Client Server XDR data Streams (DON'T CHANGE ORDER or Legacy client won't work!)
 
-enum REQUEST {
-    REQUEST_SHUTDOWN = 1,
-    REQUEST_READ_GENERIC,       // Generic Signal via the IDAM Database
-    REQUEST_READ_IDA,           // an IDA File
-    REQUEST_READ_MDS,           // an MDSPlus Server
-    REQUEST_READ_IDAM,          // a Remote IDAM server
-    REQUEST_READ_FORMAT,        // Server to Choose Plugin for Requested Format
-    REQUEST_READ_CDF,           // netCDF File
-    REQUEST_READ_HDF5,          // HDF5 FIle
-    REQUEST_READ_XML,           // XML Document defining a Signal
-    REQUEST_READ_UFILE,         // TRANSP UFile
-    REQUEST_READ_FILE,          // Read a File: A Container of Bytes!
-    REQUEST_READ_SQL,           // Read from an SQL Data Source
-    REQUEST_READ_PPF,           // JET PPF
-    REQUEST_READ_JPF,           // JET JPF
-    REQUEST_READ_NEW_PLUGIN,
-    REQUEST_READ_NOTHING,       // Immediate Return without Error: Client Server Timing Tests
-    REQUEST_READ_BLOCKED,       // Disable Server Option for External Users (Not a client side option)
-    REQUEST_READ_HDATA,         // Hierarchical Data Structures
-    REQUEST_READ_SERVERSIDE,    // Server Side Functions
-    REQUEST_READ_UNKNOWN,       // Plugin Not Known
-    REQUEST_READ_WEB,           // a Remote or Local web server
-    REQUEST_READ_BIN,           // Binary file
-    REQUEST_READ_HELP,          // Help file
-    REQUEST_READ_DEVICE         // Request to an External Device's data server
-};
-
 LIBRARY_API int protocol(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOCLIST* logmalloclist,
              USERDEFINEDTYPELIST* userdefinedtypelist, void* str, int protocolVersion);
 LIBRARY_API int protocol2(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOCLIST* logmalloclist,
diff --git a/source/clientserver/protocol2.cpp b/source/clientserver/protocol2.cpp
index 3706f746..79768a2b 100755
--- a/source/clientserver/protocol2.cpp
+++ b/source/clientserver/protocol2.cpp
@@ -289,8 +289,8 @@ static int handle_server_block(XDR* xdrs, int direction, const void* str, int pr
 
             if (server_block->idamerrorstack.nerrors > 0) {    // No Data to Receive?
 
-                server_block->idamerrorstack.idamerror = (IDAMERROR*)malloc(
-                        server_block->idamerrorstack.nerrors * sizeof(IDAMERROR));
+                server_block->idamerrorstack.idamerror = (UDA_ERROR*)malloc(
+                        server_block->idamerrorstack.nerrors * sizeof(UDA_ERROR));
                 initErrorRecords(&server_block->idamerrorstack);
 
                 if (!xdr_server2(xdrs, server_block)) {
diff --git a/source/clientserver/protocolXML.cpp b/source/clientserver/protocolXML.cpp
index b6db5e9f..f9b0a448 100755
--- a/source/clientserver/protocolXML.cpp
+++ b/source/clientserver/protocolXML.cpp
@@ -273,7 +273,7 @@ int protocolXML(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOC
                         CreateXDRStream();
                         xdrs = serverOutput;
 #  else
-                        idamCreateXDRStream();
+                        createXDRStream();
                         xdrs = clientOutput;
 #  endif
                         XDRstdioFlag = 0;
@@ -471,7 +471,7 @@ int protocolXML(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOC
                             CreateXDRStream();
                             xdrs = serverInput;
 #  else
-                            idamCreateXDRStream();
+                            createXDRStream();
                             xdrs = clientInput;
 #  endif
                             XDRstdioFlag = 0;
@@ -619,7 +619,7 @@ int protocolXML(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOC
                             CreateXDRStream();
                             xdrs = serverInput;
 #  else
-                            idamCreateXDRStream();
+                            createXDRStream();
                             xdrs = clientInput;
 #  endif
                             XDRstdioFlag = 0;
diff --git a/source/clientserver/protocolXML.h b/source/clientserver/protocolXML.h
index c004fb59..f4b380d6 100755
--- a/source/clientserver/protocolXML.h
+++ b/source/clientserver/protocolXML.h
@@ -4,12 +4,7 @@
 #include <stdio.h> // this must be included before rpc.h
 #include <rpc/rpc.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/protocolXML2.cpp b/source/clientserver/protocolXML2.cpp
index f3302e5f..2e462d9c 100755
--- a/source/clientserver/protocolXML2.cpp
+++ b/source/clientserver/protocolXML2.cpp
@@ -425,7 +425,7 @@ protocolXML2(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOCLIS
 
 // Free data object
 
-                        if (object != nullptr) free((void*)object);
+                        if (object != nullptr) free(object);
                         object = nullptr;
                         objectSize = 0;
 
@@ -748,7 +748,7 @@ protocolXML2(XDR* xdrs, int protocol_id, int direction, int* token, LOGMALLOCLIS
 
                             // Free the object
 
-                            if (object != nullptr) free((void*)object);
+                            if (object != nullptr) free(object);
                             object = nullptr;
                             objectSize = 0;
                         }
diff --git a/source/clientserver/protocolXML2.h b/source/clientserver/protocolXML2.h
index 083edd16..78322b90 100755
--- a/source/clientserver/protocolXML2.h
+++ b/source/clientserver/protocolXML2.h
@@ -4,12 +4,7 @@
 #include <stdio.h>
 #include <rpc/rpc.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/protocolXML2Put.h b/source/clientserver/protocolXML2Put.h
index f9c6035e..9f3f4b2e 100755
--- a/source/clientserver/protocolXML2Put.h
+++ b/source/clientserver/protocolXML2Put.h
@@ -5,12 +5,7 @@
 #include <rpc/rpc.h>
 
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/readXDRFile.cpp b/source/clientserver/readXDRFile.cpp
index 3ca710a0..55094876 100755
--- a/source/clientserver/readXDRFile.cpp
+++ b/source/clientserver/readXDRFile.cpp
@@ -113,7 +113,7 @@ int sendXDRFile(XDR* xdrs, char* xdrfile)
     // Housekeeping
 
     fclose(fh);        // Close the File
-    free((void*)bp);
+    free(bp);
 
     return err;
 }
@@ -218,7 +218,7 @@ int receiveXDRFile(XDR* xdrs, char* xdrfile)
     // Housekeeping
 
     fclose(fh);        // Close the File
-    free((void*)bp);
+    free(bp);
 
     return err;
 }
diff --git a/source/clientserver/readXDRFile.h b/source/clientserver/readXDRFile.h
index 6ecd3956..04fe79f1 100755
--- a/source/clientserver/readXDRFile.h
+++ b/source/clientserver/readXDRFile.h
@@ -3,15 +3,10 @@
 
 #include <rpc/types.h>
 #include <rpc/xdr.h>
+#include "export.h"
 
 #define MAXDOLOOPLIMIT 500			// ~50MB file
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/clientserver/socketStructs.h b/source/clientserver/socketStructs.h
index 12e4167a..8e522f04 100755
--- a/source/clientserver/socketStructs.h
+++ b/source/clientserver/socketStructs.h
@@ -5,12 +5,7 @@
 
 #include <time.h>
 #include <rpc/rpc.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/stringUtils.cpp b/source/clientserver/stringUtils.cpp
index ed4f96bb..0e0af506 100755
--- a/source/clientserver/stringUtils.cpp
+++ b/source/clientserver/stringUtils.cpp
@@ -1,8 +1,8 @@
 #include "stringUtils.h"
 
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
+#include <cstdlib>
+#include <cstdarg>
+#include <cstdio>
 
 #ifdef __GNUC__
 #  include <strings.h>
diff --git a/source/clientserver/stringUtils.h b/source/clientserver/stringUtils.h
index abf2fabc..8a69451e 100755
--- a/source/clientserver/stringUtils.h
+++ b/source/clientserver/stringUtils.h
@@ -4,17 +4,12 @@
 #include <string.h>
 #include <ctype.h>
 #include <stdbool.h>
+#include "export.h"
 
 #ifndef _WIN32
 #  include <strings.h>
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/clientserver/udaDefines.h b/source/clientserver/udaDefines.h
index 327cf2cb..42073da4 100755
--- a/source/clientserver/udaDefines.h
+++ b/source/clientserver/udaDefines.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENTSERVER_IDAMDEFINES_H
 #define UDA_CLIENTSERVER_IDAMDEFINES_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -85,16 +81,15 @@ extern unsigned int privateFlags;
 //--------------------------------------------------------
 // Client Flags: Client specified local properties (32 bits)
 
-#define CLIENTFLAG_FULLRESET -1    // ffff        Reset flags
-#define CLIENTFLAG_ALTDATA    1u    // 0001
-#define CLIENTFLAG_XDRFILE    2u    // 0010        Use an intermediate file with the XDR data rather than a data stream
-#define CLIENTFLAG_CACHE      4u    // 0100        Access data from the local cache and write new data to cache
-#define CLIENTFLAG_CLOSEDOWN  8u    // 1000        Immediate Closedown
-
-#define CLIENTFLAG_XDROBJECT    16u  // 10000        Use a XDR object in memory
-
-#define CLIENTFLAG_REUSELASTHANDLE     32u      // 100000       Reuse the last issued handle value (for this thread) - assume application has freed heap
-#define CLIENTFLAG_FREEREUSELASTHANDLE 64u      // 1000000      Free the heap associated with the last issued handle and reuse the handle value
+#define CLIENTFLAG_FULLRESET -1             // ffff     Reset flags
+#define CLIENTFLAG_ALTDATA    1u            // 0000 0001
+#define CLIENTFLAG_XDRFILE    2u            // 0000 0010    Use an intermediate file with the XDR data rather than a data stream
+#define CLIENTFLAG_CACHE      4u            // 0000 0100    Access data from the local cache and write new data to cache
+#define CLIENTFLAG_CLOSEDOWN  8u            // 0000 1000    Immediate Closedown
+#define CLIENTFLAG_XDROBJECT  16u           // 0001 0000    Use a XDR object in memory
+#define CLIENTFLAG_REUSELASTHANDLE     32u  // 0010 0000    Reuse the last issued handle value (for this thread) - assume application has freed heap
+#define CLIENTFLAG_FREEREUSELASTHANDLE 64u  // 0100 0000    Free the heap associated with the last issued handle and reuse the handle value
+#define CLIENTFLAG_FILECACHE 128u           // 1000 0000    Access data from and save data to local cache files
 
 extern unsigned int clientFlags;
 
diff --git a/source/clientserver/udaStructs.h b/source/clientserver/udaStructs.h
index bd17329b..8b283f32 100755
--- a/source/clientserver/udaStructs.h
+++ b/source/clientserver/udaStructs.h
@@ -1,17 +1,12 @@
-#ifndef UDA_CLIENTSERVER_IDAMSTRUCTS_H
-#define UDA_CLIENTSERVER_IDAMSTRUCTS_H
+#ifndef UDA_CLIENTSERVER_UDASTRUCTS_H
+#define UDA_CLIENTSERVER_UDASTRUCTS_H
 
 #ifdef __GNUC__
 #  include <sys/time.h>
 #endif
 
 #include "udaDefines.h"
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -298,24 +293,24 @@ typedef struct PutDataBlockList {
     PUTDATA_BLOCK* putDataBlock;    // Array of data blocks
 } PUTDATA_BLOCK_LIST;
 
-typedef struct IdamError {
+typedef struct UdaError {
     int type;                       // Error Classification
     int code;                       // Error Code
     char location[STRING_LENGTH];   // Where this Error is Located
     char msg[STRING_LENGTH];        // Message
-} IDAMERROR;
+} UDA_ERROR;
 
-typedef struct IdamErrorStack {
+typedef struct UdaErrorStack {
     unsigned int nerrors;           // Number of Errors
-    IDAMERROR* idamerror;           // Array of Errors
-} IDAMERRORSTACK;
+    UDA_ERROR* idamerror;           // Array of Errors
+} UDA_ERROR_STACK;
 
 typedef struct ServerBlock {
     int version;
     int error;
     char msg[STRING_LENGTH];
     int pid;                        // Server Application process id
-    IDAMERRORSTACK idamerrorstack;
+    UDA_ERROR_STACK idamerrorstack;
     char OSName[STRING_LENGTH];     // Name of the Server's Operating System, e.g. OSX
     char DOI[STRING_LENGTH];        // Server version/implementation DOI - to be logged with all data consumers
     SECURITY_BLOCK securityBlock;   // Contains encrypted tokens exchanged between client and server for mutual authentication
@@ -333,6 +328,33 @@ typedef struct NameValueList {
     NAMEVALUE* nameValue;  // List of individual name value pairs in parse order
 } NAMEVALUELIST;
 
+enum REQUEST {
+    REQUEST_SHUTDOWN = 1,
+    REQUEST_READ_GENERIC,       // Generic Signal via the IDAM Database
+    REQUEST_READ_IDA,           // an IDA File
+    REQUEST_READ_MDS,           // an MDSPlus Server
+    REQUEST_READ_IDAM,          // a Remote IDAM server
+    REQUEST_READ_FORMAT,        // Server to Choose Plugin for Requested Format
+    REQUEST_READ_CDF,           // netCDF File
+    REQUEST_READ_HDF5,          // HDF5 FIle
+    REQUEST_READ_XML,           // XML Document defining a Signal
+    REQUEST_READ_UFILE,         // TRANSP UFile
+    REQUEST_READ_FILE,          // Read a File: A Container of Bytes!
+    REQUEST_READ_SQL,           // Read from an SQL Data Source
+    REQUEST_READ_PPF,           // JET PPF
+    REQUEST_READ_JPF,           // JET JPF
+    REQUEST_READ_NEW_PLUGIN,
+    REQUEST_READ_NOTHING,       // Immediate Return without Error: Client Server Timing Tests
+    REQUEST_READ_BLOCKED,       // Disable Server Option for External Users (Not a client side option)
+    REQUEST_READ_HDATA,         // Hierarchical Data Structures
+    REQUEST_READ_SERVERSIDE,    // Server Side Functions
+    REQUEST_READ_UNKNOWN,       // Plugin Not Known
+    REQUEST_READ_WEB,           // a Remote or Local web server
+    REQUEST_READ_BIN,           // Binary file
+    REQUEST_READ_HELP,          // Help file
+    REQUEST_READ_DEVICE         // Request to an External Device's data server
+};
+
 typedef struct RequestBlock {
     int request;                       // Plugin or Shutdown Server
     int exp_number;                    // Pulse No.,Tree No., etc
@@ -395,4 +417,4 @@ typedef struct Environment {
 }
 #endif
 
-#endif // UDA_CLIENTSERVER_IDAMSTRUCTS_H
+#endif // UDA_CLIENTSERVER_UDASTRUCTS_H
diff --git a/source/clientserver/udaTypes.h b/source/clientserver/udaTypes.h
index 0467086d..b5d4d1ad 100755
--- a/source/clientserver/udaTypes.h
+++ b/source/clientserver/udaTypes.h
@@ -7,11 +7,7 @@
 
 #include <stdlib.h>
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/userid.cpp b/source/clientserver/userid.cpp
index 7387df6c..2171fa75 100755
--- a/source/clientserver/userid.cpp
+++ b/source/clientserver/userid.cpp
@@ -9,8 +9,7 @@
 #  include <Windows.h>
 #endif
 
-#include <stdlib.h>
-#include <stdio.h>
+#include <cstdlib>
 
 #include "stringUtils.h"
 #include "udaDefines.h"
@@ -30,13 +29,9 @@ void userid(char* uid)
         return;
     } else
 #  endif
-    if ((user = getlogin()) != nullptr) {
-        copyString(user, uid, STRING_LENGTH);
-        return;
-    } else if ((user = getenv("USER")) != nullptr) {
-        copyString(user, uid, STRING_LENGTH);
-        return;
-    } else if ((user = getenv("LOGNAME")) != nullptr) {
+    if ((user = getlogin()) != nullptr
+            || (user = getenv("USER")) != nullptr
+            || (user = getenv("LOGNAME")) != nullptr) {
         copyString(user, uid, STRING_LENGTH);
         return;
     }
diff --git a/source/clientserver/userid.h b/source/clientserver/userid.h
index de461d6f..19dfd430 100755
--- a/source/clientserver/userid.h
+++ b/source/clientserver/userid.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENTSERVER_USERID_H
 #define UDA_CLIENTSERVER_USERID_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/xdrHData.h b/source/clientserver/xdrHData.h
index ab31f89b..d1afa227 100755
--- a/source/clientserver/xdrHData.h
+++ b/source/clientserver/xdrHData.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENTSERVER_XDRHDATA_H
 #define UDA_CLIENTSERVER_XDRHDATA_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/xdrlib.cpp b/source/clientserver/xdrlib.cpp
index 88e57d96..e91b454f 100755
--- a/source/clientserver/xdrlib.cpp
+++ b/source/clientserver/xdrlib.cpp
@@ -8,12 +8,11 @@
 #include "xdrlib.h"
 
 #include <memory.h>
-#include <stdlib.h>
+#include <cstdlib>
 
 #include <logging/logging.h>
 #include <structures/struct.h>
 #include <clientserver/protocol.h>
-#include <clientserver/udaErrors.h>
 
 #include "printStructs.h"
 #include "errorLog.h"
@@ -31,19 +30,15 @@ int protocolVersionTypeTest(int protocol_version, int type)
     if (protocol_version < 3) {
         switch (type) {
             case UDA_TYPE_UNSIGNED_CHAR:
-                return 1;
             case UDA_TYPE_UNSIGNED_SHORT:
-                return 1;
             case UDA_TYPE_UNSIGNED_LONG:
-                return 1;
             case UDA_TYPE_UNSIGNED_LONG64:
-                return 1;
             case UDA_TYPE_COMPLEX:
-                return 1;
             case UDA_TYPE_DCOMPLEX:
                 return 1;
+            default:
+                return 0;
         }
-        return 0;
     } else {
         if (protocol_version < 4) {
             if (type == UDA_TYPE_COMPOUND) return 1;
@@ -55,7 +50,6 @@ int protocolVersionTypeTest(int protocol_version, int type)
     return 0;        // Return Test False: This type is OK
 }
 
-
 //-----------------------------------------------------------------------
 // Strings
 
@@ -297,7 +291,9 @@ bool_t xdr_server(XDR* xdrs, SERVER_BLOCK* str)
 
 bool_t xdr_request(XDR* xdrs, REQUEST_BLOCK* str, int protocolVersion)
 {
-    int rc = xdr_int(xdrs, &str->request);
+    int request = static_cast<int>(str->request);
+    int rc = xdr_int(xdrs, &request);
+    str->request = static_cast<REQUEST>(request);
     rc = rc && xdr_int(xdrs, &str->exp_number);
     rc = rc && xdr_int(xdrs, &str->pass);
     rc = rc && WrapXDRString(xdrs, (char*)str->tpass, STRING_LENGTH);
diff --git a/source/clientserver/xdrlib.h b/source/clientserver/xdrlib.h
index 82b84173..5ccef37e 100755
--- a/source/clientserver/xdrlib.h
+++ b/source/clientserver/xdrlib.h
@@ -2,6 +2,7 @@
 #define UDA_CLIENTSERVER_XDRLIB_H
 
 #include "udaStructs.h"
+#include "export.h"
 
 #include <rpc/types.h>
 #include <rpc/xdr.h>
@@ -17,12 +18,6 @@
 #  define xdr_uint64_t xdr_u_int64_t
 #endif
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/clientserver/xmlStructs.h b/source/clientserver/xmlStructs.h
index 364e7a7a..71e223ee 100755
--- a/source/clientserver/xmlStructs.h
+++ b/source/clientserver/xmlStructs.h
@@ -1,11 +1,7 @@
 #ifndef UDA_XMLSTRUCTS_H
 #define UDA_XMLSTRUCTS_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "export.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -32,7 +28,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     float aerr;                     // Absolute Error
     float rerr;                     // Relative Error
 } TOROIDALFIELD;
@@ -40,7 +35,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     float aerr;                     // Absolute Error
     float rerr;                     // Relative Error
 } PLASMACURRENT;
@@ -48,7 +42,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     float aerr;                     // Absolute Error
     float rerr;                     // Relative Error
 } DIAMAGNETIC;
@@ -56,7 +49,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     int nco;                        // Number of Coils
     int* coil;                      // List of Coil Connections
     int supply;                     // Supply Connections
@@ -65,7 +57,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     float r;                        // Radial Position
     float z;                        // Z Position
     float angle;                    // Angle
@@ -77,7 +68,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     float aerr;                     // Absolute Error
     float rerr;                     // Relative Error
 } PFSUPPLIES;
@@ -85,7 +75,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     int nco;                        // Number of Coordinates
     float* r;                       // Radial Position
     float* z;                       // Z Position
@@ -97,7 +86,6 @@ typedef struct {
 typedef struct {
     char id[XMLMAXSTRING];          // ID
     INSTANCE instance;
-
     int nco;                        // Number of Coordinates/Elements
     int modelnrnz[2];               // ?
     float* r;                       // Radial Position
diff --git a/source/etc/machine.d/hpc.l.cfg b/source/etc/machine.d/hpc.l.cfg
index 5972d4df..4e89d175 100755
--- a/source/etc/machine.d/hpc.l.cfg
+++ b/source/etc/machine.d/hpc.l.cfg
@@ -6,11 +6,11 @@ module load netcdf-C/4.3.2
 
 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/jet/share/lib
 
-export MAST_DATA=/net/fuslsa/data/MAST_Data
-export MAST_NEW=/net/fuslsa/data/MAST_NEW
-export MAST_ZSHOT=/net/fuslsa/data/MAST_zSHOT
-export MAST_zSHOT=/net/fuslsa/data/MAST_zSHOT
-export MAST_IMAGES=/net/fuslsa/data/MAST_IMAGES
+export MAST_DATA=/net/raidsrvr/data/MAST_Data
+export MAST_NEW=/net/raidsrvr/data/MAST_NEW
+export MAST_ZSHOT=/net/raidsrvr/data/MAST_zSHOT
+export MAST_zSHOT=/net/raidsrvr/data/MAST_zSHOT
+export MAST_IMAGES=/net/raidsrvr/data/MAST_IMAGES
 
 export UDA_METADATA_PLUGIN=POSTGRES
 
diff --git a/source/etc/machine.d/mast.l.cfg b/source/etc/machine.d/mast.l.cfg
index dd67eca7..1d3e1cc9 100644
--- a/source/etc/machine.d/mast.l.cfg
+++ b/source/etc/machine.d/mast.l.cfg
@@ -1,11 +1,11 @@
 export LD_LIBRARY_PATH=/usr/local/lib:/var/home/idam/lib64:$LD_LIBRARY_PATH
 export IDA3_ERR_MESS_FILE=/home/uda/ida3/etc/error_mess.dat
 
-export MAST_DATA=/net/fuslsa/data/MAST_Data
-export MAST_NEW=/net/fuslsa/data/MAST_NEW
-export MAST_ZSHOT=/net/fuslsa/data/MAST_zSHOT
-export MAST_zSHOT=/net/fuslsa/data/MAST_zSHOT
-export MAST_IMAGES=/net/fuslsa/data/MAST_IMAGES
+export MAST_DATA=/net/raidsrvr/data/MAST_Data
+export MAST_NEW=/net/raidsrvr/data/MAST_NEW
+export MAST_ZSHOT=/net/raidsrvr/data/MAST_zSHOT
+export MAST_zSHOT=/net/raidsrvr/data/MAST_zSHOT
+export MAST_IMAGES=/net/raidsrvr/data/MAST_IMAGES
 
 export UDA_METADATA_PLUGIN=POSTGRES
 
diff --git a/source/etc/uda-client.pc.in b/source/etc/uda-client.pc.in
index 32659b10..72982eb3 100755
--- a/source/etc/uda-client.pc.in
+++ b/source/etc/uda-client.pc.in
@@ -9,4 +9,4 @@ Description: The Universal Data Access library
 URL: http://www.iter.org/UDA
 Version: @PROJECT_VERSION@
 Cflags: -I${includedir}
-Libs: -L${libdir} -luda_client
+Libs: -L${libdir} -luda_client -lmemcached
diff --git a/source/etc/uda-cpp.pc.in b/source/etc/uda-cpp.pc.in
index 46541ee2..f777c9bc 100755
--- a/source/etc/uda-cpp.pc.in
+++ b/source/etc/uda-cpp.pc.in
@@ -9,4 +9,4 @@ Description: The Universal Data Access library
 URL: http://www.iter.org/UDA
 Version: @PROJECT_VERSION@
 Cflags: -std=c++11 -I${includedir} -I${includedir}/c++
-Libs: -L${libdir} -luda_cpp
+Libs: -L${libdir} -luda_cpp -lmemcached
diff --git a/source/etc/uda-fat-client.pc.in b/source/etc/uda-fat-client.pc.in
index 60c2a10b..6d9953ce 100755
--- a/source/etc/uda-fat-client.pc.in
+++ b/source/etc/uda-fat-client.pc.in
@@ -9,4 +9,4 @@ Description: The Universal Data Access library
 URL: http://www.iter.org/UDA
 Version: @PROJECT_VERSION@
 Cflags: -DFATCLIENT -I${includedir}
-Libs: -L${libdir} -lfatuda_client
+Libs: -L${libdir} -lfatuda_client -lmemcached
diff --git a/source/etc/uda-fat-cpp.pc.in b/source/etc/uda-fat-cpp.pc.in
index 92468a52..bd6d63e4 100755
--- a/source/etc/uda-fat-cpp.pc.in
+++ b/source/etc/uda-fat-cpp.pc.in
@@ -9,4 +9,4 @@ Description: The Universal Data Access library
 URL: http://www.iter.org/UDA
 Version: @PROJECT_VERSION@
 Cflags: -DFATCLIENT -std=c++11 -I${includedir} -I${includedir}/c++
-Libs: -L${libdir} -lfatuda_cpp
+Libs: -L${libdir} -lfatuda_cpp -lmemcached
diff --git a/source/etc/uda-plugins.pc.in b/source/etc/uda-plugins.pc.in
index 2c7c60b5..e7ee809b 100644
--- a/source/etc/uda-plugins.pc.in
+++ b/source/etc/uda-plugins.pc.in
@@ -9,4 +9,4 @@ Description: The Universal Data Access library
 URL: http://www.iter.org/UDA
 Version: @PROJECT_VERSION@
 Cflags: -I${includedir}
-Libs: -L${libdir} -luda_plugins -luda_server
\ No newline at end of file
+Libs: -L${libdir} -luda_plugins -luda_server -lmemcached
diff --git a/source/logging/CMakeLists.txt b/source/logging/CMakeLists.txt
index d153d8f0..102d169c 100755
--- a/source/logging/CMakeLists.txt
+++ b/source/logging/CMakeLists.txt
@@ -3,6 +3,12 @@
 
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 ########################################################################################################################
@@ -20,6 +26,8 @@ include_directories( ${CMAKE_SOURCE_DIR}/source )
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 ########################################################################################################################
diff --git a/source/logging/accessLog.cpp b/source/logging/accessLog.cpp
index 35414cc1..cfeaf9f0 100755
--- a/source/logging/accessLog.cpp
+++ b/source/logging/accessLog.cpp
@@ -85,8 +85,8 @@ unsigned int countDataBlockSize(DATA_BLOCK* data_block, CLIENT_BLOCK* client_blo
 
 #if defined(SERVERBUILD) || defined(FATCLIENT)
 
-void idamAccessLog(int init, CLIENT_BLOCK client_block, REQUEST_BLOCK request, SERVER_BLOCK server_block,
-                   const PLUGINLIST* pluginlist, const ENVIRONMENT* environment)
+void udaAccessLog(int init, CLIENT_BLOCK client_block, REQUEST_BLOCK request, SERVER_BLOCK server_block,
+                  const PLUGINLIST* pluginlist, const ENVIRONMENT* environment)
 {
     int err = 0;
 
@@ -214,24 +214,24 @@ void idamAccessLog(int init, CLIENT_BLOCK client_block, REQUEST_BLOCK request, S
         char* work = (char*)malloc(MAXMETA * sizeof(char));
 
         sprintf(work, "%s - %s [%s] [%d %s %d %d %s %s %s %s %s %s %s] %d %d [%s] %f %d %d [%d %d] [%s]",
-                host, client_block.uid, accessdate, request.request, request.signal, request.exp_number,
-                request.pass, request.tpass, request.path, request.file, request.format, request.archive,
-                request.device_name, request.server, err, (int)totalDataBlockSize, msg,
+                host, client_block.uid, accessdate, static_cast<int>(request.request), request.signal,
+                request.exp_number, request.pass, request.tpass, request.path, request.file, request.format,
+                request.archive, request.device_name, request.server, err, (int)totalDataBlockSize, msg,
                 elapsedtime, client_block.version, server_block.version, client_block.pid, server_block.pid,
                 client_block.DOI);
 
-        idamLog(UDA_LOG_ACCESS, "%s\n", work);
+        udaLog(UDA_LOG_ACCESS, "%s\n", work);
 
         // Save Provenance with socket stream protection
 
-        idamServerRedirectStdStreams(0);
-        idamProvenancePlugin(&client_block, &request, nullptr, nullptr, pluginlist, work, environment);
-        idamServerRedirectStdStreams(1);
+        udaServerRedirectStdStreams(0);
+        udaProvenancePlugin(&client_block, &request, nullptr, nullptr, pluginlist, work, environment);
+        udaServerRedirectStdStreams(1);
 
-        free((void*)work);
+        free(work);
 
     } else {
-        idamLog(UDA_LOG_ACCESS, "%s - %s [%s] [%d %s %d %d %s %s %s %s %s %s %s] %d %d [%s] %f %d %d [%d %d] [%s]\n",
+        udaLog(UDA_LOG_ACCESS, "%s - %s [%s] [%d %s %d %d %s %s %s %s %s %s %s] %d %d [%s] %f %d %d [%d %d] [%s]\n",
                 host, client_block.uid, accessdate, request.request, request.signal, request.exp_number,
                 request.pass, request.tpass, request.path, request.file, request.format, request.archive,
                 request.device_name, request.server, err, (int)totalDataBlockSize, msg,
diff --git a/source/logging/accessLog.h b/source/logging/accessLog.h
index 2fe66124..b58ec852 100755
--- a/source/logging/accessLog.h
+++ b/source/logging/accessLog.h
@@ -2,24 +2,19 @@
 #define UDA_LOGGING_ACCESSLOG_H
 
 #include <plugins/udaPlugin.h>
+#include <clientserver/export.h>
 
 #define HOSTNAMELENGTH    20
 #define DATELENGTH        27
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 LIBRARY_API unsigned int countDataBlockSize(DATA_BLOCK* data_block, CLIENT_BLOCK* client_block);
 
-LIBRARY_API void idamAccessLog(int init, CLIENT_BLOCK client_block, REQUEST_BLOCK request, SERVER_BLOCK server_block,
-                   const PLUGINLIST* pluginlist, const ENVIRONMENT* environment);
+LIBRARY_API void udaAccessLog(int init, CLIENT_BLOCK client_block, REQUEST_BLOCK request, SERVER_BLOCK server_block,
+                              const PLUGINLIST* pluginlist, const ENVIRONMENT* environment);
 
 #ifdef __cplusplus
 }
diff --git a/source/logging/fileLogging.cpp b/source/logging/fileLogging.cpp
index 2c86df29..f5b914ab 100755
--- a/source/logging/fileLogging.cpp
+++ b/source/logging/fileLogging.cpp
@@ -12,12 +12,12 @@ static FILE* access_log = nullptr;
 
 static LOG_LEVEL log_level = UDA_LOG_NONE;
 
-void idamSetLogLevel(LOG_LEVEL level)
+void udaSetLogLevel(LOG_LEVEL level)
 {
     log_level = level;
 }
 
-LOG_LEVEL idamGetLogLevel()
+LOG_LEVEL udaGetLogLevel()
 {
     return log_level;
 }
@@ -34,7 +34,7 @@ static FILE* idamGetLogFile(LOG_LEVEL mode)
     }
 }
 
-void idamSetLogFile(LOG_LEVEL mode, FILE* file)
+void udaSetLogFile(LOG_LEVEL mode, FILE* file)
 {
     switch (mode) {
         case UDA_LOG_ACCESS: access_log = file; break;
@@ -46,7 +46,7 @@ void idamSetLogFile(LOG_LEVEL mode, FILE* file)
     }
 }
 
-void idamLogWithFunc(LOG_LEVEL mode, logFunc func)
+void udaLogWithFunc(LOG_LEVEL mode, logFunc func)
 {
     FILE* log_file = idamGetLogFile(mode);
 
@@ -56,7 +56,7 @@ void idamLogWithFunc(LOG_LEVEL mode, logFunc func)
     }
 }
 
-void idamLog(LOG_LEVEL mode, const char * fmt, ...)
+void udaLog(LOG_LEVEL mode, const char * fmt, ...)
 {
     va_list args;
     va_start(args, fmt);
@@ -71,7 +71,7 @@ void idamLog(LOG_LEVEL mode, const char * fmt, ...)
     va_end(args);
 }
 
-void idamCloseLogging()
+void udaCloseLogging()
 {
     if (access_log != nullptr) {
         fclose(access_log);
diff --git a/source/logging/logging.h b/source/logging/logging.h
index 7ebad93a..11e3aae6 100755
--- a/source/logging/logging.h
+++ b/source/logging/logging.h
@@ -3,18 +3,14 @@
 
 #include <stdio.h>
 #include <string.h>
+#include <clientserver/export.h>
+
 #ifdef _WIN32
 #  define FILENAME (strrchr(__FILE__, '\\') ? strrchr(__FILE__, '\\') + 1 : __FILE__)
-#  define UDA_LOG(LEVEL, FMT, ...) idamLog(LEVEL, "%s:%d >> " FMT, FILENAME, __LINE__, ##__VA_ARGS__)
+#  define UDA_LOG(LEVEL, FMT, ...) udaLog(LEVEL, "%s:%d >> " FMT, FILENAME, __LINE__, ##__VA_ARGS__)
 #else
 #  include <libgen.h>
-#  define UDA_LOG(LEVEL, FMT, ...) idamLog(LEVEL, "%s:%d >> " FMT, basename((char *)__FILE__), __LINE__, ##__VA_ARGS__)
-#endif
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
+#  define UDA_LOG(LEVEL, FMT, ...) udaLog(LEVEL, "%s:%d >> " FMT, basename((char *)__FILE__), __LINE__, ##__VA_ARGS__)
 #endif
 
 #ifdef __cplusplus
@@ -34,17 +30,12 @@ typedef enum LogLevel {
 
 typedef void (* logFunc)(FILE*);
 
-LIBRARY_API void idamSetLogLevel(LOG_LEVEL log_level);
-
-LIBRARY_API LOG_LEVEL idamGetLogLevel();
-
-LIBRARY_API void idamCloseLogging();
-
-LIBRARY_API void idamSetLogFile(LOG_LEVEL mode, FILE* file_name);
-
-LIBRARY_API void idamLogWithFunc(LOG_LEVEL mode, logFunc func);
-
-LIBRARY_API void idamLog(LOG_LEVEL mode, const char* fmt, ...);
+LIBRARY_API void udaSetLogLevel(LOG_LEVEL level);
+LIBRARY_API LOG_LEVEL udaGetLogLevel();
+LIBRARY_API void udaCloseLogging();
+LIBRARY_API void udaSetLogFile(LOG_LEVEL mode, FILE* file);
+LIBRARY_API void udaLogWithFunc(LOG_LEVEL mode, logFunc func);
+LIBRARY_API void udaLog(LOG_LEVEL mode, const char* fmt, ...);
 
 #ifdef __cplusplus
 }
diff --git a/source/logging/sysLogging.cpp b/source/logging/sysLogging.cpp
index 35222f9e..ae9c57c4 100755
--- a/source/logging/sysLogging.cpp
+++ b/source/logging/sysLogging.cpp
@@ -8,22 +8,22 @@ static LOG_LEVEL log_level = UDA_LOG_NONE;
 
 int reopen_logs = 0;        // No need to Re-Open Logs
 
-void idamSetLogLevel(LOG_LEVEL mode)
+void udaSetLogLevel(LOG_LEVEL level)
 {
-    log_level = mode;
+    log_level = level;
 }
 
-LOG_LEVEL idamGetLogLevel()
+LOG_LEVEL udaGetLogLevel()
 {
     return log_level;
 }
 
-void idamCloseLogging()
+void udaCloseLogging()
 {
     closelog();
 }
 
-void idamSetLogFile(LOG_LEVEL mode, FILE* file_name)
+void udaSetLogFile(LOG_LEVEL mode, FILE* file)
 {
     openlog("uda", 0, 0);
 }
@@ -40,7 +40,7 @@ static int syslogPriority(LOG_LEVEL log_mode)
     }
 }
 
-void idamLogWithFunc(LOG_LEVEL mode, logFunc func)
+void udaLogWithFunc(LOG_LEVEL mode, logFunc func)
 {
     char tmpFileName[] = "UdaTempLogXXXXXX";
 
@@ -53,14 +53,14 @@ void idamLogWithFunc(LOG_LEVEL mode, logFunc func)
     size_t n = 0;
 
     while (getline(&line, &n, tmpFile) != EOF) {
-        idamLog(mode, "%s", line);
+        udaLog(mode, "%s", line);
     }
 
     free(line);
     fclose(tmpFile);
 }
 
-void idamLog(LOG_LEVEL mode, const char* fmt, ...)
+void udaLog(LOG_LEVEL mode, const char* fmt, ...)
 {
     if (mode >= log_level) {
         int priority = syslogPriority(mode);
diff --git a/source/plugins/CMakeLists.txt b/source/plugins/CMakeLists.txt
index e96dd50a..abc425e9 100755
--- a/source/plugins/CMakeLists.txt
+++ b/source/plugins/CMakeLists.txt
@@ -8,6 +8,12 @@ if( WIN32 OR MINGW )
   if( NOT MINGW )
     find_package( dlfcn-win32 CONFIG REQUIRED )
   endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 configure_file(
@@ -55,6 +61,8 @@ include_directories(
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 set( SOURCE_FILES
@@ -67,7 +75,7 @@ set( HEADER_FILES
   pluginStructs.h
   udaPlugin.h
   udaPluginFiles.h
-)
+        testplugin/teststructs.h testplugin/teststructs.cpp)
 
 add_library( plugins-objects OBJECT ${SOURCE_FILES} ${HEADER_FILES} )
 add_library( plugins-static STATIC $<TARGET_OBJECTS:plugins-objects> )
@@ -82,6 +90,8 @@ if( WIN32 OR MINGW )
   else()
     set( LINK_LIB ${LINK_LIB} ${XDR_LIBRARIES} ws2_32 dlfcn-win32::dl )
   endif()
+elseif(TIRPC_FOUND)
+  set( LINK_LIB ${LINK_LIB} ${TIRPC_LIBRARIES})
 endif()
 
 target_link_libraries( plugins-static PRIVATE
diff --git a/source/plugins/bytes/CMakeLists.txt b/source/plugins/bytes/CMakeLists.txt
index 99fc2f46..49045947 100644
--- a/source/plugins/bytes/CMakeLists.txt
+++ b/source/plugins/bytes/CMakeLists.txt
@@ -15,7 +15,7 @@ uda_plugin(
   DESCRIPTION "data reader to access files as a block of bytes without interpretation"
   EXAMPLE "BYTES::read()"
   LIBNAME bytes_plugin
-  SOURCES bytesPlugin.cpp readBytesNonOptimally.cpp
+  SOURCES bytesPlugin.cpp readBytesNonOptimally.cpp md5Sum.cpp
   EXTRA_INCLUDE_DIRS
     ${LIBXML2_INCLUDE_DIR}
   EXTRA_LINK_LIBS
diff --git a/source/plugins/bytes/bytesPlugin.cpp b/source/plugins/bytes/bytesPlugin.cpp
index b9a0f0cf..2511319d 100644
--- a/source/plugins/bytes/bytesPlugin.cpp
+++ b/source/plugins/bytes/bytesPlugin.cpp
@@ -154,7 +154,7 @@ int do_read(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     StringCopy(data_source->path, path, MAXPATH);
     UDA_LOG(UDA_LOG_DEBUG, "expandEnvironmentvariables! \n");
-    expandEnvironmentVariables(data_source->path);
+    expand_environment_variables(data_source->path);
 
     return readBytes(*data_source, *signal_desc, data_block, idam_plugin_interface->environment);
 }
diff --git a/source/plugins/bytes/bytesPlugin.h b/source/plugins/bytes/bytesPlugin.h
index 58d0519e..9b020fa2 100644
--- a/source/plugins/bytes/bytesPlugin.h
+++ b/source/plugins/bytes/bytesPlugin.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_BYTESPLUGIN_H
 
 #include <plugins/udaPlugin.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/clientserver/md5Sum.cpp b/source/plugins/bytes/md5Sum.cpp
similarity index 100%
rename from source/clientserver/md5Sum.cpp
rename to source/plugins/bytes/md5Sum.cpp
diff --git a/source/clientserver/md5Sum.h b/source/plugins/bytes/md5Sum.h
similarity index 70%
rename from source/clientserver/md5Sum.h
rename to source/plugins/bytes/md5Sum.h
index 47ab258b..a9a1934e 100755
--- a/source/clientserver/md5Sum.h
+++ b/source/plugins/bytes/md5Sum.h
@@ -1,11 +1,7 @@
 #ifndef UDA_CLIENTSERVER_MD5SUM_H
 #define UDA_CLIENTSERVER_MD5SUM_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include "clientserver/export.h"
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/bytes/readBytesNonOptimally.cpp b/source/plugins/bytes/readBytesNonOptimally.cpp
index 16357d41..1ac0c2bf 100755
--- a/source/plugins/bytes/readBytesNonOptimally.cpp
+++ b/source/plugins/bytes/readBytesNonOptimally.cpp
@@ -27,7 +27,7 @@
 #include <logging/logging.h>
 #include <clientserver/errorLog.h>
 #include <clientserver/stringUtils.h>
-#include <clientserver/md5Sum.h>
+#include <plugins/bytes/md5Sum.h>
 #include <clientserver/freeDataBlock.h>
 #include <clientserver/udaTypes.h>
 #include <clientserver/initStructs.h>
diff --git a/source/plugins/bytes/readBytesNonOptimally.h b/source/plugins/bytes/readBytesNonOptimally.h
index f04301ac..63bacd5f 100755
--- a/source/plugins/bytes/readBytesNonOptimally.h
+++ b/source/plugins/bytes/readBytesNonOptimally.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_READBYTESNONOPTIMALLY_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/hdf5/hdf5plugin.h b/source/plugins/hdf5/hdf5plugin.h
index 0c510ae0..01a1f966 100755
--- a/source/plugins/hdf5/hdf5plugin.h
+++ b/source/plugins/hdf5/hdf5plugin.h
@@ -9,12 +9,7 @@
 
 #include <plugins/udaPluginFiles.h>
 #include <plugins/udaPlugin.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -27,9 +22,7 @@ extern "C" {
 extern UDA_PLUGIN_FILE_LIST pluginFileList;
 
 LIBRARY_API int udaHDF5(IDAM_PLUGIN_INTERFACE * idam_plugin_interface);
-
 LIBRARY_API int readHDF5IdamType(H5T_class_t classtype, int precision, int issigned);
-
 LIBRARY_API int readHDF5Att(hid_t file_id, char * object, hid_t att_id, char * attname, DATA_BLOCK * data_block);
 
 #ifdef __cplusplus
diff --git a/source/plugins/hdf5/readHDF58.cpp b/source/plugins/hdf5/readHDF58.cpp
index d1155f39..81ef00c6 100644
--- a/source/plugins/hdf5/readHDF58.cpp
+++ b/source/plugins/hdf5/readHDF58.cpp
@@ -226,7 +226,7 @@ int readHDF5Att(hid_t file_id, char* object, hid_t att_id, char* attname, DATA_B
     if (rc < 0) {
         err = 999;
         addIdamError(CODEERRORTYPE, "readHDF5Att", err, "Error reading Attribute Data");
-        free((void*)data);
+        free(data);
         return err;
     }
 
diff --git a/source/plugins/hdf5/readHDF58.h b/source/plugins/hdf5/readHDF58.h
index c1fa0ee4..7735d013 100755
--- a/source/plugins/hdf5/readHDF58.h
+++ b/source/plugins/hdf5/readHDF58.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_READHDF58_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/help/CMakeLists.txt b/source/plugins/help/CMakeLists.txt
index faefa219..0110919e 100755
--- a/source/plugins/help/CMakeLists.txt
+++ b/source/plugins/help/CMakeLists.txt
@@ -11,17 +11,23 @@ endif()
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
   include_directories( ${XDR_INCLUDE_DIR} )
+else()
+  find_package( TIRPC QUIET)
+  if( TIRPC_FOUND )
+    include_directories( ${TIRPC_INCLUDE_DIR} )
+    add_definitions(-D__TIRPC__)   
+  endif()
 endif()
 
 include( plugins )
 
 uda_plugin(
   NAME HELP
-  ENTRY_FUNC idamServerHelp
+  ENTRY_FUNC helpPlugin
   DESCRIPTION "Service Discovery: list the details on all registered services"
   EXAMPLE "HELP::services()"
   LIBNAME help_plugin
-  SOURCES idamServerHelp.cpp
+  SOURCES help_plugin.cpp
   EXTRA_INCLUDE_DIRS
     ${LIBXML2_INCLUDE_DIR}
   EXTRA_LINK_LIBS
diff --git a/source/plugins/help/idamServerHelp.cpp b/source/plugins/help/help_plugin.cpp
similarity index 99%
rename from source/plugins/help/idamServerHelp.cpp
rename to source/plugins/help/help_plugin.cpp
index 287d81eb..e78370b4 100755
--- a/source/plugins/help/idamServerHelp.cpp
+++ b/source/plugins/help/help_plugin.cpp
@@ -17,7 +17,7 @@
 *	init	Initialise the plugin: read all required data and process. Retain staticly for
 *		future reference.
 *---------------------------------------------------------------------------------------------------------------*/
-#include "idamServerHelp.h"
+#include "help_plugin.h"
 
 #include <stdlib.h>
 #ifdef __GNUC__
@@ -38,7 +38,7 @@ static int do_ping(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 
 static int do_services(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 
-int idamServerHelp(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
+int helpPlugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     int err;
     static short init = 0;
diff --git a/source/plugins/help/idamServerHelp.h b/source/plugins/help/help_plugin.h
similarity index 66%
rename from source/plugins/help/idamServerHelp.h
rename to source/plugins/help/help_plugin.h
index fb7a3b80..634f40f6 100755
--- a/source/plugins/help/idamServerHelp.h
+++ b/source/plugins/help/help_plugin.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_IDAMSERVERHELP_H
 
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -17,7 +12,7 @@ extern "C" {
 #define THISPLUGIN_MAX_INTERFACE_VERSION    1
 #define THISPLUGIN_DEFAULT_METHOD           "help"
 
-LIBRARY_API int idamServerHelp(IDAM_PLUGIN_INTERFACE * idam_plugin_interface);
+LIBRARY_API int helpPlugin(IDAM_PLUGIN_INTERFACE * idam_plugin_interface);
 
 #ifdef __cplusplus
 }
diff --git a/source/plugins/keyvalue/CMakeLists.txt b/source/plugins/keyvalue/CMakeLists.txt
index a7360cc8..82ac77a8 100755
--- a/source/plugins/keyvalue/CMakeLists.txt
+++ b/source/plugins/keyvalue/CMakeLists.txt
@@ -4,7 +4,7 @@
 find_package( LibXml2 QUIET )
 find_package( LevelDB QUIET )
 
-if( NOT LEVELDB_FOUND )
+if( NOT LevelDB_FOUND )
   message( WARNING "LevelDB not found - skipping keyvalue plugin" )
   return()
 elseif( NOT LIBXML2_FOUND )
@@ -24,8 +24,8 @@ uda_plugin(
   CONFIG_FILE keyvalue.cfg
   EXTRA_INCLUDE_DIRS
     ${LIBXML2_INCLUDE_DIR}
-    ${LEVELDB_INCLUDE_DIR}
+    ${LevelDB_INCLUDE_DIR}
   EXTRA_LINK_LIBS
     ${LIBXML2_LIBRARIES}
-    ${LEVELDB_LIBRARIES}
+    ${LevelDB_LIBRARIES}
 )
diff --git a/source/plugins/keyvalue/keyvaluePlugin.h b/source/plugins/keyvalue/keyvaluePlugin.h
index 8bd93967..835a4fb4 100755
--- a/source/plugins/keyvalue/keyvaluePlugin.h
+++ b/source/plugins/keyvalue/keyvaluePlugin.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_KEYVALUEPLUGIN_H
 
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/managePluginFiles.cpp b/source/plugins/managePluginFiles.cpp
index 70dc14c9..e277cc4a 100755
--- a/source/plugins/managePluginFiles.cpp
+++ b/source/plugins/managePluginFiles.cpp
@@ -40,8 +40,8 @@ int addIdamPluginFilePtr(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename,
     void* old_handle = nullptr;
     int closed;
 
-    if ((old_handle = getOpenIdamPluginFilePtr(uda_files, filename)) !=
-        nullptr) {    // Is an Open File Handle already listed?
+    if ((old_handle = getOpenIdamPluginFilePtr(uda_files, filename)) != nullptr) {
+        // Is an Open File Handle already listed?
         if (old_handle == handle) return 1;
     }
 
@@ -195,7 +195,7 @@ void closeIdamPluginFiles(UDA_PLUGIN_FILE_LIST* uda_files)
     for (int i = 0; i < uda_files->count; i++) {
         closeIdamPluginFile(uda_files, uda_files->files[i].filename);
     }
-    free((void*)uda_files->files);
+    free(uda_files->files);
     initIdamPluginFileList(uda_files);
 }
 
diff --git a/source/plugins/managePluginFiles.h b/source/plugins/managePluginFiles.h
index 63238d0a..7d7f87ba 100755
--- a/source/plugins/managePluginFiles.h
+++ b/source/plugins/managePluginFiles.h
@@ -2,41 +2,24 @@
 #define UDA_PLUGINS_MANAGEPLUGINFILES_H
 
 #include <plugins/udaPluginFiles.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 LIBRARY_API void initIdamPluginFileList(UDA_PLUGIN_FILE_LIST* idamfiles);
-
 LIBRARY_API void registerIdamPluginFileClose(UDA_PLUGIN_FILE_LIST* idamfiles, void* fptr);
-
 LIBRARY_API int addIdamPluginFilePtr(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename, void* handle);
-
 LIBRARY_API int addIdamPluginFileLong(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename, long handle);
-
 LIBRARY_API void* getOpenIdamPluginFilePtr(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename);
-
 LIBRARY_API long getOpenIdamPluginFileLong(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename);
-
 LIBRARY_API int getClosedIdamPluginFile(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename);
-
 LIBRARY_API void closeIdamPluginFile(UDA_PLUGIN_FILE_LIST* idamfiles, const char* filename);
-
 LIBRARY_API void closeIdamPluginFiles(UDA_PLUGIN_FILE_LIST* uda_files);
-
 LIBRARY_API void purgeStalestIdamPluginFile(UDA_PLUGIN_FILE_LIST* uda_files);
-
 LIBRARY_API int findIdamPluginFileByName(UDA_PLUGIN_FILE_LIST* uda_files, const char* filename);
-
 LIBRARY_API int findIdamPluginFileByLong(UDA_PLUGIN_FILE_LIST* uda_files, long handle);
-
 LIBRARY_API void setIdamPluginFileClosed(UDA_PLUGIN_FILE_LIST* uda_files, int record);
 
 #ifdef __cplusplus
diff --git a/source/plugins/pluginStructs.h b/source/plugins/pluginStructs.h
index 96896720..1f7d5347 100755
--- a/source/plugins/pluginStructs.h
+++ b/source/plugins/pluginStructs.h
@@ -5,12 +5,7 @@
 
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/pluginUtils.cpp b/source/plugins/pluginUtils.cpp
index 0c8d4fb6..f8cd18f7 100755
--- a/source/plugins/pluginUtils.cpp
+++ b/source/plugins/pluginUtils.cpp
@@ -7,8 +7,7 @@
 #  include <strings.h>
 #endif
 
-
-#include <cache/cache.h>
+#include <cache/memcache.h>
 #include <client/udaClient.h>
 #include <clientserver/expand_path.h>
 #include <clientserver/freeDataBlock.h>
diff --git a/source/plugins/template/templatePlugin.h b/source/plugins/template/templatePlugin.h
index 9957b06d..6abe8b19 100755
--- a/source/plugins/template/templatePlugin.h
+++ b/source/plugins/template/templatePlugin.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_TEMPLATEPLUGIN_H
 
 #include <plugins/udaPlugin.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/testplugin/CMakeLists.txt b/source/plugins/testplugin/CMakeLists.txt
index 4c2a892f..49d148ca 100755
--- a/source/plugins/testplugin/CMakeLists.txt
+++ b/source/plugins/testplugin/CMakeLists.txt
@@ -11,6 +11,12 @@ endif()
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
   include_directories( ${XDR_INCLUDE_DIR} )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    include_directories( ${TIRPC_INCLUDE_DIR} )
+  endif()
 endif()
 
 include( plugins )
@@ -21,7 +27,7 @@ uda_plugin(
   DESCRIPTION "Generate Test Data"
   EXAMPLE "TESTPLUGIN::test1()"
   LIBNAME testplugin_plugin
-  SOURCES testplugin.cpp
+  SOURCES testplugin.cpp teststructs.cpp
   EXTRA_INCLUDE_DIRS
     ${LIBXML2_INCLUDE_DIR}
   EXTRA_LINK_LIBS
diff --git a/source/plugins/testplugin/testplugin.cpp b/source/plugins/testplugin/testplugin.cpp
index a786aeb9..be0f43d0 100755
--- a/source/plugins/testplugin/testplugin.cpp
+++ b/source/plugins/testplugin/testplugin.cpp
@@ -21,6 +21,7 @@
 
 #include <cstdlib>
 #include <cstddef>
+
 #ifdef __GNUC__
 #  include <strings.h>
 #endif
@@ -32,6 +33,8 @@
 #include <clientserver/makeRequestBlock.h>
 #include <clientserver/printStructs.h>
 
+#include "teststructs.h"
+
 #ifdef PUTDATAENABLED
 #  include <structures/accessors.h>
 #endif // PUTDATAENABLED
@@ -40,73 +43,96 @@
 #  include <netdb.h>
 #endif // TESTUDT
 
-static void init_structure_definitions(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 static int do_help(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test0(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test2(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test4(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test5(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test6(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test7(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test8(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test9(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test9A(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test10(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test11(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test12(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test13(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test14(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test15(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test16(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test18(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test19(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test20(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test21(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test22(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test23(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test24(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test25(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test26(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test27(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test28(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test30(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test31(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test32(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test34(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 #ifdef PUTDATAENABLED
 static int do_test40(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 #endif // PUTDATAENABLED
+
 static int do_test50(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_test62(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 
 static int do_plugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_errortest(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_scalartest(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 static int do_emptytest(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
 #ifdef TESTUDT
 static int do_testudt(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
 #endif // TESTUDT
 
-typedef struct Test9 {
-    char v1[56];        // single fixed length string
-    char v2[3][56];     // 3 fixed length strings
-    char* v3;           // single arbitrary length string
-    char* v4[3];        // 3 strings of arbitrary length
-    char** v5;          // arbitrary number of strings of arbitrary length
-} TEST9;
-
-typedef struct Test9A {
-    char v1[56];        // single fixed length string
-    char v2[3][56];     // 3 fixed length strings
-    char* v3;           // single arbitrary length string
-    char* v4[3];        // 3 strings of arbitrary length
-    char** v5;          // arbitrary number of strings of arbitrary length
-    TEST9 v6;           // Sub Structure with String types
-} TEST9A;
-
 extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     int err = 0;
@@ -147,21 +173,25 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     //----------------------------------------------------------------------------------------
     // Initialise
 
-    if (!init || STR_IEQUALS(request_block->function, "init") || STR_IEQUALS(request_block->function, "initialise")) {
+    if (!init || STR_IEQUALS(request_block->function, "init")
+        || STR_IEQUALS(request_block->function, "initialise")) {
         init = 1;
         UDA_LOG(UDA_LOG_DEBUG, "plugin initialised\n");
-        if (STR_IEQUALS(request_block->function, "init") || STR_IEQUALS(request_block->function, "initialise")) {
+        if (STR_IEQUALS(request_block->function, "init")
+            || STR_IEQUALS(request_block->function, "initialise")) {
             return 0;
         }
     }
-    
-    if(!STR_IEQUALS(request_block->function, "test50") &&
-       idam_plugin_interface->userdefinedtypelist == nullptr) RAISE_PLUGIN_ERROR("Unable to define Data Structures - nullptr list!");
-    
+
+    if (!STR_IEQUALS(request_block->function, "test50")
+        && idam_plugin_interface->userdefinedtypelist == nullptr) {
+        RAISE_PLUGIN_ERROR("Unable to define Data Structures - nullptr list!");
+    }
+
     UDA_LOG(UDA_LOG_DEBUG, "entering init_structure_definitions\n");
 
     init_structure_definitions(idam_plugin_interface);
-    
+
     UDA_LOG(UDA_LOG_DEBUG, "return from init_structure_definitions\n");
 
     //----------------------------------------------------------------------------------------
@@ -170,12 +200,14 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     if (STR_IEQUALS(request_block->function, "help")) {
         err = do_help(idam_plugin_interface);
-    } else if (STR_IEQUALS(request_block->function, "test0") || STR_IEQUALS(request_block->function, "test1")) {
+    } else if (STR_IEQUALS(request_block->function, "test0")
+               || STR_IEQUALS(request_block->function, "test1")) {
         // Single String - not a Structure
         //      test0: passed as a char/byte array
         //      test1: passed as type STRING
         err = do_test0(idam_plugin_interface);
-    } else if (STR_IEQUALS(request_block->function, "test2") || STR_IEQUALS(request_block->function, "test3")) {
+    } else if (STR_IEQUALS(request_block->function, "test2")
+               || STR_IEQUALS(request_block->function, "test3")) {
         // Array of Strings - not a Structure
         //      test2: as a rank 2 char/byte array
         //      test3: as an array of type STRING
@@ -196,8 +228,8 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         err = do_test9A(idam_plugin_interface);
     } else
 
-        //=========================================================================================================
-        // Integer Tests
+    //=========================================================================================================
+    // Integer Tests
 
     if (STR_IEQUALS(request_block->function, "test10")) {           // Single Integer
         err = do_test10(idam_plugin_interface);
@@ -219,8 +251,8 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         err = do_test19(idam_plugin_interface);
     } else
 
-        //=========================================================================================================
-        // Short Integer Tests
+    //=========================================================================================================
+    // Short Integer Tests
 
     if (STR_IEQUALS(request_block->function, "test20")) {           // Single Short Integer
         err = do_test20(idam_plugin_interface);
@@ -242,8 +274,8 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         err = do_test28(idam_plugin_interface);
     } else
 
-        //=====================================================================================================
-        // Doubles
+    //=====================================================================================================
+    // Doubles
 
     if (STR_IEQUALS(request_block->function, "test30")) {           // Simple Structure
         err = do_test30(idam_plugin_interface);
@@ -256,12 +288,12 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     } else if (STR_IEQUALS(request_block->function, "test34")) {    // Compound Structure
         err = do_test34(idam_plugin_interface);
 #ifdef PUTDATAENABLED
-        } else if(STR_IEQUALS(request_block->function, "test40")) {
-            err = do_test40(idam_plugin_interface);
+    } else if (STR_IEQUALS(request_block->function, "test40")) {
+        err = do_test40(idam_plugin_interface);
 #endif
 
-        //=====================================================================================================
-        // Misc
+    //=====================================================================================================
+    // Misc
 
     } else if (STR_IEQUALS(request_block->function, "plugin")) {
         err = do_plugin(idam_plugin_interface);
@@ -272,16 +304,16 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     } else if (STR_IEQUALS(request_block->function, "emptytest")) {
         err = do_emptytest(idam_plugin_interface);
 #ifdef TESTUDT
-        } else if(STR_IEQUALS(request_block->function, "test40")) {
-            err = do_testudt(idam_plugin_interface);
-#endif 
+    } else if (STR_IEQUALS(request_block->function, "test40")) {
+        err = do_testudt(idam_plugin_interface);
+#endif
     } else if (STR_IEQUALS(request_block->function, "test50")) {
         err = do_test50(idam_plugin_interface);
-    } else if (STR_IEQUALS(request_block->function, "test60")) {	// ENUM Type Data tests
+    } else if (STR_IEQUALS(request_block->function, "test60")) {    // ENUM Type Data tests
         err = do_test60(idam_plugin_interface);
-    } else if (STR_IEQUALS(request_block->function, "test61")) { 
+    } else if (STR_IEQUALS(request_block->function, "test61")) {
         err = do_test61(idam_plugin_interface);
-    } else if (STR_IEQUALS(request_block->function, "test62")) { 
+    } else if (STR_IEQUALS(request_block->function, "test62")) {
         err = do_test62(idam_plugin_interface);
     } else {
         err = 999;
@@ -293,74 +325,72 @@ extern int testplugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
 void testError1()
 {
-// Test of Error Management within Plugins
+    // Test of Error Management within Plugins
     int err = 9991;
     addIdamError(CODEERRORTYPE, "testplugin", err, "Test #1 of Error State Management");
 }
 
 void testError2()
 {
-// Test of Error Management within Plugins
+    // Test of Error Management within Plugins
     int err = 9992;
     addIdamError(CODEERRORTYPE, "testplugin", err, "Test #2 of Error State Management");
 }
 
-// Help: A Description of library functionality
 static int do_help(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
     UDA_LOG(UDA_LOG_DEBUG, "help function called\n");
-//fflush(nullptr);    
-//return 0;
+
     const char* help = "\nTestplugin: Functions Names and Test Descriptions/n/n"
-            "test0-test9: String passing tests\n"
-            "\ttest0: single string as a char array\n"
-            "\ttest1: single string\n"
-            "\ttest2: multiple strings as a 2D array of chars\n"
-            "\ttest3: array of strings\n"
-            "\ttest4: data structure with a fixed length single string\n"
-            "\ttest5: data structure with a fixed length multiple string\n"
-            "\ttest6: data structure with an arbitrary length single string\n"
-            "\ttest7: data structure with a fixed number of arbitrary length strings\n"
-            "\ttest8: data structure with an arbitrary number of arbitrary length strings\n\n"
-            "\ttest9: array of data structures with a variety of string types\n\n"
-            "\ttest9A: array of data structures with a variety of string types and single sub structure\n\n"
-
-            "***test10-test18: Integer passing tests\n"
-            "\ttest10: single integer\n"
-            "\ttest11: fixed number (rank 1 array) of integers\n"
-            "\ttest12: arbitrary number (rank 1 array) of integers\n"
-            "\ttest13: fixed length rank 2 array of integers\n"
-            "\ttest14: arbitrary length rank 2 array of integers\n"
-            "\ttest15: data structure with a single integer\n"
-            "\ttest16: data structure with a fixed number of integers\n"
-            "\ttest17: data structure with a arbitrary number of integers\n"
-            "\ttest18: array of data structures with a variety of integer types\n\n"
-
-            "***test20-test28: Short Integer passing tests\n"
-            "\ttest20: single integer\n"
-            "\ttest21: fixed number (rank 1 array) of integers\n"
-            "\ttest22: arbitrary number (rank 1 array) of integers\n"
-            "\ttest23: fixed length rank 2 array of integers\n"
-            "\ttest24: arbitrary length rank 2 array of integers\n"
-            "\ttest25: data structure with a single integer\n"
-            "\ttest26: data structure with a fixed number of integers\n"
-            "\ttest27: data structure with a arbitrary number of integers\n"
-            "\ttest28: array of data structures with a variety of integer types\n\n"
-
-            "***test30-test32: double passing tests\n"
-            "\ttest30: pair of doubles (Coordinate)\n"
-
-            "***test40-test40: put data block receiving tests\n"
-	    
-	    "\ttest50: Passing parameters into plugins via the source argument\n"
-	    
-	    "\ttest60-62: ENUMLIST structures\n\n"
-
-            "plugin: test calling other plugins\n"
-
-            "error: Error reporting and server termination tests\n";
+                       "test0-test9: String passing tests\n"
+                       "\ttest0: single string as a char array\n"
+                       "\ttest1: single string\n"
+                       "\ttest2: multiple strings as a 2D array of chars\n"
+                       "\ttest3: array of strings\n"
+                       "\ttest4: data structure with a fixed length single string\n"
+                       "\ttest5: data structure with a fixed length multiple string\n"
+                       "\ttest6: data structure with an arbitrary length single string\n"
+                       "\ttest7: data structure with a fixed number of arbitrary length strings\n"
+                       "\ttest8: data structure with an arbitrary number of arbitrary length strings\n\n"
+                       "\ttest9: array of data structures with a variety of string types\n\n"
+                       "\ttest9A: array of data structures with a variety of string types and single sub structure\n\n"
+
+                       "***test10-test18: Integer passing tests\n"
+                       "\ttest10: single integer\n"
+                       "\ttest11: fixed number (rank 1 array) of integers\n"
+                       "\ttest12: arbitrary number (rank 1 array) of integers\n"
+                       "\ttest13: fixed length rank 2 array of integers\n"
+                       "\ttest14: arbitrary length rank 2 array of integers\n"
+                       "\ttest15: data structure with a single integer\n"
+                       "\ttest16: data structure with a fixed number of integers\n"
+                       "\ttest17: data structure with a arbitrary number of integers\n"
+                       "\ttest18: array of data structures with a variety of integer types\n\n"
+
+                       "***test20-test28: Short Integer passing tests\n"
+                       "\ttest20: single integer\n"
+                       "\ttest21: fixed number (rank 1 array) of integers\n"
+                       "\ttest22: arbitrary number (rank 1 array) of integers\n"
+                       "\ttest23: fixed length rank 2 array of integers\n"
+                       "\ttest24: arbitrary length rank 2 array of integers\n"
+                       "\ttest25: data structure with a single integer\n"
+                       "\ttest26: data structure with a fixed number of integers\n"
+                       "\ttest27: data structure with a arbitrary number of integers\n"
+                       "\ttest28: array of data structures with a variety of integer types\n\n"
+
+                       "***test30-test32: double passing tests\n"
+                       "\ttest30: pair of doubles (Coordinate)\n"
+
+                       "***test40-test40: put data block receiving tests\n"
+
+                       "\ttest50: Passing parameters into plugins via the source argument\n"
+
+                       "\ttest60-62: ENUMLIST structures\n\n"
+
+                       "plugin: test calling other plugins\n"
+
+                       "error: Error reporting and server termination tests\n";
 
     initDataBlock(data_block);
 
@@ -393,147 +423,6 @@ static int do_help(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     return 0;
 }
 
-//----------------------------------------------------------------------------------------
-// Structure Definitions
-//----------------------------------------------------------------------------------------
-static void init_structure_definitions(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
-{
-
-    USERDEFINEDTYPE* old;
-
-    USERDEFINEDTYPE usertype;
-    initUserDefinedType(&usertype);            // New structure definition
-
-    strcpy(usertype.name, "TEST9");
-    strcpy(usertype.source, "Test #9");
-    usertype.ref_id = 0;
-    usertype.imagecount = 0;                // No Structure Image data
-    usertype.image = nullptr;
-    usertype.size = sizeof(TEST9);            // Structure size
-    usertype.idamclass = UDA_TYPE_COMPOUND;
-
-    int offset = 0;
-
-    COMPOUNDFIELD field;
-    initCompoundField(&field);
-    strcpy(field.name, "v1");
-    field.atomictype = UDA_TYPE_STRING;
-    strcpy(field.type, "STRING");            // convert atomic type to a string label
-    strcpy(field.desc, "string structure element: char [56]");
-    field.pointer = 0;
-    field.count = 56;
-    field.rank = 1;
-    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
-    field.shape[0] = field.count;
-    field.size = field.count * sizeof(char);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    offset = field.offset + field.size;    // Next Offset
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    initCompoundField(&field);
-    strcpy(field.name, "v2");
-    field.atomictype = UDA_TYPE_STRING;
-    strcpy(field.type, "STRING");            // convert atomic type to a string label
-    strcpy(field.desc, "string structure element: char [3][56]");
-    field.pointer = 0;
-    field.count = 3 * 56;
-    field.rank = 2;
-    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
-    field.shape[0] = 56;
-    field.shape[1] = 3;
-    field.size = field.count * sizeof(char);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    offset = field.offset + field.size;    // Next Offset
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    initCompoundField(&field);
-    strcpy(field.name, "v3");
-    field.atomictype = UDA_TYPE_STRING;
-    strcpy(field.type, "STRING");            // convert atomic type to a string label
-    strcpy(field.desc, "string structure element: char *");
-    field.pointer = 1;
-    field.count = 1;
-    field.rank = 0;
-    field.shape = nullptr;
-    field.size = field.count * sizeof(char*);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    offset = field.offset + field.size;    // Next Offset
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    initCompoundField(&field);
-    strcpy(field.name, "v4");
-    field.atomictype = UDA_TYPE_STRING;
-    strcpy(field.type, "STRING *");            // Array of String pointers
-    strcpy(field.desc, "string structure element: char *[3]");
-    field.pointer = 0;
-    field.count = 3;
-    field.rank = 1;
-    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
-    field.shape[0] = 3;
-    field.size = field.count * sizeof(char*);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    offset = field.offset + field.size;    // Next Offset
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    initCompoundField(&field);
-    strcpy(field.name, "v5");
-    field.atomictype = UDA_TYPE_STRING;
-    strcpy(field.type, "STRING *");                // Array of String pointers
-    strcpy(field.desc, "string structure element: char **");
-    field.pointer = 1;
-    field.count = 1;
-    field.rank = 0;
-    field.shape = nullptr;
-    field.size = field.count * sizeof(char**);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
-    addUserDefinedType(userdefinedtypelist, usertype);
-
-    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9 defined\n");
-
-    old = findUserDefinedType(userdefinedtypelist, "TEST9", 0);            // Clone existing structure & modify
-    copyUserDefinedType(old, &usertype);
-
-    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9 located\n");
-
-    strcpy(usertype.name, "TEST9A");
-    strcpy(usertype.source, "Test #9A");
-    usertype.size = sizeof(TEST9A);            // Structure size
-
-    offset = old->size;
-
-    initCompoundField(&field);
-    strcpy(field.name, "v6");
-    field.atomictype = UDA_TYPE_UNKNOWN;
-    strcpy(field.type, "TEST9");                // Array of String pointers
-    strcpy(field.desc, "string structure elements with sub structure");
-    field.pointer = 0;
-    field.count = 1;
-    field.rank = 0;
-    field.shape = nullptr;
-    field.size = field.count * sizeof(TEST9);
-    field.offset = newoffset(offset, field.type);
-    field.offpad = padding(offset, field.type);
-    field.alignment = getalignmentof(field.type);
-    addCompoundField(&usertype, field);        // Single Structure element
-
-    addUserDefinedType(userdefinedtypelist, usertype);
-
-    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9A defined\n");
-}
-
 static int do_test0(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
@@ -580,18 +469,17 @@ static int do_test2(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
     REQUEST_BLOCK* request_block = idam_plugin_interface->request_block;
 
+    // An array of strings can be formed in two distinct ways.
+    // 1> A fixed block of contiguous memory with each string beginning at a well defined regular location - as if each
+    //    string were the same length.
+    // 2> An array of string pointers: each string has its own length. Memory is not contiguous. This is the normal
+    //    representation of string arrays.
 
-// An array of strings can be formed in two distinct ways.
-// 1> A fixed block of contiguous memory with each string beginning at a well defined regular location - as if each
-//    string were the same length.
-// 2> An array of string pointers: each string has its own length. Memory is not contiguous. This is the normal
-//    representation of string arrays.
+    // To pass back the data as a block of chars/bytes or as type STRING, model 1 must be adopted - its how the middleware operates.
+    // By labeling the type as STRING, we can convert the data within the client to the correct type
 
-// To pass back the data as a block of chars/bytes or as type STRING, model 1 must be adopted - its how the middleware operates.
-// By labeling the type as STRING, we can convert the data within the client to the correct type
 
-
-// create original data using model 2
+    // create original data using model 2
 
     int sCount = 3;
     char** sarr = (char**)malloc(sCount * sizeof(char*));
@@ -606,7 +494,7 @@ static int do_test2(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     strcpy(sarr[1], "Qwerty keyboard");
     strcpy(sarr[2], "MAST Upgrade");
 
-// Maximum size of any individual string
+    // Maximum size of any individual string
 
     int sMax = 0;
     {
@@ -618,12 +506,12 @@ static int do_test2(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         }
     }
 
-// Create a block of contigous memory and assign all bytes to nullptr character
+    // Create a block of contigous memory and assign all bytes to nullptr character
 
     char* p = (char*)malloc(sMax * sCount * sizeof(char));
     memset(p, '\0', sMax * sCount);
 
-// Copy string data into the block positioned at regular intervals
+    // Copy string data into the block positioned at regular intervals
 
     {
         for (int i = 0; i < sCount; i++) {
@@ -631,7 +519,7 @@ static int do_test2(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         }
     }
 
-// Free original data
+    // Free original data
 
     {
         for (int i = 0; i < sCount; i++) {
@@ -684,7 +572,8 @@ static int do_test4(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test4 {
+    typedef struct Test4
+    {
         char value[56];
     } TEST4;
 
@@ -727,7 +616,7 @@ static int do_test4(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-// Create Data
+    // Create Data
 
     data = (TEST4*)malloc(sizeof(TEST4));            // Structured Data Must be a heap variable
     strcpy(data->value, "012345678901234567890");
@@ -755,7 +644,8 @@ static int do_test5(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test5 {
+    typedef struct Test5
+    {
         char value[3][56];
     } TEST5;
 
@@ -829,7 +719,8 @@ static int do_test6(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test6 {
+    typedef struct Test6
+    {
         char* value;
     } TEST6;
 
@@ -901,7 +792,8 @@ static int do_test7(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test7 {
+    typedef struct Test7
+    {
         char* value[3];                                     // 3 strings of arbitrary length
     } TEST7;
 
@@ -984,7 +876,8 @@ static int do_test8(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test8 {
+    typedef struct Test8
+    {
         char** value;                                   // arbitrary number of strings of arbitrary length
     } TEST8;
 
@@ -1275,7 +1168,8 @@ static int do_test11(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test11 {
+    typedef struct Test11
+    {
         int value;
     } TEST11;
 
@@ -1345,7 +1239,8 @@ static int do_test12(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test12 {
+    typedef struct Test12
+    {
         int value[3];
     } TEST12;
 
@@ -1417,7 +1312,8 @@ static int do_test13(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test13 {
+    typedef struct Test13
+    {
         int value[2][3];
     } TEST13;
 
@@ -1493,7 +1389,8 @@ static int do_test14(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test14 {
+    typedef struct Test14
+    {
         int* value;
     } TEST14;
 
@@ -1526,7 +1423,7 @@ static int do_test14(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     field.shape = nullptr;            // Needed when rank >= 1
 
-    field.size = field.count * sizeof(int *);
+    field.size = field.count * sizeof(int*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -1567,7 +1464,8 @@ static int do_test15(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test15 {
+    typedef struct Test15
+    {
         int* value;
     } TEST15;
 
@@ -1599,7 +1497,7 @@ static int do_test15(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(int *);
+    field.size = field.count * sizeof(int*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -1643,7 +1541,8 @@ static int do_test16(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test16 {
+    typedef struct Test16
+    {
         int* value;
     } TEST16;
 
@@ -1675,7 +1574,7 @@ static int do_test16(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(int *);
+    field.size = field.count * sizeof(int*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -1726,7 +1625,8 @@ static int do_test18(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test18 {
+    typedef struct Test18
+    {
         int value;
     } TEST18;
 
@@ -1813,7 +1713,8 @@ static int do_test19(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test19A {
+    typedef struct Test19A
+    {
         int value;
     } TEST19A;
 
@@ -1853,7 +1754,8 @@ static int do_test19(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-    typedef struct Test19 {
+    typedef struct Test19
+    {
         int value;
         TEST19A vals[7];
     } TEST19;
@@ -1985,7 +1887,8 @@ static int do_test21(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test21 {
+    typedef struct Test21
+    {
         short value;
     } TEST21;
 
@@ -2055,7 +1958,8 @@ static int do_test22(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test22 {
+    typedef struct Test22
+    {
         short value[3];
     } TEST22;
 
@@ -2127,7 +2031,8 @@ static int do_test23(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test23 {
+    typedef struct Test23
+    {
         short value[2][3];
     } TEST23;
 
@@ -2203,7 +2108,8 @@ static int do_test24(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test24 {
+    typedef struct Test24
+    {
         short* value;
     } TEST24;
 
@@ -2236,7 +2142,7 @@ static int do_test24(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     field.shape = nullptr;                                         // Needed when rank >= 1
 
-    field.size = field.count * sizeof(short *);
+    field.size = field.count * sizeof(short*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -2277,7 +2183,8 @@ static int do_test25(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test25 {
+    typedef struct Test25
+    {
         short* value;
     } TEST25;
 
@@ -2309,7 +2216,7 @@ static int do_test25(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(short *);
+    field.size = field.count * sizeof(short*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -2353,7 +2260,8 @@ static int do_test26(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test26 {
+    typedef struct Test26
+    {
         short* value;
     } TEST26;
 
@@ -2385,7 +2293,7 @@ static int do_test26(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(short *);
+    field.size = field.count * sizeof(short*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -2437,7 +2345,8 @@ static int do_test27(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test27 {
+    typedef struct Test27
+    {
         short value[2][3][4];
     } TEST27;
 
@@ -2535,7 +2444,8 @@ static int do_test28(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test28 {
+    typedef struct Test28
+    {
         short* value;
     } TEST28;
 
@@ -2567,7 +2477,7 @@ static int do_test28(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(short *);
+    field.size = field.count * sizeof(short*);
     field.offset = newoffset(offset, field.type);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -2638,7 +2548,8 @@ static int do_test30(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test30 {
+    typedef struct Test30
+    {
         double R;
         double Z;
     } TEST30;
@@ -2673,14 +2584,14 @@ static int do_test30(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-// Create Data
+    // Create Data
 
     data = (TEST30*)malloc(sizeof(TEST30));            // Structured Data Must be a heap variable
     data[0].R = 1.0;
     data[0].Z = 2.0;
     addMalloc(idam_plugin_interface->logmalloclist, (void*)data, 1, sizeof(TEST30), "TEST30");
 
-// Pass Data
+    // Pass Data
 
     data_block->data_type = UDA_TYPE_COMPOUND;
     data_block->rank = 0;
@@ -2702,7 +2613,8 @@ static int do_test31(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test30 {
+    typedef struct Test30
+    {
         double R;
         double Z;
     } TEST30;
@@ -2737,7 +2649,7 @@ static int do_test31(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-// Create Data
+    // Create Data
 
     int count = 100;
     data = (TEST30*)malloc(count * sizeof(TEST30));            // Structured Data Must be a heap variable
@@ -2759,7 +2671,7 @@ static int do_test31(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     addMalloc2(idam_plugin_interface->logmalloclist, (void*)data, count, sizeof(TEST30), "TEST30", rank, shape);
 
-// Pass Data
+    // Pass Data
 
     data_block->data_type = UDA_TYPE_COMPOUND;
     data_block->rank = 0;
@@ -2781,7 +2693,8 @@ static int do_test32(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test32A {
+    typedef struct Test32A
+    {
         double R;
         double Z;
     } TEST32A;
@@ -2814,7 +2727,8 @@ static int do_test32(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-    typedef struct Test32 {
+    typedef struct Test32
+    {
         int count;
         TEST32A coords[100];
     } TEST32;
@@ -2861,7 +2775,7 @@ static int do_test32(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     addUserDefinedType(userdefinedtypelist, usertype);
 
-// Create Data
+    // Create Data
 
     data_block->data_n = 1;
     data = (TEST32*)malloc(data_block->data_n * sizeof(TEST32));    // Structured Data Must be a heap variable
@@ -2874,7 +2788,7 @@ static int do_test32(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         data[0].coords[i].Z = 10.0 * i;
     }
 
-// Pass Data
+    // Pass Data
 
     data_block->data_type = UDA_TYPE_COMPOUND;
     data_block->rank = 0;
@@ -2896,7 +2810,8 @@ static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test33A {
+    typedef struct Test33A
+    {
         double R;
         double Z;
     } TEST33A;
@@ -2929,7 +2844,8 @@ static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-    typedef struct Test33 {
+    typedef struct Test33
+    {
         int count;
         TEST33A* coords;
     } TEST33;
@@ -2965,7 +2881,7 @@ static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(TEST33A *);
+    field.size = field.count * sizeof(TEST33A*);
     field.offset = offsetof(TEST33, coords);
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -2974,7 +2890,7 @@ static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
     addUserDefinedType(userdefinedtypelist, usertype);
 
-// Create Data
+    // Create Data
 
     data_block->data_n = 1;
     data = (TEST33*)malloc(data_block->data_n * sizeof(TEST33));    // Structured Data Must be a heap variable
@@ -2984,18 +2900,19 @@ static int do_test33(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data->coords = (TEST33A*)malloc(data->count * sizeof(TEST33A));
 
     int rank = 2;
-    int* shape = (int*)malloc(2 * sizeof(int));
+    auto shape = (int*)malloc(2 * sizeof(int));
     shape[0] = 5;
     shape[1] = 20;
 
-    addMalloc2(idam_plugin_interface->logmalloclist, (void*)data->coords, data->count, sizeof(TEST33A), "TEST33A", rank, shape);
+    addMalloc2(idam_plugin_interface->logmalloclist, (void*)data->coords, data->count, sizeof(TEST33A), "TEST33A", rank,
+               shape);
 
     for (int i = 0; i < data->count; i++) {
         data->coords[i].R = 1.0 * i;
         data->coords[i].Z = 10.0 * i;
     }
 
-// Pass Data
+    // Pass Data
 
     data_block->data_type = UDA_TYPE_COMPOUND;
     data_block->rank = 0;
@@ -3017,7 +2934,8 @@ static int do_test34(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
 
-    typedef struct Test33A {
+    typedef struct Test33A
+    {
         unsigned char* R;
         unsigned char* Z;
     } TEST33A;
@@ -3056,7 +2974,8 @@ static int do_test34(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
     addUserDefinedType(userdefinedtypelist, usertype);
 
-    typedef struct Test33 {
+    typedef struct Test33
+    {
         int count;
         TEST33A* coords;
     } TEST33;
@@ -3092,7 +3011,7 @@ static int do_test34(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     field.rank = 0;
     field.shape = nullptr;
 
-    field.size = field.count * sizeof(TEST33A *);
+    field.size = field.count * sizeof(TEST33A*);
     field.offset = (int)offsetof(TEST33, coords);
     field.offpad = (int)padding((size_t)offset, field.type);
     field.alignment = getalignmentof(field.type);
@@ -3115,14 +3034,17 @@ static int do_test34(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     shape[0] = 5;
     shape[1] = 20;
 
-    addMalloc2(idam_plugin_interface->logmalloclist, (void*)data->coords, data->count, sizeof(TEST33A), "TEST33A", rank, shape);
+    addMalloc2(idam_plugin_interface->logmalloclist, (void*)data->coords, data->count, sizeof(TEST33A), "TEST33A", rank,
+               shape);
 
     for (int i = 0; i < data->count; i++) {
         data->coords[i].R = (unsigned char*)malloc(10 * sizeof(unsigned char));
         data->coords[i].Z = (unsigned char*)malloc(10 * sizeof(unsigned char));
 
-        addMalloc(idam_plugin_interface->logmalloclist, (void*)data->coords[i].R, 10, sizeof(unsigned char), "unsigned char *");
-        addMalloc(idam_plugin_interface->logmalloclist, (void*)data->coords[i].Z, 10, sizeof(unsigned char), "unsigned char *");
+        addMalloc(idam_plugin_interface->logmalloclist, (void*)data->coords[i].R, 10, sizeof(unsigned char),
+                  "unsigned char *");
+        addMalloc(idam_plugin_interface->logmalloclist, (void*)data->coords[i].Z, 10, sizeof(unsigned char),
+                  "unsigned char *");
 
         for (int j = 0; j < 10; ++j) {
             data->coords[i].R[j] = (unsigned char)(1 * i);
@@ -3313,27 +3235,27 @@ static int do_test50(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
     DATA_BLOCK* data_block = idam_plugin_interface->data_block;
     REQUEST_BLOCK* request_block = idam_plugin_interface->request_block;
-    
+
     UDA_LOG(UDA_LOG_DEBUG, "TESTPLUGIN test50\n");
     printRequestBlock(*request_block);
-      
+
     // Return an array of strings with all passed parameters and substitutions
 
-    int count = 10*1024;
-    char *work = (char *)malloc(count*sizeof(char));
+    int count = 10 * 1024;
+    char* work = (char*)malloc(count * sizeof(char));
     work[0] = '\0';
 
     strcpy(work, "test50 passed parameters and substitutions\n");
     sprintf(&work[strlen(work)], "Shot number:%d\n", request_block->exp_number);
     sprintf(&work[strlen(work)], "Pass number:%d\n", request_block->pass);
-    sprintf(&work[strlen(work)], "substitution parameters:%s\n", request_block->tpass);	       
+    sprintf(&work[strlen(work)], "substitution parameters:%s\n", request_block->tpass);
     sprintf(&work[strlen(work)], "Number of name-value pairs: %d\n", request_block->nameValueList.pairCount);
     for (int i = 0; i < request_block->nameValueList.pairCount; i++)
-       sprintf(&work[strlen(work)], "name: %s, value: %s\n", request_block->nameValueList.nameValue[i].name,
-               request_block->nameValueList.nameValue[i].value);
-	       
+        sprintf(&work[strlen(work)], "name: %s, value: %s\n", request_block->nameValueList.nameValue[i].name,
+                request_block->nameValueList.nameValue[i].value);
+
     UDA_LOG(UDA_LOG_DEBUG, "test50: %s\n", work);
-	       
+
     initDataBlock(data_block);
 
     data_block->rank = 0;
@@ -3341,7 +3263,7 @@ static int do_test50(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data_block->data_type = UDA_TYPE_STRING;
     strcpy(data_block->data_desc, "testplugins:test50 = passing placeholders and substitution values to plugins");
 
-    data_block->data = (char *)work;
+    data_block->data = (char*)work;
 
     strcpy(data_block->data_label, "");
     strcpy(data_block->data_units, "");
@@ -3356,41 +3278,44 @@ static int do_test50(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 // A void pointer type is used as the placeholder in the structure 
 // When the type is known the structure definition can be created with the correct type
 // otherwise, an unsigned long long array can be returned as this will provide for all integer types. The application will have to deal with the type conversion.
- 
-typedef struct EnumMember60 {
+
+typedef struct EnumMember60
+{
     char name[MAXELEMENTNAME];      // The Enumeration member name
     long long value;                // The value of the member
 } ENUMMEMBER60;
 
-typedef struct EnumList60 {
-    char name[MAXELEMENTNAME];		// The Enumeration name
-    int type;				// The original integer base type
-    int count;				// The number of members of this enumeration class
-    ENUMMEMBER60* enummember;		// Array of enum members
-    void* arraydata;			// Generalised data pointer for all integer type arrays
+typedef struct EnumList60
+{
+    char name[MAXELEMENTNAME];        // The Enumeration name
+    int type;                // The original integer base type
+    int count;                // The number of members of this enumeration class
+    ENUMMEMBER60* enummember;        // Array of enum members
+    void* arraydata;            // Generalised data pointer for all integer type arrays
     int arraydata_rank;
     int arraydata_count;
-    int *arraydata_shape;
+    int* arraydata_shape;
 } ENUMLIST60;
- 
+
 static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
-    ENUMLIST60 *enumlist = (ENUMLIST60 *)malloc(sizeof(ENUMLIST60));
+    auto enumlist = (ENUMLIST60*)malloc(sizeof(ENUMLIST60));
     strcpy(enumlist->name, "TEST60 ENUM of type unsigned short");
     enumlist->type = UDA_TYPE_UNSIGNED_SHORT;
     enumlist->count = 3;
-    enumlist->enummember = (ENUMMEMBER60 *)malloc(enumlist->count*sizeof(ENUMMEMBER60));
+    enumlist->enummember = (ENUMMEMBER60*)malloc(enumlist->count * sizeof(ENUMMEMBER60));
     strcpy(enumlist->enummember[0].name, "ENUM Value 1");
     strcpy(enumlist->enummember[1].name, "ENUM Value 2");
     strcpy(enumlist->enummember[2].name, "ENUM Value 3");
-    enumlist->enummember[0].value = (long long) 1;
-    enumlist->enummember[1].value = (long long) 2;
-    enumlist->enummember[2].value = (long long) 3;
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist, 1, sizeof(ENUMLIST60), "ENUMLIST60");	    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER60), "ENUMMEMBER60");
- 
+    enumlist->enummember[0].value = (long long)1;
+    enumlist->enummember[1].value = (long long)2;
+    enumlist->enummember[2].value = (long long)3;
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist, 1, sizeof(ENUMLIST60), "ENUMLIST60");
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER60),
+              "ENUMMEMBER60");
+
     int count = 10;
-    unsigned short *data = (unsigned short *)malloc(count*sizeof(unsigned short));
+    auto data = (unsigned short*)malloc(count * sizeof(unsigned short));
     data[0] = 3;
     data[1] = 2;
     data[2] = 1;
@@ -3401,35 +3326,37 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data[7] = 2;
     data[8] = 3;
     data[9] = 2;
-    enumlist->arraydata = (void *)data;
+    enumlist->arraydata = (void*)data;
     enumlist->arraydata_rank = 1;
     enumlist->arraydata_count = count;
-    enumlist->arraydata_shape = (int *)malloc(sizeof(int));
+    enumlist->arraydata_shape = (int*)malloc(sizeof(int));
     enumlist->arraydata_shape[0] = count;
-    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *)enumlist->arraydata, count, sizeof(unsigned short), "unsigned short");
-    
+
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata, count, sizeof(unsigned short),
+              "unsigned short");
+
     count = 1;
     int rank = 1;
-    int shape[] = {1};		// Shape of the shape array!
-    addMalloc2(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata_shape, count, sizeof(int), "int", rank, shape);
-    
+    int shape[] = {1};        // Shape of the shape array!
+    addMalloc2(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata_shape, count, sizeof(int), "int", rank,
+               shape);
+
     USERDEFINEDTYPE usertype;
-    int offset;    
-    COMPOUNDFIELD field;    
-    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;   
-    
-    initUserDefinedType(&usertype);		// New structure definition
+    int offset;
+    COMPOUNDFIELD field;
+    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
+
+    initUserDefinedType(&usertype);        // New structure definition
     strcpy(usertype.name, "ENUMMEMBER60");
     strcpy(usertype.source, "Test #60 ENUMMEMBER structure");
     usertype.ref_id = 0;
-    usertype.imagecount = 0;			// No Structure Image data
+    usertype.imagecount = 0;            // No Structure Image data
     usertype.image = nullptr;
-    usertype.size = sizeof(ENUMMEMBER60);	// Structure size
+    usertype.size = sizeof(ENUMMEMBER60);    // Structure size
     usertype.idamclass = UDA_TYPE_COMPOUND;
 
     offset = 0;
-    
+
     initCompoundField(&field);
     strcpy(field.name, "name");
     field.atomictype = UDA_TYPE_STRING;
@@ -3451,20 +3378,19 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     defineField(&field, "value", "The ENUM value", &offset, SCALARLONG64);
     addCompoundField(&usertype, field);
 
-    addUserDefinedType(userdefinedtypelist, usertype);    
-     
+    addUserDefinedType(userdefinedtypelist, usertype);
 
-    initUserDefinedType(&usertype);		// New structure definition
+    initUserDefinedType(&usertype);        // New structure definition
     strcpy(usertype.name, "ENUMLIST60");
     strcpy(usertype.source, "Test #60 ENUMLIST structure");
     usertype.ref_id = 0;
-    usertype.imagecount = 0;			// No Structure Image data
+    usertype.imagecount = 0;            // No Structure Image data
     usertype.image = nullptr;
-    usertype.size = sizeof(ENUMLIST60);		// Structure size
+    usertype.size = sizeof(ENUMLIST60);        // Structure size
     usertype.idamclass = UDA_TYPE_COMPOUND;
 
     offset = 0;
-    
+
     initCompoundField(&field);
     strcpy(field.name, "name");
     field.atomictype = UDA_TYPE_STRING;
@@ -3490,57 +3416,50 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     initCompoundField(&field);
     defineField(&field, "count", "The number of ENUM values", &offset, SCALARINT);
     addCompoundField(&usertype, field);
-    
+
     initCompoundField(&field);
     strcpy(field.name, "enummember");
     field.atomictype = UDA_TYPE_UNKNOWN;
-    strcpy(field.type, "ENUMMEMBER60");  
+    strcpy(field.type, "ENUMMEMBER60");
     strcpy(field.desc, "The ENUM list members: labels and value");
     field.pointer = 1;
     field.count = 1;
     field.rank = 0;
     field.shape = nullptr;
-    field.size = sizeof(ENUMMEMBER60 *);
-    field.offset = offsetof(ENUMLIST60, enummember);		// Different to newoffset
+    field.size = sizeof(ENUMMEMBER60*);
+    field.offset = offsetof(ENUMLIST60, enummember);        // Different to newoffset
     offset = field.offset + field.size;
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
     addCompoundField(&usertype, field);
-     
-    initCompoundField(&field); 
-    switch(enumlist->type)
-    {
-       case(UDA_TYPE_UNSIGNED_SHORT):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYUSHORT);
-	  break;
-       }
-       case(UDA_TYPE_SHORT):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYSHORT);
-	  break;
-       }
-       case(UDA_TYPE_UNSIGNED_INT):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYUINT);
-	  break;
-       }
-       case(UDA_TYPE_INT):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYINT);
-	  break;
-       }
-       case(UDA_TYPE_UNSIGNED_LONG64):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYULONG64);
-	  break;
-       }
-       case(UDA_TYPE_LONG64):
-       {
-          defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYLONG64);
-	  break;
-       }
-    }     
+
+    initCompoundField(&field);
+    switch (enumlist->type) {
+        case (UDA_TYPE_UNSIGNED_SHORT): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYUSHORT);
+            break;
+        }
+        case (UDA_TYPE_SHORT): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYSHORT);
+            break;
+        }
+        case (UDA_TYPE_UNSIGNED_INT): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYUINT);
+            break;
+        }
+        case (UDA_TYPE_INT): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYINT);
+            break;
+        }
+        case (UDA_TYPE_UNSIGNED_LONG64): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYULONG64);
+            break;
+        }
+        case (UDA_TYPE_LONG64): {
+            defineField(&field, "arraydata", "The array of values defined by the ENUM", &offset, ARRAYLONG64);
+            break;
+        }
+    }
     addCompoundField(&usertype, field);
 
     initCompoundField(&field);
@@ -3554,9 +3473,8 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     addCompoundField(&usertype, field);
 
     addUserDefinedType(userdefinedtypelist, usertype);
-        
-        
-    DATA_BLOCK* data_block = idam_plugin_interface->data_block;	       
+
+    DATA_BLOCK* data_block = idam_plugin_interface->data_block;
     initDataBlock(data_block);
 
     data_block->rank = 0;
@@ -3564,7 +3482,7 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data_block->data_type = UDA_TYPE_COMPOUND;
     strcpy(data_block->data_desc, "testplugins:test60 = ENUM Values");
 
-    data_block->data = (char *)enumlist;
+    data_block->data = (char*)enumlist;
 
     data_block->opaque_type = UDA_OPAQUE_TYPE_STRUCTURES;
     data_block->opaque_count = 1;
@@ -3575,22 +3493,23 @@ static int do_test60(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
 static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
-    ENUMLIST60 *enumlist = (ENUMLIST60 *)malloc(sizeof(ENUMLIST60));
+    auto enumlist = (ENUMLIST60*)malloc(sizeof(ENUMLIST60));
     strcpy(enumlist->name, "TEST61 ENUM of type unsigned long long");
     enumlist->type = UDA_TYPE_UNSIGNED_SHORT;
     enumlist->count = 3;
-    enumlist->enummember = (ENUMMEMBER60 *)malloc(enumlist->count*sizeof(ENUMMEMBER60));
+    enumlist->enummember = (ENUMMEMBER60*)malloc(enumlist->count * sizeof(ENUMMEMBER60));
     strcpy(enumlist->enummember[0].name, "ENUM Value 1");
     strcpy(enumlist->enummember[1].name, "ENUM Value 2");
     strcpy(enumlist->enummember[2].name, "ENUM Value 3");
-    enumlist->enummember[0].value = (long long) 1;
-    enumlist->enummember[1].value = (long long) 2;
-    enumlist->enummember[2].value = (long long) 3;
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist, 1, sizeof(ENUMLIST60), "ENUMLIST60");	    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER60), "ENUMMEMBER60");
- 
+    enumlist->enummember[0].value = (long long)1;
+    enumlist->enummember[1].value = (long long)2;
+    enumlist->enummember[2].value = (long long)3;
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist, 1, sizeof(ENUMLIST60), "ENUMLIST60");
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER60),
+              "ENUMMEMBER60");
+
     int count = 10;
-    unsigned long long *data = (unsigned long long *)malloc(count*sizeof(unsigned long long));
+    auto data = (unsigned long long*)malloc(count * sizeof(unsigned long long));
     data[0] = 3;
     data[1] = 2;
     data[2] = 1;
@@ -3601,35 +3520,37 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data[7] = 2;
     data[8] = 3;
     data[9] = 2;
-    enumlist->arraydata = (void *)data;
+    enumlist->arraydata = (void*)data;
     enumlist->arraydata_rank = 1;
     enumlist->arraydata_count = count;
-    enumlist->arraydata_shape = (int *)malloc(sizeof(int));
+    enumlist->arraydata_shape = (int*)malloc(sizeof(int));
     enumlist->arraydata_shape[0] = count;
-    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *)enumlist->arraydata, count, sizeof(unsigned long long), "unsigned long long");
-    
+
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata, count, sizeof(unsigned long long),
+              "unsigned long long");
+
     count = 1;
     int rank = 1;
-    int shape[] = {1};		// Shape of the shape array!
-    addMalloc2(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata_shape, count, sizeof(int), "int", rank, shape);
-    
+    int shape[] = {1};        // Shape of the shape array!
+    addMalloc2(idam_plugin_interface->logmalloclist, (void*)enumlist->arraydata_shape, count, sizeof(int), "int", rank,
+               shape);
+
     USERDEFINEDTYPE usertype;
-    int offset;    
-    COMPOUNDFIELD field;    
-    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;   
-    
-    initUserDefinedType(&usertype);		// New structure definition
+    int offset;
+    COMPOUNDFIELD field;
+    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
+
+    initUserDefinedType(&usertype);        // New structure definition
     strcpy(usertype.name, "ENUMMEMBER60");
     strcpy(usertype.source, "Test #61 ENUMMEMBER structure");
     usertype.ref_id = 0;
-    usertype.imagecount = 0;			// No Structure Image data
+    usertype.imagecount = 0;            // No Structure Image data
     usertype.image = nullptr;
-    usertype.size = sizeof(ENUMMEMBER60);	// Structure size
+    usertype.size = sizeof(ENUMMEMBER60);    // Structure size
     usertype.idamclass = UDA_TYPE_COMPOUND;
 
     offset = 0;
-    
+
     initCompoundField(&field);
     strcpy(field.name, "name");
     field.atomictype = UDA_TYPE_STRING;
@@ -3651,20 +3572,20 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     defineField(&field, "value", "The ENUM value", &offset, SCALARLONG64);
     addCompoundField(&usertype, field);
 
-    addUserDefinedType(userdefinedtypelist, usertype);    
-     
+    addUserDefinedType(userdefinedtypelist, usertype);
+
 
-    initUserDefinedType(&usertype);		// New structure definition
+    initUserDefinedType(&usertype);        // New structure definition
     strcpy(usertype.name, "ENUMLIST60");
     strcpy(usertype.source, "Test #61 ENUMLIST structure");
     usertype.ref_id = 0;
-    usertype.imagecount = 0;			// No Structure Image data
+    usertype.imagecount = 0;            // No Structure Image data
     usertype.image = nullptr;
-    usertype.size = sizeof(ENUMLIST60);		// Structure size
+    usertype.size = sizeof(ENUMLIST60);        // Structure size
     usertype.idamclass = UDA_TYPE_COMPOUND;
 
     offset = 0;
-    
+
     initCompoundField(&field);
     strcpy(field.name, "name");
     field.atomictype = UDA_TYPE_STRING;
@@ -3689,25 +3610,26 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     initCompoundField(&field);
     defineField(&field, "count", "The number of ENUM values", &offset, SCALARINT);
     addCompoundField(&usertype, field);
-    
+
     initCompoundField(&field);
     strcpy(field.name, "enummember");
     field.atomictype = UDA_TYPE_UNKNOWN;
-    strcpy(field.type, "ENUMMEMBER60");  
+    strcpy(field.type, "ENUMMEMBER60");
     strcpy(field.desc, "The ENUM list members: labels and value");
     field.pointer = 1;
     field.count = 1;
     field.rank = 0;
     field.shape = nullptr;
-    field.size = sizeof(ENUMMEMBER60 *);
-    field.offset = offsetof(ENUMLIST60, enummember);		// Different to newoffset
+    field.size = sizeof(ENUMMEMBER60*);
+    field.offset = offsetof(ENUMLIST60, enummember);        // Different to newoffset
     offset = field.offset + field.size;
     field.offpad = padding(offset, field.type);
     field.alignment = getalignmentof(field.type);
     addCompoundField(&usertype, field);
-     
-    initCompoundField(&field); 
-    defineField(&field, "arraydata", "Data with this enumerated type", &offset, ARRAYULONG64);	// Data need to be converted to this type  
+
+    initCompoundField(&field);
+    defineField(&field, "arraydata", "Data with this enumerated type", &offset,
+                ARRAYULONG64);    // Data need to be converted to this type
     addCompoundField(&usertype, field);
     initCompoundField(&field);
     defineField(&field, "arraydata_rank", "The rank of arraydata", &offset, SCALARINT);
@@ -3720,9 +3642,9 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     addCompoundField(&usertype, field);
 
     addUserDefinedType(userdefinedtypelist, usertype);
-        
-        
-    DATA_BLOCK* data_block = idam_plugin_interface->data_block;	       
+
+
+    DATA_BLOCK* data_block = idam_plugin_interface->data_block;
     initDataBlock(data_block);
 
     data_block->rank = 0;
@@ -3730,7 +3652,7 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data_block->data_type = UDA_TYPE_COMPOUND;
     strcpy(data_block->data_desc, "testplugins:test61 = ENUM Values");
 
-    data_block->data = (char *)enumlist;
+    data_block->data = (char*)enumlist;
 
     data_block->opaque_type = UDA_OPAQUE_TYPE_STRUCTURES;
     data_block->opaque_count = 1;
@@ -3741,22 +3663,23 @@ static int do_test61(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 
 static int do_test62(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
 {
-    ENUMLIST *enumlist = (ENUMLIST *)malloc(sizeof(ENUMLIST));
+    auto* enumlist = (ENUMLIST*)malloc(sizeof(ENUMLIST));
     strcpy(enumlist->name, "TEST62 ENUM of type unsigned long long");
     enumlist->type = UDA_TYPE_UNSIGNED_SHORT;
     enumlist->count = 3;
-    enumlist->enummember = (ENUMMEMBER *)malloc(enumlist->count*sizeof(ENUMMEMBER));
+    enumlist->enummember = (ENUMMEMBER*)malloc(enumlist->count * sizeof(ENUMMEMBER));
     strcpy(enumlist->enummember[0].name, "ENUM Value 1");
     strcpy(enumlist->enummember[1].name, "ENUM Value 2");
     strcpy(enumlist->enummember[2].name, "ENUM Value 3");
-    enumlist->enummember[0].value = (long long) 1;
-    enumlist->enummember[1].value = (long long) 2;
-    enumlist->enummember[2].value = (long long) 3;
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist, 1, sizeof(ENUMLIST), "ENUMLIST");	    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *) enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER), "ENUMMEMBER");
- 
+    enumlist->enummember[0].value = (long long)1;
+    enumlist->enummember[1].value = (long long)2;
+    enumlist->enummember[2].value = (long long)3;
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist, 1, sizeof(ENUMLIST), "ENUMLIST");
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->enummember, enumlist->count, sizeof(ENUMMEMBER),
+              "ENUMMEMBER");
+
     int count = 10;
-    auto data = (unsigned long long *)malloc(count*sizeof(unsigned long long));
+    auto data = (unsigned long long*)malloc(count * sizeof(unsigned long long));
     data[0] = 3;
     data[1] = 2;
     data[2] = 1;
@@ -3770,17 +3693,18 @@ static int do_test62(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     enumlist->enumarray = data;
     enumlist->enumarray_rank = 1;
     enumlist->enumarray_count = count;
-    enumlist->enumarray_shape = (int *)malloc(sizeof(int));
+    enumlist->enumarray_shape = (int*)malloc(sizeof(int));
     enumlist->enumarray_shape[0] = count;
-    
-    addMalloc(idam_plugin_interface->logmalloclist, (void *)enumlist->enumarray, count, sizeof(unsigned long long), "unsigned long long");
-    
+
+    addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->enumarray, count, sizeof(unsigned long long),
+              "unsigned long long");
+
     //count = 1;
     //int rank = 1;
     //int shape[] = {1};		// Shape of the shape array!
     addMalloc(idam_plugin_interface->logmalloclist, (void*)enumlist->enumarray_shape, 1, sizeof(int), "int");
 
-    DATA_BLOCK* data_block = idam_plugin_interface->data_block;	       
+    DATA_BLOCK* data_block = idam_plugin_interface->data_block;
     initDataBlock(data_block);
 
     data_block->rank = 0;
@@ -3788,7 +3712,7 @@ static int do_test62(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     data_block->data_type = UDA_TYPE_COMPOUND;
     strcpy(data_block->data_desc, "testplugins:test62 = ENUM Values");
 
-    data_block->data = (char *)enumlist;
+    data_block->data = (char*)enumlist;
 
     data_block->opaque_type = UDA_OPAQUE_TYPE_STRUCTURES;
     data_block->opaque_count = 1;
@@ -3804,8 +3728,6 @@ static int do_test62(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     return 0;
 }
 
-
-
 //======================================================================================
 // Test direct calling of plugins from this plugin
 // A plugin only has a single instance on a server. For multiple instances, multiple servers are needed.
@@ -3820,7 +3742,7 @@ static int do_plugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
     int err = 0;
 
     IDAM_PLUGIN_INTERFACE next_plugin_interface;
-    REQUEST_BLOCK next_request_block = { 0 };
+    REQUEST_BLOCK next_request_block = {0};
 
     const PLUGINLIST* pluginList = idam_plugin_interface->pluginList;
 
@@ -3828,7 +3750,7 @@ static int do_plugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         RAISE_PLUGIN_ERROR("No plugins available for this data request");
     }
 
-// Test specifics
+    // Test specifics
 
     const char* signal = nullptr;
     const char* source = nullptr;
@@ -3846,7 +3768,7 @@ static int do_plugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
         strcpy(next_request_block.signal, signal);
         strcpy(next_request_block.source, source);
 
-        makeRequestBlock(&next_request_block, *pluginList, idam_plugin_interface->environment);
+        make_request_block(&next_request_block, *pluginList, idam_plugin_interface->environment);
 
         for (int i = 0; i < pluginList->count; i++) {
             if (next_request_block.request == pluginList->plugin[i].request) {
@@ -3860,7 +3782,7 @@ static int do_plugin(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
             }
         }
 
-        freeNameValueList(&next_request_block.nameValueList);
+        free_name_value_list(&next_request_block.nameValueList);
     }
 
     return err;
@@ -3895,10 +3817,10 @@ static int do_errortest(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
             return err;
         case 3: {
             const char* p = "crash!";        // force a server crash! (write to read-only memory)
-            *(char*)p = '*';
+            *const_cast<char*>(p) = '*';
 
             p = nullptr;
-            free((void*)p);
+            free(const_cast<void*>(reinterpret_cast<const void*>(p)));
 
             int* p2 = nullptr;
             *p2 = 1;
diff --git a/source/plugins/testplugin/testplugin.h b/source/plugins/testplugin/testplugin.h
index 9b9b394c..d4080529 100755
--- a/source/plugins/testplugin/testplugin.h
+++ b/source/plugins/testplugin/testplugin.h
@@ -2,13 +2,7 @@
 #define UDA_PLUGIN_TESTPLUGIN_TESTPLUGIN_H
 
 #include <plugins/udaPlugin.h>
-
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -31,7 +25,6 @@ LIBRARY_API int tcp_connect(SYSSOCKET *ssock, int port);
 LIBRARY_API int c_connect(UDTSOCKET *usock, int port);
 LIBRARY_API int createUDTSocket(int *usock, int port, int rendezvous);
 LIBRARY_API int createTCPSocket(SYSSOCKET *ssock, int port, bool rendezvous);
-     
 #endif
 
 extern int testplugin(IDAM_PLUGIN_INTERFACE *idam_plugin_interface);
diff --git a/source/plugins/testplugin/teststructs.cpp b/source/plugins/testplugin/teststructs.cpp
new file mode 100644
index 00000000..2974a0ad
--- /dev/null
+++ b/source/plugins/testplugin/teststructs.cpp
@@ -0,0 +1,141 @@
+#include "teststructs.h"
+
+#include <structures/struct.h>
+#include <logging/logging.h>
+
+void init_structure_definitions(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
+{
+    USERDEFINEDTYPE* old;
+
+    USERDEFINEDTYPE usertype;
+    initUserDefinedType(&usertype);            // New structure definition
+
+    strcpy(usertype.name, "TEST9");
+    strcpy(usertype.source, "Test #9");
+    usertype.ref_id = 0;
+    usertype.imagecount = 0;                // No Structure Image data
+    usertype.image = nullptr;
+    usertype.size = sizeof(TEST9);            // Structure size
+    usertype.idamclass = UDA_TYPE_COMPOUND;
+
+    int offset = 0;
+
+    COMPOUNDFIELD field;
+    initCompoundField(&field);
+    strcpy(field.name, "v1");
+    field.atomictype = UDA_TYPE_STRING;
+    strcpy(field.type, "STRING");            // convert atomic type to a string label
+    strcpy(field.desc, "string structure element: char [56]");
+    field.pointer = 0;
+    field.count = 56;
+    field.rank = 1;
+    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
+    field.shape[0] = field.count;
+    field.size = field.count * sizeof(char);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    offset = field.offset + field.size;    // Next Offset
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    initCompoundField(&field);
+    strcpy(field.name, "v2");
+    field.atomictype = UDA_TYPE_STRING;
+    strcpy(field.type, "STRING");            // convert atomic type to a string label
+    strcpy(field.desc, "string structure element: char [3][56]");
+    field.pointer = 0;
+    field.count = 3 * 56;
+    field.rank = 2;
+    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
+    field.shape[0] = 56;
+    field.shape[1] = 3;
+    field.size = field.count * sizeof(char);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    offset = field.offset + field.size;    // Next Offset
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    initCompoundField(&field);
+    strcpy(field.name, "v3");
+    field.atomictype = UDA_TYPE_STRING;
+    strcpy(field.type, "STRING");            // convert atomic type to a string label
+    strcpy(field.desc, "string structure element: char *");
+    field.pointer = 1;
+    field.count = 1;
+    field.rank = 0;
+    field.shape = nullptr;
+    field.size = field.count * sizeof(char*);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    offset = field.offset + field.size;    // Next Offset
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    initCompoundField(&field);
+    strcpy(field.name, "v4");
+    field.atomictype = UDA_TYPE_STRING;
+    strcpy(field.type, "STRING *");            // Array of String pointers
+    strcpy(field.desc, "string structure element: char *[3]");
+    field.pointer = 0;
+    field.count = 3;
+    field.rank = 1;
+    field.shape = (int*)malloc(field.rank * sizeof(int));        // Needed when rank >= 1
+    field.shape[0] = 3;
+    field.size = field.count * sizeof(char*);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    offset = field.offset + field.size;    // Next Offset
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    initCompoundField(&field);
+    strcpy(field.name, "v5");
+    field.atomictype = UDA_TYPE_STRING;
+    strcpy(field.type, "STRING *");                // Array of String pointers
+    strcpy(field.desc, "string structure element: char **");
+    field.pointer = 1;
+    field.count = 1;
+    field.rank = 0;
+    field.shape = nullptr;
+    field.size = field.count * sizeof(char**);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    USERDEFINEDTYPELIST* userdefinedtypelist = idam_plugin_interface->userdefinedtypelist;
+    addUserDefinedType(userdefinedtypelist, usertype);
+
+    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9 defined\n");
+
+    old = findUserDefinedType(userdefinedtypelist, "TEST9", 0);            // Clone existing structure & modify
+    copyUserDefinedType(old, &usertype);
+
+    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9 located\n");
+
+    strcpy(usertype.name, "TEST9A");
+    strcpy(usertype.source, "Test #9A");
+    usertype.size = sizeof(TEST9A);            // Structure size
+
+    offset = old->size;
+
+    initCompoundField(&field);
+    strcpy(field.name, "v6");
+    field.atomictype = UDA_TYPE_UNKNOWN;
+    strcpy(field.type, "TEST9");                // Array of String pointers
+    strcpy(field.desc, "string structure elements with sub structure");
+    field.pointer = 0;
+    field.count = 1;
+    field.rank = 0;
+    field.shape = nullptr;
+    field.size = field.count * sizeof(TEST9);
+    field.offset = newoffset(offset, field.type);
+    field.offpad = padding(offset, field.type);
+    field.alignment = getalignmentof(field.type);
+    addCompoundField(&usertype, field);        // Single Structure element
+
+    addUserDefinedType(userdefinedtypelist, usertype);
+
+    UDA_LOG(UDA_LOG_DEBUG, "Type TEST9A defined\n");
+}
\ No newline at end of file
diff --git a/source/plugins/testplugin/teststructs.h b/source/plugins/testplugin/teststructs.h
new file mode 100644
index 00000000..31dc9ce5
--- /dev/null
+++ b/source/plugins/testplugin/teststructs.h
@@ -0,0 +1,27 @@
+#ifndef UDA_PLUGIN_TESTPLUGIN_TESTSTRUCTS_H
+#define UDA_PLUGIN_TESTPLUGIN_TESTSTRUCTS_H
+
+#include <plugins/pluginStructs.h>
+
+typedef struct Test9
+{
+    char v1[56];        // single fixed length string
+    char v2[3][56];     // 3 fixed length strings
+    char* v3;           // single arbitrary length string
+    char* v4[3];        // 3 strings of arbitrary length
+    char** v5;          // arbitrary number of strings of arbitrary length
+} TEST9;
+
+typedef struct Test9A
+{
+    char v1[56];        // single fixed length string
+    char v2[3][56];     // 3 fixed length strings
+    char* v3;           // single arbitrary length string
+    char* v4[3];        // 3 strings of arbitrary length
+    char** v5;          // arbitrary number of strings of arbitrary length
+    TEST9 v6;           // Sub Structure with String types
+} TEST9A;
+
+void init_structure_definitions(IDAM_PLUGIN_INTERFACE* idam_plugin_interface);
+
+#endif // UDA_PLUGIN_TESTPLUGIN_TESTSTRUCTS_H
diff --git a/source/plugins/uda/CMakeLists.txt b/source/plugins/uda/CMakeLists.txt
index 0ffd6d8c..9adf34ed 100755
--- a/source/plugins/uda/CMakeLists.txt
+++ b/source/plugins/uda/CMakeLists.txt
@@ -11,6 +11,12 @@ endif()
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
   include_directories( ${XDR_INCLUDE_DIR} )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    include_directories( ${TIRPC_INCLUDE_DIR} )
+  endif()
 endif()
 
 include( plugins )
diff --git a/source/plugins/uda/uda_plugin.h b/source/plugins/uda/uda_plugin.h
index a6a6cd7f..3bdd33f8 100755
--- a/source/plugins/uda/uda_plugin.h
+++ b/source/plugins/uda/uda_plugin.h
@@ -2,12 +2,7 @@
 #define UDA_PLUGIN_UDA_PLUGIN_H
 
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/udaPlugin.cpp b/source/plugins/udaPlugin.cpp
index 58b38826..7322d543 100644
--- a/source/plugins/udaPlugin.cpp
+++ b/source/plugins/udaPlugin.cpp
@@ -1,17 +1,13 @@
 #include "udaPlugin.h"
 
-#include <errno.h>
-
 #include <clientserver/makeRequestBlock.h>
 #include <clientserver/stringUtils.h>
 #include <clientserver/initStructs.h>
 #include <clientserver/udaTypes.h>
-#include <clientserver/protocol.h>
 
 int initPlugin(const IDAM_PLUGIN_INTERFACE* plugin_interface)
 {
-    idamSetLogLevel((LOG_LEVEL)plugin_interface->environment->loglevel);
-
+    udaSetLogLevel((LOG_LEVEL)plugin_interface->environment->loglevel);
     return 0;
 }
 
@@ -313,7 +309,9 @@ int findPluginIdByDevice(const char* device, const PLUGINLIST* plugin_list)
 int findPluginRequestByFormat(const char* format, const PLUGINLIST* plugin_list)
 {
     for (int i = 0; i < plugin_list->count; i++) {
-        if (STR_IEQUALS(plugin_list->plugin[i].format, format)) return plugin_list->plugin[i].request;
+        if (STR_IEQUALS(plugin_list->plugin[i].format, format)) {
+            return plugin_list->plugin[i].request;
+        }
     }
     return REQUEST_READ_UNKNOWN;
 }
@@ -327,7 +325,9 @@ int findPluginRequestByFormat(const char* format, const PLUGINLIST* plugin_list)
 int findPluginRequestByExtension(const char* extension, const PLUGINLIST* plugin_list)
 {
     for (int i = 0; i < plugin_list->count; i++) {
-        if (STR_IEQUALS(plugin_list->plugin[i].extension, extension)) return plugin_list->plugin[i].request;
+        if (STR_IEQUALS(plugin_list->plugin[i].extension, extension)) {
+            return plugin_list->plugin[i].request;
+        }
     }
     return REQUEST_READ_UNKNOWN;
 }
@@ -534,11 +534,10 @@ int callPlugin(const PLUGINLIST* pluginlist, const char* request, const IDAM_PLU
 
     request_block.source[0] = '\0';
     strcpy(request_block.signal, request);
-    makeRequestBlock(&request_block, *pluginlist, old_plugin_interface->environment);
+    make_request_block(&request_block, *pluginlist, old_plugin_interface->environment);
 
     request_block.request = findPluginRequestByFormat(request_block.format, pluginlist);
-
-    if (request_block.request < 0) {
+    if (request_block.request == REQUEST_READ_UNKNOWN) {
         RAISE_PLUGIN_ERROR("Plugin not found!");
     }
 
diff --git a/source/plugins/udaPlugin.h b/source/plugins/udaPlugin.h
index 03524c0a..3dac7f22 100755
--- a/source/plugins/udaPlugin.h
+++ b/source/plugins/udaPlugin.h
@@ -7,12 +7,7 @@
 #include <logging/logging.h>
 #include <clientserver/errorLog.h>
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -32,63 +27,36 @@ extern "C" {
 #define UDA_PLUGIN_PRIVATE       1           // Only internal users can use the service (access the data!)
 #define UDA_PLUGIN_PUBLIC        0           // All users - internal and external - can use the service
 
-// SQL Connection Types
-
-#define PLUGINSQLNOTKNOWN   0
-#define PLUGINSQLPOSTGRES   1
-#define PLUGINSQLMYSQL      2
-#define PLUGINSQLMONGODB    3
-
-typedef void (* ADDIDAMERRORFUNP)(IDAMERRORSTACK*, int, char*, int, char*);   // Write to the Error Log
+typedef void (* ADDIDAMERRORFUNP)(UDA_ERROR_STACK*, int, char*, int, char*);   // Write to the Error Log
 
 // Prototypes
 
 LIBRARY_API int callPlugin(const PLUGINLIST* pluginlist, const char* request, const IDAM_PLUGIN_INTERFACE* old_plugin_interface);
 
 LIBRARY_API int findPluginIdByRequest(int request, const PLUGINLIST* plugin_list);
-
 LIBRARY_API int findPluginIdByFormat(const char* format, const PLUGINLIST* plugin_list);
-
 LIBRARY_API int findPluginIdByDevice(const char* device, const PLUGINLIST* plugin_list);
-
 LIBRARY_API int findPluginRequestByFormat(const char* format, const PLUGINLIST* plugin_list);
-
 LIBRARY_API int findPluginRequestByExtension(const char* extension, const PLUGINLIST* plugin_list);
 
 LIBRARY_API int setReturnDataFloatArray(DATA_BLOCK* data_block, float* values, size_t rank, const size_t* shape, const char* description);
-
 LIBRARY_API int setReturnDataDoubleArray(DATA_BLOCK* data_block, double* values, size_t rank, const size_t* shape, const char* description);
-
 LIBRARY_API int setReturnDataIntArray(DATA_BLOCK* data_block, int* values, size_t rank, const size_t* shape, const char* description);
-
 LIBRARY_API int setReturnDataDoubleScalar(DATA_BLOCK* data_block, double value, const char* description);
-
 LIBRARY_API int setReturnDataFloatScalar(DATA_BLOCK* data_block, float value, const char* description);
-
 LIBRARY_API int setReturnDataIntScalar(DATA_BLOCK* data_block, int value, const char* description);
-
 LIBRARY_API int setReturnDataLongScalar(DATA_BLOCK* data_block, long value, const char* description);
-
 LIBRARY_API int setReturnDataShortScalar(DATA_BLOCK* data_block, short value, const char* description);
-
 LIBRARY_API int setReturnDataString(DATA_BLOCK* data_block, const char* value, const char* description);
 
 LIBRARY_API bool findStringValue(const NAMEVALUELIST* namevaluelist, const char** value, const char* name);
-
 LIBRARY_API bool findValue(const NAMEVALUELIST* namevaluelist, const char* name);
-
 LIBRARY_API bool findIntValue(const NAMEVALUELIST* namevaluelist, int* value, const char* name);
-
 LIBRARY_API bool findShortValue(const NAMEVALUELIST* namevaluelist, short* value, const char* name);
-
 LIBRARY_API bool findCharValue(const NAMEVALUELIST* namevaluelist, char* value, const char* name);
-
 LIBRARY_API bool findFloatValue(const NAMEVALUELIST* namevaluelist, float* values, const char* name);
-
 LIBRARY_API bool findIntArray(const NAMEVALUELIST* namevaluelist, int** values, size_t* nvalues, const char* name);
-
 LIBRARY_API bool findFloatArray(const NAMEVALUELIST* namevaluelist, float** values, size_t* nvalues, const char* name);
-
 LIBRARY_API bool findDoubleArray(const NAMEVALUELIST* namevaluelist, double** values, size_t* nvalues, const char* name);
 
 #define QUOTE_(X) #X
diff --git a/source/plugins/udaPluginFiles.h b/source/plugins/udaPluginFiles.h
index 8ce64545..e997cfe4 100755
--- a/source/plugins/udaPluginFiles.h
+++ b/source/plugins/udaPluginFiles.h
@@ -9,12 +9,7 @@
 #endif
 
 #include <clientserver/udaDefines.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/plugins/viewport/CMakeLists.txt b/source/plugins/viewport/CMakeLists.txt
index a5d279ef..48aa6039 100755
--- a/source/plugins/viewport/CMakeLists.txt
+++ b/source/plugins/viewport/CMakeLists.txt
@@ -11,6 +11,12 @@ endif()
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
   include_directories( ${XDR_INCLUDE_DIR} )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    include_directories( ${TIRPC_INCLUDE_DIR} )
+  endif()
 endif()
 
 include( plugins )
diff --git a/source/plugins/viewport/viewport.cpp b/source/plugins/viewport/viewport.cpp
index b3a4106d..c312598c 100755
--- a/source/plugins/viewport/viewport.cpp
+++ b/source/plugins/viewport/viewport.cpp
@@ -538,15 +538,15 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                         }
 
                         count = newCount;
-                        free((void*)values);
-                        free((void*)coords);
+                        free(values);
+                        free(coords);
 
                         values = newValues;
                         coords = newCoords;
 
                     }
 
-                    free((void*)remove);
+                    free(remove);
                 }
 
                 // Reduce data to fix the device coordinates (relative pixels)
@@ -658,10 +658,10 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                         UDA_LOG(UDA_LOG_DEBUG, "[%d] %d\n", i, frtot[i]);
                     }
 
-                    free((void*)column);
-                    free((void*)row);
-                    free((void*)fctot);
-                    free((void*)frtot);
+                    free(column);
+                    free(row);
+                    free(fctot);
+                    free(frtot);
 
                     // Build return values
 
@@ -780,7 +780,7 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                             goodCount++;
                         }
 
-                        free((void*)freq[i]);
+                        free(freq[i]);
 
                         if (i == 0) {
                             UDA_LOG(UDA_LOG_DEBUG, "&data = %p\n", data);
@@ -799,12 +799,12 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                     }
                     // Free allocated heap
 
-                    free((void*)values);
-                    free((void*)coords);
-                    free((void*)freq);
-                    free((void*)verticalPixelValues);
-                    free((void*)verticalPixelBoundaries);
-                    free((void*)integral);
+                    free(values);
+                    free(coords);
+                    free(freq);
+                    free(verticalPixelValues);
+                    free(verticalPixelBoundaries);
+                    free(integral);
 
                     // data, errhi, errlo, horizontalPixelValues heap freed once the server transmits the data
                     // heap within the idam layer is freed on reset or clearCache or if the cache fills
@@ -827,12 +827,12 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                                 ID++;
                             }
                         }
-                        free((void*)good);
+                        free(good);
 
-                        free((void*)data);
-                        free((void*)errlo);
-                        free((void*)errhi);
-                        free((void*)horizontalPixelValues);
+                        free(data);
+                        free(errlo);
+                        free(errhi);
+                        free(horizontalPixelValues);
 
                         data = newData;
                         errlo = newErrlo;
@@ -877,7 +877,7 @@ extern int viewport(IDAM_PLUGIN_INTERFACE* idam_plugin_interface)
                         data_block->errasymmetry = 1;
                         data_block->errlo = (char*)errlo;
                     } else {
-                        free((void*)errlo);
+                        free(errlo);
                     }
                     data_block->errhi = (char*)errhi;
                     data_block->error_type = UDA_TYPE_FLOAT;
diff --git a/source/plugins/viewport/viewport.h b/source/plugins/viewport/viewport.h
index d7fd6adf..b7dd76c6 100755
--- a/source/plugins/viewport/viewport.h
+++ b/source/plugins/viewport/viewport.h
@@ -2,12 +2,7 @@
 #define IDAM_PLUGINS_VIEWPORT_VIEWPORT_H
 
 #include <plugins/udaPlugin.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/security/authenticationUtils.h b/source/security/authenticationUtils.h
index 1aee313a..6944df4e 100755
--- a/source/security/authenticationUtils.h
+++ b/source/security/authenticationUtils.h
@@ -2,12 +2,7 @@
 #define UDA_SECURITY_AUTHENTICATIONUTILS_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/security/clientAuthentication.cpp b/source/security/clientAuthentication.cpp
index f2cb1e11..ef9256fa 100755
--- a/source/security/clientAuthentication.cpp
+++ b/source/security/clientAuthentication.cpp
@@ -198,8 +198,8 @@ static int initialiseKeys(CLIENT_BLOCK* client_block, gcry_sexp_t* publickey_out
     free(client2X509File);
 
     if (err != 0) {
-        free((void*)securityBlock->client_X509);
-        free((void*)securityBlock->client2_X509);
+        free(securityBlock->client_X509);
+        free(securityBlock->client2_X509);
 
         securityBlock->client_X509 = nullptr;
         securityBlock->client2_X509 = nullptr;
@@ -279,8 +279,8 @@ static int issueToken(CLIENT_BLOCK* client_block, LOGMALLOCLIST* logmalloclist,
     securityBlock->client_ciphertext = nullptr;
     securityBlock->client_ciphertextLength = 0;
 
-    free((void*)securityBlock->client_X509);
-    free((void*)securityBlock->client2_X509);
+    free(securityBlock->client_X509);
+    free(securityBlock->client2_X509);
 
     securityBlock->client_X509 = nullptr;
     securityBlock->client2_X509 = nullptr;
@@ -362,8 +362,8 @@ static int decryptServerToken(SERVER_BLOCK* server_block, CLIENT_BLOCK* client_b
         THROW_ERROR(err, "Failed Authentication Step #5!");
     }
 
-    free((void*)client_ciphertext);
-    free((void*)server_ciphertext);
+    free(client_ciphertext);
+    free(server_ciphertext);
 
     return err;
 }
@@ -416,8 +416,8 @@ static int encryptServerToken(CLIENT_BLOCK* client_block, LOGMALLOCLIST* logmall
         THROW_ERROR(PROTOCOL_ERROR_7, "Protocol 7 Error (Client Block #6)");
     }
 
-    free((void*)server_ciphertext);
-    free((void*)client_ciphertext);
+    free(server_ciphertext);
+    free(client_ciphertext);
 #endif
 
     return err;
@@ -451,8 +451,8 @@ int clientAuthentication(CLIENT_BLOCK* client_block, SERVER_BLOCK* server_block,
             break;
 
         case HOUSEKEEPING:
-            free((void*)publickey);
-            free((void*)privatekey);
+            free(publickey);
+            free(privatekey);
             if (client_mpiToken != nullptr) gcry_mpi_release(client_mpiToken);
             if (server_mpiToken != nullptr) gcry_mpi_release(server_mpiToken);
             break;
diff --git a/source/security/clientAuthentication.h b/source/security/clientAuthentication.h
index 229e81c9..44275a8b 100755
--- a/source/security/clientAuthentication.h
+++ b/source/security/clientAuthentication.h
@@ -1,17 +1,12 @@
 #ifndef UDA_SECURITY_CLIENTAUTHENTICATION_H
 #define UDA_SECURITY_CLIENTAUTHENTICATION_H
 
+#include <clientserver/export.h>
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
 
 #include "security.h"
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/security/security.cpp b/source/security/security.cpp
index d1075481..a7ecdee0 100755
--- a/source/security/security.cpp
+++ b/source/security/security.cpp
@@ -98,7 +98,7 @@ static void logToken(const char* msg, const gcry_mpi_t mpi_token)
 
     gcry_mpi_aprint(GCRYMPI_FMT_HEX, &token, &tokenLength, mpi_token);
     UDA_LOG(UDA_LOG_DEBUG, "%s MPI [%d] %s\n", msg, tokenLength, token);
-    free((void*)token);
+    free(token);
 }
 
 /**
@@ -166,18 +166,18 @@ static int createMPIToken(unsigned short tokenType, unsigned short tokenByteLeng
             // Create an MPI from both the time and the quasi-random list
             gcry_mpi_t timeData;
             if (gcry_mpi_scan(&timeData, GCRYMPI_FMT_USG, timeList, timeLength, nullptr) != 0) {
-                free((void*)randList);
+                free(randList);
                 THROW_ERROR(999, "Unable to generate MPI Token");
             }
 
             gcry_mpi_t randData;
             if (gcry_mpi_scan(&randData, GCRYMPI_FMT_USG, randList, tokenByteLength, nullptr) != 0) {
                 gcry_mpi_release(timeData);
-                free((void*)randList);
+                free(randList);
                 THROW_ERROR(999, "Unable to generate MPI Token");
             }
 
-            free((void*)randList);
+            free(randList);
 
             // Multiply to generate a token
             *mpiToken = gcry_mpi_new(0);
diff --git a/source/security/security.h b/source/security/security.h
index 7345fcbb..d04684ec 100755
--- a/source/security/security.h
+++ b/source/security/security.h
@@ -2,12 +2,7 @@
 #define UDA_SECURITY_SECURITY_H
 
 #include <gcrypt.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/security/serverAuthentication.cpp b/source/security/serverAuthentication.cpp
index 24ace424..67d622ff 100755
--- a/source/security/serverAuthentication.cpp
+++ b/source/security/serverAuthentication.cpp
@@ -220,10 +220,10 @@ static int decryptClientToken(CLIENT_BLOCK* client_block, LOGMALLOCLIST* logmall
         THROW_ERROR(err, "Failed Decryption Step #2!");
     }
 
-    free((void*)client_ciphertext);
+    free(client_ciphertext);
     client_ciphertext = nullptr;
     client_ciphertextLength = 0;
-    free((void*)server_ciphertext);
+    free(server_ciphertext);
     server_ciphertext = nullptr;
     server_ciphertextLength = 0;
 
@@ -427,8 +427,8 @@ int serverAuthentication(CLIENT_BLOCK* client_block, SERVER_BLOCK* server_block,
             break;
 
         case HOUSEKEEPING:
-            free((void*)privatekey);
-            free((void*)publickey);
+            free(privatekey);
+            free(publickey);
             if (client_mpiToken != nullptr) gcry_mpi_release(client_mpiToken);
             if (server_mpiToken != nullptr) gcry_mpi_release(server_mpiToken);
             break;
diff --git a/source/security/serverAuthentication.h b/source/security/serverAuthentication.h
index 1702dfab..f87d1e64 100755
--- a/source/security/serverAuthentication.h
+++ b/source/security/serverAuthentication.h
@@ -1,17 +1,12 @@
 #ifndef UDA_SECURITY_SERVERAUTHENTICATION_H
 #define UDA_SECURITY_SERVERAUTHENTICATION_H
 
+#include <clientserver/export.h>
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
 
 #include "security.h"
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/security/x509Utils.h b/source/security/x509Utils.h
index ecba38aa..0f964e05 100755
--- a/source/security/x509Utils.h
+++ b/source/security/x509Utils.h
@@ -4,11 +4,7 @@
 #include <ksba.h>
 #include <gcrypt.h>
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/CMakeLists.txt b/source/server/CMakeLists.txt
index 4ac659d7..ba0da359 100755
--- a/source/server/CMakeLists.txt
+++ b/source/server/CMakeLists.txt
@@ -9,6 +9,11 @@ if( WIN32 OR MINGW )
   if( NOT MINGW )
     find_package( dlfcn-win32 CONFIG REQUIRED )
   endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)    
+  endif()
 endif()
 
 ########################################################################################################################
@@ -17,7 +22,6 @@ endif()
 set( SRC_FILES
   applyXML.cpp
   closeServerSockets.cpp
-  dumpFile.cpp
   freeIdamPut.cpp
   getPluginAddress.cpp
   getServerEnvironment.cpp
@@ -36,7 +40,6 @@ set( HEADER_FILES
   applyXML.h
   closeServerSockets.h
   createXDRStream.h
-  dumpFile.h
   freeIdamPut.h
   getPluginAddress.h
   getServerEnvironment.h
@@ -105,6 +108,9 @@ if( WIN32 OR MINGW )
   endif()
   include_directories( ${XDR_INCLUDE_DIR} )
   set( LINK_XDR ${XDR_LIBRARIES} ws2_32 )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
+  set( LINK_XDR ${LINK_XDR} ${TIRPC_LIBRARIES})
 endif()
 
 target_link_libraries( server-static PRIVATE ${LINK_XDR} )
diff --git a/source/server/applyXML.cpp b/source/server/applyXML.cpp
index 747ebc2f..2d58f97b 100755
--- a/source/server/applyXML.cpp
+++ b/source/server/applyXML.cpp
@@ -21,8 +21,8 @@
 #include <clientserver/udaTypes.h>
 #include <clientserver/stringUtils.h>
 
-int idamserverParseSignalXML(DATA_SOURCE data_source, SIGNAL signal, SIGNAL_DESC signal_desc,
-                             ACTIONS* actions_desc, ACTIONS* actions_sig)
+int serverParseSignalXML(DATA_SOURCE data_source, SIGNAL signal, SIGNAL_DESC signal_desc,
+                         ACTIONS* actions_desc, ACTIONS* actions_sig)
 {
 
 // return -1 if No Qualifying Actionable XML otherwise return 0
@@ -239,9 +239,9 @@ void applyCalibration(int type, int ndata, double factor, double offset, int inv
 }
 
 
-void idamserverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE* data_source, SIGNAL* signal,
-                              SIGNAL_DESC* signal_desc,
-                              DATA_BLOCK* data_block, ACTIONS actions)
+void serverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE* data_source, SIGNAL* signal,
+                          SIGNAL_DESC* signal_desc,
+                          DATA_BLOCK* data_block, ACTIONS actions)
 {
 
     int ndata, dimid;
@@ -368,7 +368,7 @@ void idamserverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE* data_sourc
                                 data_block->dims[data_block->order].ints = nullptr;
                             } else {
                                 if (data_block->dims[data_block->order].dim != nullptr) {
-                                    free((void*)data_block->dims[data_block->order].dim);
+                                    free(data_block->dims[data_block->order].dim);
                                 }
                                 data_block->dims[data_block->order].dim = nullptr;
                             }
@@ -393,7 +393,7 @@ void idamserverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE* data_sourc
                             data_block->dims[data_block->order].ints = nullptr;
                         } else {
                             if (data_block->dims[data_block->order].dim != nullptr) {
-                                free((void*)data_block->dims[data_block->order].dim);
+                                free(data_block->dims[data_block->order].dim);
                             }
                             data_block->dims[data_block->order].dim = nullptr;
                         }
@@ -1347,7 +1347,7 @@ void idamserverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE* data_sourc
 
 // Combine the set of Actions from both sources with Signal XML having Priority of Signal_Desc XML
 
-void idamserverDeselectSignalXML(ACTIONS* actions_desc, ACTIONS* actions_sig)
+void serverDeselectSignalXML(ACTIONS* actions_desc, ACTIONS* actions_sig)
 {
 
     int type;
diff --git a/source/server/applyXML.h b/source/server/applyXML.h
index 1333bfe5..ddb0aaad 100755
--- a/source/server/applyXML.h
+++ b/source/server/applyXML.h
@@ -3,24 +3,19 @@
 
 #include <clientserver/parseXML.h>
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int idamserverParseSignalXML(DATA_SOURCE data_source, SIGNAL signal, SIGNAL_DESC signal_desc,
-                             ACTIONS *actions_desc, ACTIONS *actions_sig);
+LIBRARY_API int serverParseSignalXML(DATA_SOURCE data_source, SIGNAL signal, SIGNAL_DESC signal_desc,
+                                     ACTIONS *actions_desc, ACTIONS *actions_sig);
 
-LIBRARY_API void idamserverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE *data_source, SIGNAL *signal, SIGNAL_DESC *signal_desc,
-                              DATA_BLOCK *data_block, ACTIONS actions);
+LIBRARY_API void serverApplySignalXML(CLIENT_BLOCK client_block, DATA_SOURCE *data_source, SIGNAL *signal,
+                                      SIGNAL_DESC *signal_desc, DATA_BLOCK *data_block, ACTIONS actions);
 
-LIBRARY_API void idamserverDeselectSignalXML(ACTIONS *actions_desc, ACTIONS *actions_sig);
+LIBRARY_API void serverDeselectSignalXML(ACTIONS *actions_desc, ACTIONS *actions_sig);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/closeServerSockets.cpp b/source/server/closeServerSockets.cpp
index 473c04f1..d3e6bb8e 100755
--- a/source/server/closeServerSockets.cpp
+++ b/source/server/closeServerSockets.cpp
@@ -44,7 +44,7 @@ void closeServerSockets(SOCKETLIST* socks)
 {
     for (int i = 0; i < socks->nsocks; i++) closeServerSocket(socks, socks->sockets[i].fh);
     if (socks->sockets != nullptr) {
-        free((void*)socks->sockets);
+        free(socks->sockets);
     }
     initSocketList(socks);
 }
diff --git a/source/server/closeServerSockets.h b/source/server/closeServerSockets.h
index 72527003..4db5ff77 100755
--- a/source/server/closeServerSockets.h
+++ b/source/server/closeServerSockets.h
@@ -2,12 +2,7 @@
 #define UDA_SERVER_CLOSESERVERSOCKETS_H
 
 #include <clientserver/socketStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/createXDRStream.cpp b/source/server/createXDRStream.cpp
index 0c4780ac..660743e9 100755
--- a/source/server/createXDRStream.cpp
+++ b/source/server/createXDRStream.cpp
@@ -8,7 +8,7 @@
 #include "writer.h"
 
 #if !defined(FATCLIENT) && defined(SSLAUTHENTICATION)
-#include <authentication/udaSSL.h>
+#include <authentication/udaServerSSL.h>
 #endif
 
 void CreateXDRStream() {
@@ -17,63 +17,63 @@ void CreateXDRStream() {
 
 #if !defined(FATCLIENT) && defined(SSLAUTHENTICATION)
 
-    if(getUdaServerSSLDisabled()){
+    if (getUdaServerSSLDisabled()) {
 
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
        xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (void *, void *, int))Readin,
-                      (int (*) (void *, void *, int))Writeout);
+                      reinterpret_cast<int (*)(void *, void *, int)>(Readin),
+                      reinterpret_cast<int (*)(void *, void *, int)>(Writeout));
 
        xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (void *, void *, int))Readin,
-                      (int (*) (void *, void *, int))Writeout);
+                      reinterpret_cast<int (*)(void *, void *, int)>(Readin),
+                      reinterpret_cast<int (*)(void *, void *, int)>(Writeout));
 #else
        xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (char *, char *, int))Readin,
-                      (int (*) (char *, char *, int))Writeout);
+                      reinterpret_cast<int (*)(char *, char *, int)>(Readin),
+                      reinterpret_cast<int (*)(char *, char *, int)>(Writeout));
 
        xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (char *, char *, int))Readin,
-                      (int (*) (char *, char *, int))Writeout);
+                      reinterpret_cast<int (*)(char *, char *, int)>(Readin),
+                      reinterpret_cast<int (*)(char *, char *, int)>(Writeout));
 #endif     
     } else { 
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
        xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (void *, void *, int))readUdaServerSSL,
-                      (int (*) (void *, void *, int))writeUdaServerSSL);
+                      reinterpret_cast<int (*)(void *, void *, int)>(readUdaServerSSL),
+                      reinterpret_cast<int (*)(void *, void *, int)>(writeUdaServerSSL));
 
        xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (void *, void *, int))readUdaServerSSL,
-                      (int (*) (void *, void *, int))writeUdaServerSSL);
+                      reinterpret_cast<int (*)(void *, void *, int)>(readUdaServerSSL),
+                      reinterpret_cast<int (*)(void *, void *, int)>(writeUdaServerSSL));
 #else
        xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (char *, char *, int))readUdaServerSSL,
-                      (int (*) (char *, char *, int))writeUdaServerSSL);
+                      reinterpret_cast<int (*)(char *, char *, int)>(readUdaServerSSL),
+                      reinterpret_cast<int (*)(char *, char *, int)>(writeUdaServerSSL));
 
        xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                      (int (*) (char *, char *, int))readUdaServerSSL,
-                      (int (*) (char *, char *, int))writeUdaServerSSL);
+                      reinterpret_cast<int (*)(char *, char *, int)>(readUdaServerSSL),
+                      reinterpret_cast<int (*)(char *, char *, int)>(writeUdaServerSSL));
 #endif
     }
     
 #else	// SSLAUTHENTICATION
 
-#ifdef __APPLE__
+#if defined (__APPLE__) || defined(__TIRPC__)
     xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                   (int (*) (void *, void *, int))Readin,
-                   (int (*) (void *, void *, int))Writeout);
+                   reinterpret_cast<int (*)(void *, void *, int)>(Readin),
+                   reinterpret_cast<int (*)(void *, void *, int)>(Writeout));
 
     xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                   (int (*) (void *, void *, int))Readin,
-                   (int (*) (void *, void *, int))Writeout);
+                   reinterpret_cast<int (*)(void *, void *, int)>(Readin),
+                   reinterpret_cast<int (*)(void *, void *, int)>(Writeout));
 #else
     xdrrec_create( serverOutput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                   (int (*) (char *, char *, int))Readin,
-                   (int (*) (char *, char *, int))Writeout);
+                   reinterpret_cast<int (*)(char *, char *, int)>(Readin),
+                   reinterpret_cast<int (*)(char *, char *, int)>(Writeout));
 
     xdrrec_create( serverInput, DB_READ_BLOCK_SIZE, DB_WRITE_BLOCK_SIZE, nullptr,
-                   (int (*) (char *, char *, int))Readin,
-                   (int (*) (char *, char *, int))Writeout);
+                   reinterpret_cast<int (*)(char *, char *, int)>(Readin),
+                   reinterpret_cast<int (*)(char *, char *, int)>(Writeout));
 #endif
 
 #endif   // SSLAUTHENTICATION
diff --git a/source/server/createXDRStream.h b/source/server/createXDRStream.h
index a3476cf1..25f67da5 100755
--- a/source/server/createXDRStream.h
+++ b/source/server/createXDRStream.h
@@ -1,11 +1,7 @@
 #ifndef UDA_SERVER_CREATEXDRSTREAM_H
 #define UDA_SERVER_CREATEXDRSTREAM_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/dumpFile.cpp b/source/server/dumpFile.cpp
deleted file mode 100755
index dd9a554f..00000000
--- a/source/server/dumpFile.cpp
+++ /dev/null
@@ -1,281 +0,0 @@
-/*!
-  IDAM Plugin to Dump the Signal Details from a File using proprietory tools, e.g. ncdump
-*/
-/*---------------------------------------------------------------
-*
-* Input Arguments:	REQUEST_BLOCK request_block
-*
-* Returns:		dumpFile		0 if read was successful
-*						otherwise a Error Code is returned
-*			DATA_BLOCK		Structure with Data from the Data File
-*
-* Calls		freeDataBlock	to free Heap memory if an Error Occurs
-*
-* Notes: 	All memory required to hold data is allocated dynamically
-*		in heap storage. Pointers to these areas of memory are held
-*		by the passed DATA_BLOCK structure. Local memory allocations
-*		are freed on exit. However, the blocks reserved for data are
-*		not and MUST BE FREED by the calling routine.
-*
-* ToDo:
-*
-*-----------------------------------------------------------------------------*/
-#include "dumpFile.h"
-
-#include <cstdlib>
-#include <cerrno>
-#if defined(__GNUC__)
-#  include <strings.h>
-#else
-#  define strncasecmp _strnicmp
-#  define popen _popen
-#endif
-
-#include <logging/logging.h>
-#include <clientserver/udaTypes.h>
-#include <clientserver/stringUtils.h>
-#include <clientserver/errorLog.h>
-#include <clientserver/printStructs.h>
-#include <clientserver/freeDataBlock.h>
-#include <clientserver/protocol.h>
-
-int dumpFile(REQUEST_BLOCK request_block, DATA_BLOCK* data_block)
-{
-    int err = 0, serrno;
-
-    char cmd[MAXRECLENGTH];
-    int offset, bufsize, nread, nchar;
-    char* bp = nullptr;
-    char alias[4] = "";
-    char file[STRING_LENGTH] = "";
-    char path[STRING_LENGTH] = "";
-    char exp_number_str[STRING_LENGTH];
-    char* env = nullptr;
-
-    //----------------------------------------------------------------------
-    // File Location
-
-    UDA_LOG(UDA_LOG_DEBUG, "Exp. Number  : %d \n", request_block.exp_number);
-    UDA_LOG(UDA_LOG_DEBUG, "Pass Number  : %d \n", request_block.pass);
-    UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block.signal);
-    UDA_LOG(UDA_LOG_DEBUG, "File Name    : %s \n", request_block.file);
-    UDA_LOG(UDA_LOG_DEBUG, "File Path    : %s \n", request_block.path);
-
-    err = 0;
-
-    if (request_block.exp_number > 0 && request_block.request == REQUEST_READ_IDA) {
-
-        if (strlen(request_block.signal) > 0) {
-            strncpy(alias, request_block.signal, 3);
-            alias[3] = '\0';
-            strlwr(alias);
-        }
-
-        strlwr(request_block.file);
-
-        // Check whether or not the filename is the alias name
-        // If is it then form the correct filename
-
-        strcpy(file, request_block.file);
-
-        // Check whether or not a Path has been specified
-
-        strcpy(path, request_block.path);
-        strcat(path, "/");
-        strcat(path, file);
-
-    } else {
-        strcpy(file, request_block.file);
-        strcpy(path, request_block.path);        //Fully Specified
-    }
-
-    UDA_LOG(UDA_LOG_DEBUG, "File Alias   : %s \n", alias);
-    UDA_LOG(UDA_LOG_DEBUG, "File Name    : %s \n", file);
-    UDA_LOG(UDA_LOG_DEBUG, "File Path    : %s \n", path);
-
-    //----------------------------------------------------------------------
-    // Test for embedded semi-colons => embedded linux commands
-
-    if (!IsLegalFilePath(path)) {
-        err = 999;
-        addIdamError(CODEERRORTYPE, "dumpFile", err, "The directory path has incorrect syntax");
-    }
-
-    //----------------------------------------------------------------------
-    // Error Trap Loop
-
-    FILE* ph = nullptr;
-
-    do {
-        if (err != 0) break;
-
-        //----------------------------------------------------------------------
-        // Create the output file using the appropriate dump utility program
-
-        switch (request_block.request) {
-            case REQUEST_READ_IDA:
-                if ((env = getenv("UDA_DUMP_IDA")) != nullptr) {
-                    strcpy(cmd, env);
-                    strcat(cmd, " ");
-                } else {
-                    strcpy(cmd, "idadump ");
-                }
-                break;
-
-            case REQUEST_READ_CDF:
-                if ((env = getenv("UDA_DUMP_NETCDF")) != nullptr) {
-                    strcpy(cmd, env);
-                    strcat(cmd, " -h ");
-                } else {
-                    strcpy(cmd, "ncdump -h ");
-                }
-                break;
-
-            case REQUEST_READ_HDF5:
-                if ((env = getenv("UDA_DUMP_HDF5")) != nullptr) {
-                    strcpy(cmd, env);
-                    strcat(cmd, " -n ");
-                } else {
-                    strcpy(cmd, "h5dump -n ");
-                }
-                break;
-            case REQUEST_READ_MDS: {
-                // Java example: http://www.mdsplus.org/mdsplus/cvsweb.cgi/mdsplus/javatraverser/DecompileTree.java
-
-                char server[MAXSERVER];
-                char* token = nullptr;
-                int lpath;
-
-                strcpy(server, request_block.server);
-                if (!strncasecmp(server, "localhost.", 10)) server[9] = '/';        // For Parsing
-
-                if ((token = strstr(server, "/")) != nullptr) {                // The Server contains the path to the data
-                    strcpy(path, token);                        // Extract the Path
-                    server[token - server] = '\0';                    // Extract the Server Name
-                    if (STR_IEQUALS(server, "localhost")) {
-                        lpath = (int) strlen(path);
-                        if (!IsLegalFilePath(path)) {                    // Check the file path is regular
-                            err = 999;
-                            addIdamError(CODEERRORTYPE, "dumpFile", err,
-                                         "Unacceptable Path to MDS+ Data Tree");
-                            UDA_LOG(UDA_LOG_DEBUG,
-                                    "Syntax error in the directory path to the MDS+ Data Tree %s\n", path);
-                            break;
-                        }
-                        for (int i = 0; i < lpath; i++)
-                            if (path[i] == '.')
-                                path[i] = '/';        // Change from URL Notation to Path Tree Notation
-                    } else {
-                        err = 999;
-                        addIdamError(CODEERRORTYPE, "dumpFile", err,
-                                     "Unable to Set Trees Paths for Remote MDSPlus Servers");
-                        UDA_LOG(UDA_LOG_DEBUG, "Unable to Set Trees Paths for Remote MDSPlus Servers - %s\n",
-                                path);
-                        break;
-                    }
-                }
-
-                if (strlen(server) == 0) {
-                    THROW_ERROR(999, "No server found");
-                }
-
-                sprintf(exp_number_str, "%d", request_block.exp_number);
-#ifdef _WIN32
-                _putenv_s("SERVER_TREENAME", request_block.file);
-                _putenv_s("SERVER_TREENUM", exp_number_str);
-                _putenv_s("SERVER_TREESERVER", server);
-                _putenv_s("SERVER_TREEPATH", path);
-#else
-                setenv("SERVER_TREENAME", request_block.file, 1);
-                setenv("SERVER_TREENUM", exp_number_str, 1);
-                setenv("SERVER_TREESERVER", server, 1);
-                setenv("SERVER_TREEPATH", path, 1);
-#endif
-
-                UDA_LOG(UDA_LOG_DEBUG, "SERVER_TREENAME:   %s\n", request_block.file);
-                UDA_LOG(UDA_LOG_DEBUG, "SERVER_TREENUM:    %s\n", exp_number_str);
-                UDA_LOG(UDA_LOG_DEBUG, "SERVER_TREESERVER: %s\n", server);
-                UDA_LOG(UDA_LOG_DEBUG, "SERVER_TREEPATH:   %s\n", path);
-
-                if ((env = getenv("UDA_DUMP_MDSPLUS")) != nullptr) {
-                    strcpy(cmd, env);
-                    strcat(cmd, " mdsdump ");
-                } else {
-                    strcpy(cmd, "idl mdsdump ");        // Must be on the Server's path
-                }
-                path[0] = '\0';                // Details are passed via Environment variables
-                break;
-            }
-            default:
-                err = 999;
-                addIdamError(CODEERRORTYPE, "dumpFile", err,
-                             "No DUMP Utility Program for this File Format");
-                break;
-        }
-        if (err != 0) break;
-
-        strcat(cmd, path);
-        strcat(cmd, " 2>&1");
-
-        UDA_LOG(UDA_LOG_DEBUG, "DUMP: %s\n", cmd);
-
-        // Execute the Command and Open a Pipe to the Output for Reading
-
-        errno = 0;
-        ph = popen(cmd, "r");
-        serrno = errno;
-
-        if (ph == nullptr || serrno != 0) {
-            err = 999;
-            if (serrno != 0) addIdamError(SYSTEMERRORTYPE, "dumpFile", serrno, "");
-            addIdamError(CODEERRORTYPE, "dumpFile", err, "Problem Running the DUMP utility program");
-            break;
-        }
-
-        nchar = 0;
-        offset = 0;
-        bufsize = 1024;
-        data_block->data_n = bufsize;
-
-        while (!feof(ph)) {
-            if ((bp = (char*) realloc(bp, data_block->data_n)) == nullptr) {
-                err = 9998;
-                addIdamError(CODEERRORTYPE, "dumpFile", err,
-                             "Unable to Allocate Heap Memory for the File DUMP");
-                break;
-            }
-            nread = (int) fread(bp + offset, sizeof(char), bufsize, ph);
-            nchar = nchar + nread;
-            offset = nchar;
-            data_block->data_n = nchar + bufsize + 1;
-        }
-
-        if (err != 0) break;
-
-        UDA_LOG(UDA_LOG_DEBUG, "nchar %d\n", nchar);
-
-        data_block->data_n = nchar;
-        data_block->data = (char*) bp;
-
-        data_block->rank = 0;        // Scalar Array of Bytes
-        data_block->order = -1;        // No Time Dimension
-
-        data_block->data_type = UDA_TYPE_STRING;
-
-        //----------------------------------------------------------------------
-        // End of Error Trap Loop
-
-    } while (0);
-
-    //----------------------------------------------------------------------
-    // Housekeeping
-
-    UDA_LOG(UDA_LOG_DEBUG, "DUMP: err %d\n", err);
-    UDA_LOG(UDA_LOG_DEBUG, "errno     %d\n", errno);
-    printDataBlock(*data_block);
-
-    if (err != 0) freeDataBlock(data_block);
-    if (ph != nullptr) fclose(ph);
-
-    return err;
-}
diff --git a/source/server/dumpFile.h b/source/server/dumpFile.h
deleted file mode 100755
index 09b81080..00000000
--- a/source/server/dumpFile.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef UDA_SERVER_DUMPFILE_H
-#define UDA_SERVER_DUMPFILE_H
-
-#include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-LIBRARY_API int dumpFile(REQUEST_BLOCK request_block, DATA_BLOCK *data_block);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif // UDA_SERVER_DUMPFILE_H
diff --git a/source/server/fatServer.cpp b/source/server/fatServer.cpp
index 64bed9e2..b821c299 100755
--- a/source/server/fatServer.cpp
+++ b/source/server/fatServer.cpp
@@ -144,7 +144,7 @@ fatServer(CLIENT_BLOCK client_block, SERVER_BLOCK* server_block, REQUEST_BLOCK*
         return err;
     }
 
-    idamAccessLog(FALSE, client_block, request_block, *server_block, &pluginList, getIdamServerEnvironment());
+    udaAccessLog(FALSE, client_block, request_block, *server_block, &pluginList, getServerEnvironment());
 
     err = doFatServerClosedown(server_block, &data_block, &actions_desc, &actions_sig, data_block0);
 
@@ -261,7 +261,7 @@ int fatClientReturn(SERVER_BLOCK* server_block, DATA_BLOCK* data_block, DATA_BLO
     //----------------------------------------------------------------------------
     // Free Name Value pair
 
-    freeNameValueList(&request_block->nameValueList);
+    free_name_value_list(&request_block->nameValueList);
 
     return err;
 }
@@ -301,12 +301,12 @@ int handleRequestFat(REQUEST_BLOCK* request_block, REQUEST_BLOCK* request_block0
     protocolVersion = serverVersion;
 
     if (protocolVersion >= 6) {
-        if ((err = idamServerPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc,
-                                    &pluginList, getIdamServerEnvironment())) != 0) {
+        if ((err = udaServerPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc,
+                                   &pluginList, getServerEnvironment())) != 0) {
             return err;
         }
     } else {
-        if ((err = idamServerLegacyPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc)) !=
+        if ((err = udaServerLegacyPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc)) !=
             0) {
             return err;
         }
@@ -441,7 +441,7 @@ int startupFatServer(SERVER_BLOCK* server_block)
 
     if (!plugin_list_initialised) {
         pluginList.count = 0;
-        initPluginList(&pluginList, getIdamServerEnvironment());
+        initPluginList(&pluginList, getServerEnvironment());
         plugin_list_initialised = 1;
 
         UDA_LOG(UDA_LOG_INFO, "List of Plugins available\n");
diff --git a/source/server/freeIdamPut.cpp b/source/server/freeIdamPut.cpp
index 83c547ab..92535518 100755
--- a/source/server/freeIdamPut.cpp
+++ b/source/server/freeIdamPut.cpp
@@ -4,21 +4,10 @@
 
 #include <clientserver/initStructs.h>
 
-void freeIdamServerPutDataBlock(PUTDATA_BLOCK* str)
-{
-    //str->opaque_block  = NULL;
-    //str->data          = NULL;		// Client app is responsible for freeing these heap variables
-    //str->blockName     = NULL;		// as IDAM does not copy the data (to be reviewed!)
-
-    //if(str->count > 0 && str->data  != NULL) free((void *)str->data);
-    //if(str->rank  > 1 && str->shape != NULL) free((void *)str->shape);
-    //if(str->blockNameLength  > 1 && str->blockName != NULL) free((void *)str->blockName);
-}
-
-void freeIdamServerPutDataBlockList(PUTDATA_BLOCK_LIST* putDataBlockList)
+void freeServerPutDataBlockList(PUTDATA_BLOCK_LIST* putDataBlockList)
 {
     if (putDataBlockList->putDataBlock != nullptr && putDataBlockList->blockListSize > 0) {
-        free((void*)putDataBlockList->putDataBlock);
+        free(putDataBlockList->putDataBlock);
     }
     initIdamPutDataBlockList(putDataBlockList);
 }
diff --git a/source/server/freeIdamPut.h b/source/server/freeIdamPut.h
index 70f00dc6..e3395c50 100755
--- a/source/server/freeIdamPut.h
+++ b/source/server/freeIdamPut.h
@@ -2,18 +2,13 @@
 #define UDA_SERVER_FREEIDAMPUT_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API void freeIdamServerPutDataBlockList(PUTDATA_BLOCK_LIST *putDataBlockList);
+LIBRARY_API void freeServerPutDataBlockList(PUTDATA_BLOCK_LIST *putDataBlockList);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/getPluginAddress.cpp b/source/server/getPluginAddress.cpp
index 5cf73ead..6fd360eb 100755
--- a/source/server/getPluginAddress.cpp
+++ b/source/server/getPluginAddress.cpp
@@ -3,27 +3,22 @@
 #include <dlfcn.h>
 #include <cstdlib>
 
-#include <clientserver/udaErrors.h>
-#include <server/udaServer.h>
-
 /**
  * Return the function address for plugin data readers located in external shared libraries
  *
  * @param pluginHandle
  * @param library the full file path name to the registered plugin shared library
  * @param symbol the name of the library api function to be called
- * @param idamPlugin the address of the library function
+ * @param pluginfunp the address of the library function
  * @return
  */
-int getPluginAddress(void** pluginHandle, const char* library, const char* symbol, PLUGINFUNP* idamPlugin)
+int getPluginAddress(void** pluginHandle, const char* library, const char* symbol, PLUGINFUNP* pluginfunp)
 {
-    int err = 0;
-    int (* fptr)(IDAM_PLUGIN_INTERFACE*);               // Pointer to a Plugin function with standard interface
-
-    *idamPlugin = (PLUGINFUNP)nullptr;                     // Default
+    *pluginfunp = (PLUGINFUNP)nullptr;
 
-    if (library[0] == '\0' || symbol[0] == '\0') {      // Nothing to 'point' to! Is this an Error?
-        return err;
+    if (library[0] == '\0' || symbol[0] == '\0') {
+        // Nothing to 'point' to! Is this an Error?
+        return 0;
     }
 
     const char* plugin_dir = getenv("UDA_PLUGIN_DIR");
@@ -41,14 +36,13 @@ int getPluginAddress(void** pluginHandle, const char* library, const char* symbo
 
     if (*pluginHandle == nullptr) {
         if ((*pluginHandle = dlopen(full_path, RTLD_LOCAL | RTLD_LAZY)) == nullptr) {
-            err = 999;
             const char* errmsg = dlerror();
             UDA_LOG(UDA_LOG_ERROR, "Cannot open the target shared library %s: %s\n", library, errmsg);
             if (fail_on_load != nullptr) {
-                addIdamError(SYSTEMERRORTYPE, __func__, err, "Cannot open the target shared library");
-                addIdamError(SYSTEMERRORTYPE, __func__, err, errmsg);
+                ADD_ERROR(999, "Cannot open the target shared library");
+                ADD_ERROR(999, errmsg);
             }
-            return err;
+            return 999;
         }
     }
 
@@ -58,23 +52,23 @@ int getPluginAddress(void** pluginHandle, const char* library, const char* symbo
 
     // Find the address of the required plugin function
 
+    int (* fptr)(IDAM_PLUGIN_INTERFACE*);
     *(void**)(&fptr) = dlsym(*pluginHandle, symbol);
 
     char* errstr = dlerror();
 
     if (errstr == nullptr) {
-        *idamPlugin = (PLUGINFUNP)fptr;
+        *pluginfunp = (PLUGINFUNP)fptr;
     } else {
-        err = 999;
         UDA_LOG(UDA_LOG_ERROR, "Cannot open the target shared library %s: %s\n", library, errstr);
         if (fail_on_load != nullptr) {
-            addIdamError(CODEERRORTYPE, __func__, err, "Cannot locate the data reader with the target shared library");
-            addIdamError(CODEERRORTYPE, __func__, err, errstr);
+            ADD_ERROR(999, "Cannot locate the data reader with the target shared library");
+            ADD_ERROR(999, errstr);
         }
         dlclose(pluginHandle);
         *pluginHandle = nullptr;
-        return err;
+        return 999;
     }
 
-    return err;
+    return 0;
 }
\ No newline at end of file
diff --git a/source/server/getPluginAddress.h b/source/server/getPluginAddress.h
index 45ae3abb..6a410bee 100755
--- a/source/server/getPluginAddress.h
+++ b/source/server/getPluginAddress.h
@@ -2,18 +2,13 @@
 #define UDA_GETPLUGIN_ADDRESS_H
 
 #include <plugins/udaPlugin.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int getPluginAddress(void **pluginHandle, const char *library, const char *symbol, PLUGINFUNP *idamPlugin);
+LIBRARY_API int getPluginAddress(void **pluginHandle, const char *library, const char *symbol, PLUGINFUNP *pluginfunp);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/getServerEnvironment.cpp b/source/server/getServerEnvironment.cpp
index bbea18f3..80b57e6c 100755
--- a/source/server/getServerEnvironment.cpp
+++ b/source/server/getServerEnvironment.cpp
@@ -16,12 +16,7 @@
 // 2019-07-04 Herve Ancher (CEA): Add prefix "g_" to avoid conflict with internal MinGW varaible
 static ENVIRONMENT g_environ;
 
-void putIdamServerEnvironment(const ENVIRONMENT* environment)
-{
-    g_environ = *environment;
-}
-
-void printIdamServerEnvironment(const ENVIRONMENT* environment)
+void printServerEnvironment(const ENVIRONMENT* environment)
 {
     UDA_LOG(UDA_LOG_INFO, "\nServer Environment Variable values\n\n");
     UDA_LOG(UDA_LOG_INFO, "Log Location    : %s\n", environment->logdir);
@@ -34,7 +29,7 @@ void printIdamServerEnvironment(const ENVIRONMENT* environment)
     UDA_LOG(UDA_LOG_INFO, "Private File Path Substitute: %s\n", environment->private_path_substitute);
 }
 
-ENVIRONMENT* getIdamServerEnvironment()
+ENVIRONMENT* getServerEnvironment()
 {
     char* env = nullptr;
 
diff --git a/source/server/getServerEnvironment.h b/source/server/getServerEnvironment.h
index d22d5852..d7fe0197 100755
--- a/source/server/getServerEnvironment.h
+++ b/source/server/getServerEnvironment.h
@@ -2,19 +2,14 @@
 #define UDA_SERVER_GETSERVERENVIRONMENT_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API void printIdamServerEnvironment(const ENVIRONMENT* environment);
-LIBRARY_API ENVIRONMENT* getIdamServerEnvironment();
+LIBRARY_API void printServerEnvironment(const ENVIRONMENT* environment);
+LIBRARY_API ENVIRONMENT* getServerEnvironment();
 
 #ifdef __cplusplus
 }
diff --git a/source/server/initPluginList.cpp b/source/server/initPluginList.cpp
index 52bf8ec4..e5e869d8 100644
--- a/source/server/initPluginList.cpp
+++ b/source/server/initPluginList.cpp
@@ -2,9 +2,8 @@
 
 #include <cerrno>
 
-#include <cache/cache.h>
+#include <cache/memcache.h>
 #include <clientserver/stringUtils.h>
-#include <clientserver/protocol.h>
 #include <server/serverPlugin.h>
 
 #include "getPluginAddress.h"
@@ -32,7 +31,7 @@ void initPluginList(PLUGINLIST* plugin_list, ENVIRONMENT* environment)
     plugin_list->plugin[plugin_list->count].is_private = UDA_PLUGIN_PUBLIC;
     strcpy(plugin_list->plugin[plugin_list->count].desc,
            "Generic Data Access request - no file format or server name specified, only the shot number");
-    strcpy(plugin_list->plugin[plugin_list->count].example, "idamGetAPI(\"signal name\", \"12345\")");
+    strcpy(plugin_list->plugin[plugin_list->count].example, R"(udaGetAPI("signal name", "12345"))");
     allocPluginList(plugin_list->count++, plugin_list);
 
     //----------------------------------------------------------------------------------------------------------------------
@@ -109,17 +108,16 @@ void initPluginList(PLUGINLIST* plugin_list, ENVIRONMENT* environment)
 
         errno = 0;
         if ((conf = fopen(work, "r")) == nullptr || errno != 0) {
-            int err = 999;
-            addIdamError(SYSTEMERRORTYPE, __func__, errno, strerror(errno));
-            addIdamError(SYSTEMERRORTYPE, __func__, err, "No Server Plugin Configuration File found!");
+            ADD_SYS_ERROR(strerror(errno));
+            ADD_ERROR(999, "No Server Plugin Configuration File found!");
             if (conf != nullptr) {
                 fclose(conf);
             }
-            free((void*)work);
+            free(work);
             return;
         }
 
-        if (work != nullptr) free((void*)work);
+        free(work);
 
         /*
         record format: csv, empty records ignored, comment begins #, max record size 1023;
@@ -279,7 +277,6 @@ void initPluginList(PLUGINLIST* plugin_list, ENVIRONMENT* environment)
 
                 // Issue Unique request ID
                 plugin_list->plugin[plugin_list->count].request = REQUEST_READ_START + offset++;
-
                 plugin_list->plugin[plugin_list->count].pluginHandle = nullptr;            // Library handle: Not opened
                 plugin_list->plugin[plugin_list->count].status = UDA_PLUGIN_NOT_OPERATIONAL;  // Not yet available
 
diff --git a/source/server/initPluginList.h b/source/server/initPluginList.h
index 531d5679..8c65535c 100644
--- a/source/server/initPluginList.h
+++ b/source/server/initPluginList.h
@@ -3,12 +3,7 @@
 
 #include <clientserver/udaStructs.h>
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/makeServerRequestBlock.cpp b/source/server/makeServerRequestBlock.cpp
index ddccb4d2..243b3eee 100755
--- a/source/server/makeServerRequestBlock.cpp
+++ b/source/server/makeServerRequestBlock.cpp
@@ -38,7 +38,7 @@ void initServerRequestBlock(REQUEST_BLOCK* str)
 
 int makeServerRequestBlock(REQUEST_BLOCK* request_block, PLUGINLIST pluginList)
 {
-    return makeRequestBlock(request_block, pluginList, getIdamServerEnvironment());
+    return make_request_block(request_block, pluginList, getServerEnvironment());
 }
 
 #endif
diff --git a/source/server/makeServerRequestBlock.h b/source/server/makeServerRequestBlock.h
index cd823738..e9ac0200 100755
--- a/source/server/makeServerRequestBlock.h
+++ b/source/server/makeServerRequestBlock.h
@@ -3,12 +3,7 @@
 
 #include <plugins/udaPlugin.h>
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/serverGetData.cpp b/source/server/serverGetData.cpp
index dd294f48..7c311024 100755
--- a/source/server/serverGetData.cpp
+++ b/source/server/serverGetData.cpp
@@ -19,29 +19,25 @@
 #include <clientserver/freeDataBlock.h>
 #include <clientserver/initStructs.h>
 #include <clientserver/printStructs.h>
-#include <clientserver/protocol.h>
 #include <clientserver/stringUtils.h>
 #include <clientserver/makeRequestBlock.h>
+#include <clientserver/nameValueSubstitution.h>
 #include <structures/struct.h>
 
 #include "applyXML.h"
-#include "dumpFile.h"
 #include "getServerEnvironment.h"
 #include "makeServerRequestBlock.h"
 #include "serverPlugin.h"
 #include "serverSubsetData.h"
 
-static int idamserverSwapSignalError(DATA_BLOCK* data_block, DATA_BLOCK* data_block2, int asymmetry);
-
-static int idamserverSwapSignalDim(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2);
-
-static int idamserverSwapSignalDimError(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2,
-                                        int asymmetry);
-
-static int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block, DATA_BLOCK* data_block,
-                              DATA_SOURCE* data_source, SIGNAL* signal_rec, SIGNAL_DESC* signal_desc,
-                              const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
-                              USERDEFINEDTYPELIST* userdefinedtypelist);
+static int swap_signal_error(DATA_BLOCK* data_block, DATA_BLOCK* data_block2, int asymmetry);
+static int swap_signal_dim(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2);
+static int swap_signal_dim_error(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2,
+                                 int asymmetry);
+static int read_data(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block, DATA_BLOCK* data_block,
+                     DATA_SOURCE* data_source, SIGNAL* signal_rec, SIGNAL_DESC* signal_desc,
+                     const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
+                     USERDEFINEDTYPELIST* userdefinedtypelist);
 
 int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
                DATA_BLOCK* data_block, DATA_SOURCE* data_source, SIGNAL* signal_rec, SIGNAL_DESC* signal_desc,
@@ -98,7 +94,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
                 serverside = 1;
                 initActions(&actions_serverside);
                 int rc;
-                if ((rc = idamserverParseServerSide(request_block, &actions_serverside)) != 0) {
+                if ((rc = serverParseServerSide(request_block, &actions_serverside)) != 0) {
                     return rc;
                 }
                 // Erase original SUBSET request
@@ -112,7 +108,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
                 serverside = 1;
                 initActions(&actions_serverside);
                 int rc;
-                if ((rc = idamserverParseServerSide(request_block, &actions_serverside)) != 0) {
+                if ((rc = serverParseServerSide(request_block, &actions_serverside)) != 0) {
                     return rc;
                 }
                 // Erase original SUBSET request
@@ -124,8 +120,8 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
     //--------------------------------------------------------------------------------------------------------------------------
     // Read the Data (Returns rc < 0 if the signal is a derived type or is defined in an XML document)
 
-    int rc = idamserverReadData(request_block, client_block, data_block, data_source, signal_rec, signal_desc,
-                                pluginlist, logmalloclist, userdefinedtypelist);
+    int rc = read_data(request_block, client_block, data_block, data_source, signal_rec, signal_desc,
+                       pluginlist, logmalloclist, userdefinedtypelist);
 
     UDA_LOG(UDA_LOG_DEBUG, "After idamserverReadData rc = %d\n", rc);
     UDA_LOG(UDA_LOG_DEBUG, "Is the Signal a Composite? %d\n", signal_desc->type == 'C');
@@ -166,7 +162,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
         UDA_LOG(UDA_LOG_DEBUG, "parsing XML for a COMPOSITE Signal\n");
 
-        rc = idamserverParseSignalXML(*data_source, *signal_rec, *signal_desc, &actions_comp_desc, &actions_comp_sig);
+        rc = serverParseSignalXML(*data_source, *signal_rec, *signal_desc, &actions_comp_desc, &actions_comp_sig);
 
         UDA_LOG(UDA_LOG_DEBUG, "parsing XML RC? %d\n", rc);
 
@@ -330,7 +326,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
         if (!client_block.get_asis) {
 
             // Regular Signal
-            rc = idamserverParseSignalXML(*data_source, *signal_rec, *signal_desc, actions_desc, actions_sig);
+            rc = serverParseSignalXML(*data_source, *signal_rec, *signal_desc, actions_desc, actions_sig);
 
             if (rc == -1) {
                 if (!serverside) {
@@ -397,7 +393,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
             // Replace Error Data
 
-            rc = idamserverSwapSignalError(data_block, &data_block2, 0);
+            rc = swap_signal_error(data_block, &data_block2, 0);
             freeDataBlock(&data_block2);
 
             if (rc != 0) {
@@ -443,7 +439,7 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
             // Replace Error Data
 
-            rc = idamserverSwapSignalError(data_block, &data_block2, 1);
+            rc = swap_signal_error(data_block, &data_block2, 1);
             freeDataBlock(&data_block2);
 
             if (rc != 0) {
@@ -544,8 +540,8 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
                     // Replace Dimension Data
 
-                    rc = idamserverSwapSignalDim(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
-                                                 data_block, &data_block2);
+                    rc = swap_signal_dim(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
+                                         data_block, &data_block2);
 
                     freeDataBlock(&data_block2);
 
@@ -592,8 +588,8 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
                     // Replace Dimension Error Data
 
-                    rc = idamserverSwapSignalDimError(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
-                                                      data_block, &data_block2, 0);
+                    rc = swap_signal_dim_error(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
+                                               data_block, &data_block2, 0);
 
                     freeDataBlock(&data_block2);
 
@@ -640,8 +636,8 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
                     // Replace Dimension Asymmetric Error Data
 
-                    rc = idamserverSwapSignalDimError(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
-                                                      data_block, &data_block2, 1);
+                    rc = swap_signal_dim_error(actions_desc->action[compId].composite.dimensions[i].dimcomposite,
+                                               data_block, &data_block2, 1);
                     freeDataBlock(&data_block2);
 
                     if (rc != 0) {
@@ -664,10 +660,10 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
 
         // All Signal Actions have Precedence over Signal_Desc Actions: Deselect if there is a conflict
 
-        idamserverDeselectSignalXML(actions_desc, actions_sig);
+        serverDeselectSignalXML(actions_desc, actions_sig);
 
-        idamserverApplySignalXML(client_block, data_source, signal_rec, signal_desc, data_block, *actions_desc);
-        idamserverApplySignalXML(client_block, data_source, signal_rec, signal_desc, data_block, *actions_sig);
+        serverApplySignalXML(client_block, data_source, signal_rec, signal_desc, data_block, *actions_desc);
+        serverApplySignalXML(client_block, data_source, signal_rec, signal_desc, data_block, *actions_sig);
     }
 
     UDA_LOG(UDA_LOG_DEBUG, "#Timing After XML\n");
@@ -677,10 +673,10 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
     // Subset Data or Map Data when all other actions have been applied
 
     if (isDerived && compId > -1) {
-        UDA_LOG(UDA_LOG_DEBUG, "Calling idamserverSubsetData (Derived)  %d\n", *depth);
+        UDA_LOG(UDA_LOG_DEBUG, "Calling serverSubsetData (Derived)  %d\n", *depth);
         printDataBlock(*data_block);
 
-        if ((rc = idamserverSubsetData(data_block, actions_desc->action[compId], logmalloclist)) != 0) {
+        if ((rc = serverSubsetData(data_block, actions_desc->action[compId], logmalloclist)) != 0) {
             (*depth)--;
             return rc;
         }
@@ -692,10 +688,10 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
     if (!serverside && !isDerived && signal_desc->type == 'S') {
         for (int i = 0; i < actions_desc->nactions; i++) {
             if (actions_desc->action[i].actionType == SUBSETTYPE) {
-                UDA_LOG(UDA_LOG_DEBUG, "Calling idamserverSubsetData (SUBSET)   %d\n", *depth);
+                UDA_LOG(UDA_LOG_DEBUG, "Calling serverSubsetData (SUBSET)   %d\n", *depth);
                 printDataBlock(*data_block);
 
-                if ((rc = idamserverSubsetData(data_block, actions_desc->action[i], logmalloclist)) != 0) {
+                if ((rc = serverSubsetData(data_block, actions_desc->action[i], logmalloclist)) != 0) {
                     (*depth)--;
                     return rc;
                 }
@@ -710,10 +706,10 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
         for (int i = 0; i < actions_serverside.nactions; i++) {
             if (actions_serverside.action[i].actionType == SERVERSIDETYPE) {
                 for (int j = 0; j < actions_serverside.action[i].serverside.nsubsets; j++) {
-                    UDA_LOG(UDA_LOG_DEBUG, "Calling idamserverSubsetData (Serverside)   %d\n", *depth);
+                    UDA_LOG(UDA_LOG_DEBUG, "Calling serverSubsetData (Serverside)   %d\n", *depth);
                     printDataBlock(*data_block);
 
-                    if ((rc = idamserverSubsetData(data_block, actions_serverside.action[i], logmalloclist)) != 0) {
+                    if ((rc = serverSubsetData(data_block, actions_serverside.action[i], logmalloclist)) != 0) {
                         (*depth)--;
                         return rc;
                     }
@@ -729,19 +725,19 @@ int udaGetData(int* depth, REQUEST_BLOCK* request_block, CLIENT_BLOCK client_blo
     return 0;
 }
 
-int idamserverSwapSignalError(DATA_BLOCK* data_block, DATA_BLOCK* data_block2, int asymmetry)
+int swap_signal_error(DATA_BLOCK* data_block, DATA_BLOCK* data_block2, int asymmetry)
 {
     // Check Rank and Array Block Size are equal
 
     if (data_block->rank == data_block2->rank && data_block->data_n == data_block2->data_n) {
 
         if (!asymmetry) {
-            if (data_block->errhi != nullptr) free((void*)data_block->errhi);    // Free unwanted Error Data Heap
+            if (data_block->errhi != nullptr) free(data_block->errhi);    // Free unwanted Error Data Heap
             data_block->errhi = data_block2->data;                // straight swap!
             data_block2->data = nullptr;                        // Prevent Double Heap Free
             data_block->errasymmetry = 0;
         } else {
-            if (data_block->errlo != nullptr) free((void*)data_block->errlo);
+            if (data_block->errlo != nullptr) free(data_block->errlo);
             data_block->errlo = data_block2->data;
             data_block2->data = nullptr;
             data_block->errasymmetry = 1;
@@ -756,7 +752,7 @@ int idamserverSwapSignalError(DATA_BLOCK* data_block, DATA_BLOCK* data_block2, i
     return 0;
 }
 
-int idamserverSwapSignalDim(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2)
+int swap_signal_dim(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2)
 {
     void* cptr = nullptr;
 
@@ -872,8 +868,8 @@ int idamserverSwapSignalDim(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, D
 }
 
 
-int idamserverSwapSignalDimError(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2,
-                                 int asymmetry)
+int swap_signal_dim_error(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_block, DATA_BLOCK* data_block2,
+                          int asymmetry)
 {
     void* cptr = nullptr;
 
@@ -905,10 +901,10 @@ int idamserverSwapSignalDimError(DIMCOMPOSITE dimcomposite, DATA_BLOCK* data_blo
     return 0;
 }
 
-int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
-                       DATA_BLOCK* data_block, DATA_SOURCE* data_source, SIGNAL* signal_rec, SIGNAL_DESC* signal_desc,
-                       const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
-                       USERDEFINEDTYPELIST* userdefinedtypelist)
+int read_data(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
+              DATA_BLOCK* data_block, DATA_SOURCE* data_source, SIGNAL* signal_rec, SIGNAL_DESC* signal_desc,
+              const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
+              USERDEFINEDTYPELIST* userdefinedtypelist)
 {
     // If err = 0 then standard signal data read
     // If err > 0 then an error occured
@@ -979,7 +975,7 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
 
         // Identify the required Plugin
 
-        int plugin_id = idamServerMetaDataPluginId(pluginlist, getIdamServerEnvironment());
+        int plugin_id = udaServerMetaDataPluginId(pluginlist, getServerEnvironment());
         if (plugin_id < 0) {
             // No plugin so not possible to identify the requested data item
             THROW_ERROR(778, "Unable to identify requested data item");
@@ -993,8 +989,8 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
 
         // Execute the plugin to resolve the identity of the data requested
 
-        int err = idamServerMetaDataPlugin(pluginlist, plugin_id, request_block, signal_desc, signal_rec, data_source,
-                                           getIdamServerEnvironment());
+        int err = udaServerMetaDataPlugin(pluginlist, plugin_id, request_block, signal_desc, signal_rec, data_source,
+                                          getServerEnvironment());
 
         if (err != 0) {
             THROW_ERROR(err, "No Record Found for this Generic Signal");
@@ -1015,7 +1011,7 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
     // Modifes HEAP in request_block
 
     {
-        int err = nameValueSubstitution(&request_block->nameValueList, request_block->tpass);
+        int err = name_value_substitution(&request_block->nameValueList, request_block->tpass);
         if (err != 0) return err;
     }
 
@@ -1055,7 +1051,7 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
         return -1;
     }
 
-    ENVIRONMENT* environment = getIdamServerEnvironment();
+    ENVIRONMENT* environment = getServerEnvironment();
 
     //------------------------------------------------------------------------------
     // Read Data via a Suitable Registered Plugin using a standard interface
@@ -1126,7 +1122,7 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
                 // Redirect Output to temporary file if no file handles passed
                 int reset = 0;
                 int rc;
-                if ((rc = idamServerRedirectStdStreams(reset)) != 0) {
+                if ((rc = udaServerRedirectStdStreams(reset)) != 0) {
                     THROW_ERROR(rc, "Error Redirecting Plugin Message Output");
                 }
 #endif
@@ -1137,7 +1133,7 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
 #ifndef FATCLIENT
                 // Reset Redirected Output
                 reset = 1;
-                if ((rc = idamServerRedirectStdStreams(reset)) != 0) {
+                if ((rc = udaServerRedirectStdStreams(reset)) != 0) {
                     THROW_ERROR(rc, "Error Resetting Redirected Plugin Message Output");
                 }
 #endif
@@ -1150,10 +1146,10 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
 
                 // Save Provenance with socket stream protection
 
-                idamServerRedirectStdStreams(0);
-                idamProvenancePlugin(&client_block, request_block, data_source, signal_desc, pluginlist, nullptr,
-                                     getIdamServerEnvironment());
-                idamServerRedirectStdStreams(1);
+                udaServerRedirectStdStreams(0);
+                udaProvenancePlugin(&client_block, request_block, data_source, signal_desc, pluginlist, nullptr,
+                                    getServerEnvironment());
+                udaServerRedirectStdStreams(1);
 
                 // If no structures to pass back (only regular data) then free the user defined type list
 
@@ -1235,10 +1231,10 @@ int idamserverReadData(REQUEST_BLOCK* request_block, CLIENT_BLOCK client_block,
     //----------------------------------------------------------------------------
     // Save Provenance with socket stream protection
 
-    idamServerRedirectStdStreams(0);
-    idamProvenancePlugin(&client_block, request_block, data_source, signal_desc, pluginlist, nullptr,
-                         getIdamServerEnvironment());
-    idamServerRedirectStdStreams(1);
+    udaServerRedirectStdStreams(0);
+    udaProvenancePlugin(&client_block, request_block, data_source, signal_desc, pluginlist, nullptr,
+                        getServerEnvironment());
+    udaServerRedirectStdStreams(1);
 
     return 0;
 }
diff --git a/source/server/serverGetData.h b/source/server/serverGetData.h
index 135b762f..7eb53ae0 100755
--- a/source/server/serverGetData.h
+++ b/source/server/serverGetData.h
@@ -6,13 +6,7 @@
 #include <clientserver/socketStructs.h>
 #include <structures/genStructs.h>
 #include <plugins/pluginStructs.h>
-
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/serverLegacyPlugin.cpp b/source/server/serverLegacyPlugin.cpp
index 54dd852c..3ffccbb0 100755
--- a/source/server/serverLegacyPlugin.cpp
+++ b/source/server/serverLegacyPlugin.cpp
@@ -20,13 +20,13 @@
 #  include <server/getServerEnvironment.h>
 #endif
 
-int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc)
+int udaServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc)
 {
     int err = 0;
     char* token = nullptr;
     char work[STRING_LENGTH];
 
-    UDA_LOG(UDA_LOG_DEBUG, "IdamServerLegacyPlugin: Start\n");
+    UDA_LOG(UDA_LOG_DEBUG, "Start\n");
 
     //----------------------------------------------------------------------------
     // Start of Error Trap
@@ -38,7 +38,7 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
 
 #ifndef FATCLIENT
 
-        ENVIRONMENT* environment = getIdamServerEnvironment();
+        ENVIRONMENT* environment = getServerEnvironment();
 
         if (request_block->request == REQUEST_READ_FORMAT) {
             if (environment->private_path_target[0] != '\0') {
@@ -69,10 +69,8 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                     }
                 } else {
                     err = 999;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
-                                 "Unmatched count of Target and Substitute File Paths.");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Unmatched count of Target and Substitute File Paths.");
                     break;
-
                 }
             }
         }
@@ -129,11 +127,11 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->type = ' ';
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read IDA \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Alias   : %s \n", request_block->file);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Path    : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pulse Number : %d \n", request_block->exp_number);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pass Number  : %d \n", request_block->pass);
+                UDA_LOG(UDA_LOG_DEBUG, "File Alias   : %s \n", request_block->file);
+                UDA_LOG(UDA_LOG_DEBUG, "File Path    : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Pulse Number : %d \n", request_block->exp_number);
+                UDA_LOG(UDA_LOG_DEBUG, "Pass Number  : %d \n", request_block->pass);
                 break;
 
             case REQUEST_READ_NEW_PLUGIN:
@@ -148,11 +146,11 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->type = ' ';
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read IDA \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Alias   : %s \n", request_block->file);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Path    : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pulse Number : %d \n", request_block->exp_number);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pass Number  : %d \n", request_block->pass);
+                UDA_LOG(UDA_LOG_DEBUG, "File Alias   : %s \n", request_block->file);
+                UDA_LOG(UDA_LOG_DEBUG, "File Path    : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Pulse Number : %d \n", request_block->exp_number);
+                UDA_LOG(UDA_LOG_DEBUG, "Pass Number  : %d \n", request_block->pass);
                 break;
 
             case REQUEST_READ_MDS:
@@ -169,17 +167,17 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->exp_number = request_block->exp_number;                // MDS+ Tree Number
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read MDS+ \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Server       : %s \n", request_block->server);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Tree         : %s \n", request_block->file);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Data Node    : %s \n", request_block->signal);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Tree Number  : %d \n", request_block->exp_number);
+                UDA_LOG(UDA_LOG_DEBUG, "Server       : %s \n", request_block->server);
+                UDA_LOG(UDA_LOG_DEBUG, "Tree         : %s \n", request_block->file);
+                UDA_LOG(UDA_LOG_DEBUG, "Data Node    : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Tree Number  : %d \n", request_block->exp_number);
                 break;
 
             case REQUEST_READ_IDAM:
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read Remote IDAM Source \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Server       : %s \n", request_block->server);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Source       : %s \n", request_block->file);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Server       : %s \n", request_block->server);
+                UDA_LOG(UDA_LOG_DEBUG, "Source       : %s \n", request_block->file);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
                 break;
 
             case REQUEST_READ_CDF:
@@ -187,8 +185,8 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 copyString(TrimString(request_block->signal), signal_desc->signal_name, MAXNAME);
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: readnetCDF \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: netCDF File  : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "netCDF File  : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
                 break;
 
             case REQUEST_READ_HDF5:
@@ -196,8 +194,8 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 copyString(TrimString(request_block->signal), signal_desc->signal_name, MAXNAME);
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadHDF5 \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: HDF5 File    : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "HDF5 File    : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
                 break;
 
             case REQUEST_READ_XML:
@@ -205,22 +203,22 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->pass = request_block->pass;
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadXML \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: XML File     : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: XML Document : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "XML File     : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "XML Document : %s \n", request_block->signal);
                 break;
 
             case REQUEST_READ_UFILE:
                 strcpy(data_source->path, TrimString(request_block->path));    // UFile File Location
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadUFile \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: UFile File   : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "UFile File   : %s \n", request_block->path);
                 break;
 
             case REQUEST_READ_FILE:
                 strcpy(data_source->path, TrimString(request_block->path));    // File Location
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadBytes \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File  : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "File  : %s \n", request_block->path);
                 break;
 
 
@@ -228,7 +226,7 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 strcpy(data_source->path, TrimString(request_block->path));    // File Location
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadHData \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File  : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "File  : %s \n", request_block->path);
                 break;
 
             case REQUEST_READ_SQL:
@@ -239,7 +237,7 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 strcpy(data_source->device_name, TrimString(request_block->device_name));
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: ReadSQL \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: SQL   : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "SQL   : %s \n", request_block->signal);
                 break;
 
             case REQUEST_READ_NOTHING:
@@ -277,11 +275,11 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->type = ' ';
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read PPF \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Alias   : %s \n", request_block->file);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: File Path    : %s \n", request_block->path);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pulse Number : %d \n", request_block->exp_number);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pass Number  : %d \n", request_block->pass);
+                UDA_LOG(UDA_LOG_DEBUG, "File Alias   : %s \n", request_block->file);
+                UDA_LOG(UDA_LOG_DEBUG, "File Path    : %s \n", request_block->path);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Pulse Number : %d \n", request_block->exp_number);
+                UDA_LOG(UDA_LOG_DEBUG, "Pass Number  : %d \n", request_block->pass);
                 break;
 
             case REQUEST_READ_JPF:
@@ -289,14 +287,14 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
                 data_source->exp_number = request_block->exp_number;
 
                 UDA_LOG(UDA_LOG_DEBUG, "Request: Read JPF \n");
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Signal       : %s \n", request_block->signal);
-                UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Pulse Number : %d \n", request_block->exp_number);
+                UDA_LOG(UDA_LOG_DEBUG, "Signal       : %s \n", request_block->signal);
+                UDA_LOG(UDA_LOG_DEBUG, "Pulse Number : %d \n", request_block->exp_number);
                 break;
 
             default:
                 UDA_LOG(UDA_LOG_DEBUG, "Unknown Requested Data Access Routine (%d) \n", request_block->request);
                 err = 9999;
-                addIdamError(CODEERRORTYPE, "idamServer", err,
+                addIdamError(CODEERRORTYPE, __func__, err,
                              "Unknown Requested Data Access Routine");
                 break;
         }
@@ -308,7 +306,7 @@ int idamServerLegacyPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_sourc
 
     } while (0);
 
-    UDA_LOG(UDA_LOG_DEBUG, "IdamServerLegacyPlugin: End\n");
+    UDA_LOG(UDA_LOG_DEBUG, "End\n");
 
     return err;
 }
diff --git a/source/server/serverLegacyPlugin.h b/source/server/serverLegacyPlugin.h
index 5b469b33..d0819c0a 100755
--- a/source/server/serverLegacyPlugin.h
+++ b/source/server/serverLegacyPlugin.h
@@ -2,18 +2,13 @@
 #define UDA_SERVER_SERVERLEGACYPLUGIN_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int idamServerLegacyPlugin(REQUEST_BLOCK *request_block, DATA_SOURCE *data_source, SIGNAL_DESC *signal_desc);
+LIBRARY_API int udaServerLegacyPlugin(REQUEST_BLOCK *request_block, DATA_SOURCE *data_source, SIGNAL_DESC *signal_desc);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/serverPlugin.cpp b/source/server/serverPlugin.cpp
index 5f4c63a9..f3469dfc 100755
--- a/source/server/serverPlugin.cpp
+++ b/source/server/serverPlugin.cpp
@@ -16,7 +16,7 @@
 #  define dup2 _dup2
 #endif
 
-#include <cache/cache.h>
+#include <cache/memcache.h>
 #include <client/udaClient.h>
 #include <clientserver/expand_path.h>
 #include <clientserver/freeDataBlock.h>
@@ -67,7 +67,7 @@ void freePluginList(PLUGINLIST* plugin_list)
             dlclose(plugin_list->plugin[i].pluginHandle);
         }
     }
-    free((void*)plugin_list->plugin);
+    free(plugin_list->plugin);
     plugin_list->plugin = nullptr;
     plugin_list->count = 0;
     plugin_list->mcount = 0;
@@ -119,7 +119,7 @@ void printPluginList(FILE* fd, const PLUGINLIST* plugin_list)
     }
 }
 
-int idamServerRedirectStdStreams(int reset)
+int udaServerRedirectStdStreams(int reset)
 {
     // Any OS messages will corrupt xdr streams so re-divert IO from plugin libraries to a temporary file
 
@@ -255,8 +255,8 @@ int idamServerRedirectStdStreams(int reset)
 // 5. open the library
 // 6. get plugin function address
 // 7. close the file
-int idamServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc,
-                     const PLUGINLIST* plugin_list, const ENVIRONMENT* environment)
+int udaServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc,
+                    const PLUGINLIST* plugin_list, const ENVIRONMENT* environment)
 {
     int err = 0;
 
@@ -265,7 +265,7 @@ int idamServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIG
     //----------------------------------------------------------------------------------------------
     // Decode the API Arguments: determine appropriate data reader plug-in
 
-    if ((err = makeRequestBlock(request_block, *plugin_list, environment)) != 0) {
+    if ((err = make_request_block(request_block, *plugin_list, environment)) != 0) {
         return err;
     }
 
@@ -323,9 +323,9 @@ int idamServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIG
 // changePlugin option disabled in this context
 // private malloc log and userdefinedtypelist
 
-int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_request_block,
-                         DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc, const PLUGINLIST* plugin_list,
-                         char* logRecord, const ENVIRONMENT* environment)
+int udaProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_request_block,
+                        DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc, const PLUGINLIST* plugin_list,
+                        char* logRecord, const ENVIRONMENT* environment)
 {
 
     if (STR_EQUALS(client_block->DOI, "")) {
@@ -408,7 +408,7 @@ int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_req
 
     UDA_LOG(UDA_LOG_DEBUG, "Provenance Plugin signal: %s\n", request_block.signal);
 
-    makeRequestBlock(&request_block, *plugin_list, environment);
+    make_request_block(&request_block, *plugin_list, environment);
 
     int err, rc, reset;
     DATA_BLOCK data_block;
@@ -449,7 +449,7 @@ int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_req
     // Redirect Output to temporary file if no file handles passed
 
     reset = 0;
-    if ((err = idamServerRedirectStdStreams(reset)) != 0) {
+    if ((err = udaServerRedirectStdStreams(reset)) != 0) {
         THROW_ERROR(err, "Error Redirecting Plugin Message Output");
     }
 
@@ -465,7 +465,7 @@ int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_req
 
     UDA_LOG(UDA_LOG_DEBUG, "housekeeping\n");
 
-    freeNameValueList(&request_block.nameValueList);
+    free_name_value_list(&request_block.nameValueList);
 
     UDA_LOG(UDA_LOG_DEBUG, "testing for bug!!!\n");
     if (data_block.opaque_type != UDA_OPAQUE_TYPE_UNKNOWN ||
@@ -480,7 +480,7 @@ int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_req
     // Reset Redirected Output
 
     reset = 1;
-    if ((rc = idamServerRedirectStdStreams(reset)) != 0 || err != 0) {
+    if ((rc = udaServerRedirectStdStreams(reset)) != 0 || err != 0) {
         if (rc != 0) {
             addIdamError(CODEERRORTYPE, __func__, rc, "Error Resetting Redirected Plugin Message Output");
         }
@@ -502,7 +502,7 @@ int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_req
 //------------------------------------------------------------------------------------------------
 // Identify the Plugin to use to resolve Generic Name mappings and return its ID
 
-int idamServerMetaDataPluginId(const PLUGINLIST* plugin_list, const ENVIRONMENT* environment)
+int udaServerMetaDataPluginId(const PLUGINLIST* plugin_list, const ENVIRONMENT* environment)
 {
     static unsigned short noPluginRegistered = 0;
     static int plugin_id = -1;
@@ -554,9 +554,9 @@ int idamServerMetaDataPluginId(const PLUGINLIST* plugin_list, const ENVIRONMENT*
 //------------------------------------------------------------------------------------------------
 // Execute the Generic Name mapping Plugin
 
-int idamServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUEST_BLOCK* request_block,
-                             SIGNAL_DESC* signal_desc, SIGNAL* signal_rec, DATA_SOURCE* data_source,
-                             const ENVIRONMENT* environment)
+int udaServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUEST_BLOCK* request_block,
+                            SIGNAL_DESC* signal_desc, SIGNAL* signal_rec, DATA_SOURCE* data_source,
+                            const ENVIRONMENT* environment)
 {
     int err, reset, rc;
     IDAM_PLUGIN_INTERFACE idam_plugin_interface;
@@ -594,7 +594,7 @@ int idamServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUE
     // Redirect Output to temporary file if no file handles passed
 
     reset = 0;
-    if ((err = idamServerRedirectStdStreams(reset)) != 0) {
+    if ((err = udaServerRedirectStdStreams(reset)) != 0) {
         THROW_ERROR(err, "Error Redirecting Plugin Message Output");
     }
 
@@ -605,7 +605,7 @@ int idamServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUE
     // Reset Redirected Output
 
     reset = 1;
-    if ((rc = idamServerRedirectStdStreams(reset)) != 0 || err != 0) {
+    if ((rc = udaServerRedirectStdStreams(reset)) != 0 || err != 0) {
         if (rc != 0) {
             addIdamError(CODEERRORTYPE, __func__, rc, "Error Resetting Redirected Plugin Message Output");
         }
diff --git a/source/server/serverPlugin.h b/source/server/serverPlugin.h
index 14eee846..03803603 100755
--- a/source/server/serverPlugin.h
+++ b/source/server/serverPlugin.h
@@ -2,43 +2,30 @@
 #define UDA_SERVER_SERVERPLUGIN_H
 
 #include <plugins/udaPlugin.h>
+#include <clientserver/export.h>
 
 #define REQUEST_READ_START      1000
 #define REQUEST_PLUGIN_MCOUNT   100    // Maximum initial number of plugins that can be registered
 #define REQUEST_PLUGIN_MSTEP    10    // Increase heap by 10 records once the maximum is exceeded
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 LIBRARY_API void allocPluginList(int count, PLUGINLIST* plugin_list);
-
 LIBRARY_API void freePluginList(PLUGINLIST* plugin_list);
-
 LIBRARY_API void initPluginData(PLUGIN_DATA* plugin);
-
 LIBRARY_API void initPluginList(PLUGINLIST* plugin_list, ENVIRONMENT* environment);
-
-LIBRARY_API int idamServerRedirectStdStreams(int reset);
-
-LIBRARY_API int idamServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc,
-                     const PLUGINLIST* plugin_list, const ENVIRONMENT* environment);
-
-LIBRARY_API int idamProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_request_block,
-                         DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc, const PLUGINLIST* plugin_list,
-                         char* logRecord, const ENVIRONMENT* environment);
-
-LIBRARY_API int idamServerMetaDataPluginId(const PLUGINLIST* plugin_list, const ENVIRONMENT* environment);
-
-LIBRARY_API int idamServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUEST_BLOCK* request_block,
-                             SIGNAL_DESC* signal_desc, SIGNAL* signal_rec, DATA_SOURCE* data_source,
-                             const ENVIRONMENT* environment);
+LIBRARY_API int udaServerRedirectStdStreams(int reset);
+LIBRARY_API int udaServerPlugin(REQUEST_BLOCK* request_block, DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc,
+                                const PLUGINLIST* plugin_list, const ENVIRONMENT* environment);
+LIBRARY_API int udaProvenancePlugin(CLIENT_BLOCK* client_block, REQUEST_BLOCK* original_request_block,
+                                    DATA_SOURCE* data_source, SIGNAL_DESC* signal_desc, const PLUGINLIST* plugin_list,
+                                    char* logRecord, const ENVIRONMENT* environment);
+LIBRARY_API int udaServerMetaDataPluginId(const PLUGINLIST* plugin_list, const ENVIRONMENT* environment);
+LIBRARY_API int udaServerMetaDataPlugin(const PLUGINLIST* plugin_list, int plugin_id, REQUEST_BLOCK* request_block,
+                                        SIGNAL_DESC* signal_desc, SIGNAL* signal_rec, DATA_SOURCE* data_source,
+                                        const ENVIRONMENT* environment);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/serverProcessing.cpp b/source/server/serverProcessing.cpp
index 31a3b806..41083c70 100755
--- a/source/server/serverProcessing.cpp
+++ b/source/server/serverProcessing.cpp
@@ -409,13 +409,13 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
             if (reduce) {                // Reduce the Rank to Scalar and free Dimensional Heap Memory
                 data_block->order = -1;
                 data_block->rank = 0;
-                if (ddim->dim != nullptr) free((void*)ddim->dim);
-                if (ddim->errhi != nullptr) free((void*)ddim->errhi);
-                if (ddim->errlo != nullptr) free((void*)ddim->errlo);
-                if (ddim->sams != nullptr) free((void*)ddim->sams);
-                if (ddim->offs != nullptr) free((void*)ddim->offs);
-                if (ddim->ints != nullptr) free((void*)ddim->ints);
-                free((void*)ddim);
+                if (ddim->dim != nullptr) free(ddim->dim);
+                if (ddim->errhi != nullptr) free(ddim->errhi);
+                if (ddim->errlo != nullptr) free(ddim->errlo);
+                if (ddim->sams != nullptr) free(ddim->sams);
+                if (ddim->offs != nullptr) free(ddim->offs);
+                if (ddim->ints != nullptr) free(ddim->ints);
+                free(ddim);
                 data_block->dims = nullptr;
             }
         }
@@ -445,16 +445,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((char*)ddim->offs + i);
                                         *(newints + i) = (double)*((char*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -463,7 +463,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((char*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -472,8 +472,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((char*)ddim->offs);
                                     *newints = (double)*((char*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -487,16 +487,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((short*)ddim->offs + i);
                                         *(newints + i) = (double)*((short*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -505,7 +505,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((short*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -514,8 +514,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((short*)ddim->offs);
                                     *newints = (double)*((short*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -529,16 +529,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((int*)ddim->offs + i);
                                         *(newints + i) = (double)*((int*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -547,7 +547,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((int*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -556,8 +556,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((int*)ddim->offs);
                                     *newints = (double)*((int*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -571,16 +571,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((long*)ddim->offs + i);
                                         *(newints + i) = (double)*((long*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -589,7 +589,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((long*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -598,8 +598,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((long*)ddim->offs);
                                     *newints = (double)*((long*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -613,16 +613,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((unsigned char*)ddim->offs + i);
                                         *(newints + i) = (double)*((unsigned char*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -631,7 +631,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((unsigned char*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -640,8 +640,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((unsigned char*)ddim->offs);
                                     *newints = (double)*((unsigned char*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -655,16 +655,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((unsigned short*)ddim->offs + i);
                                         *(newints + i) = (double)*((unsigned short*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -673,7 +673,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((unsigned short*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -682,8 +682,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((unsigned short*)ddim->offs);
                                     *newints = (double)*((unsigned short*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -697,16 +697,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((unsigned int*)ddim->offs + i);
                                         *(newints + i) = (double)*((unsigned int*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -715,7 +715,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((unsigned int*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -724,8 +724,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((unsigned int*)ddim->offs);
                                     *newints = (double)*((unsigned int*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -739,16 +739,16 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
                                     for (unsigned int i = 0; i < ddim->udoms; i++) {
                                         *(newoffs + i) = (double)*((unsigned long*)ddim->offs + i);
                                         *(newints + i) = (double)*((unsigned long*)ddim->ints + i);
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -757,7 +757,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((unsigned long*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -766,8 +766,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newints = (double*)malloc(sizeof(double));
                                     *newoffs = (double)*((unsigned long*)ddim->offs);
                                     *newints = (double)*((unsigned long*)ddim->ints);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
@@ -781,8 +781,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     newints = (double*)malloc(ddim->udoms * sizeof(double));
                                     if (newoffs == nullptr || newints == nullptr) {
-                                        if (newoffs != nullptr) free((void*)newoffs);
-                                        if (newints != nullptr) free((void*)newints);
+                                        if (newoffs != nullptr) free(newoffs);
+                                        if (newints != nullptr) free(newints);
                                         return 1;
                                     }
 
@@ -795,8 +795,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
 
                                         UDA_LOG(UDA_LOG_DEBUG, "%i  %f  %f\n", i, *(newoffs + i), *(newints + i));
                                     }
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
@@ -810,7 +810,7 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     newoffs = (double*)malloc(ddim->udoms * sizeof(double));
                                     for (unsigned int i = 0; i < ddim->udoms; i++)
                                         *(newoffs + i) = (double)*((float*)ddim->offs + i);
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
                                     ddim->offs = (char*)newoffs;
                                     ddim->data_type = UDA_TYPE_DOUBLE;
                                     break;
@@ -822,8 +822,8 @@ int serverProcessing(CLIENT_BLOCK client_block, DATA_BLOCK* data_block)
                                     *newints = (double)*((float*)ddim->ints);
                                     UDA_LOG(UDA_LOG_DEBUG, "%f  %f\n", *((double*)ddim->offs),
                                               *((double*)ddim->ints));
-                                    if (ddim->offs != nullptr) free((void*)ddim->offs);
-                                    if (ddim->ints != nullptr) free((void*)ddim->ints);
+                                    if (ddim->offs != nullptr) free(ddim->offs);
+                                    if (ddim->ints != nullptr) free(ddim->ints);
                                     ddim->offs = (char*)newoffs;
                                     ddim->ints = (char*)newints;
                                     UDA_LOG(UDA_LOG_DEBUG, "%f  %f\n", *((double*)ddim->offs),
diff --git a/source/server/serverProcessing.h b/source/server/serverProcessing.h
index 1e32a227..af8f4c65 100755
--- a/source/server/serverProcessing.h
+++ b/source/server/serverProcessing.h
@@ -2,12 +2,7 @@
 #define UDA_SERVER_SERVERPROCESSING_H
 
 #include <clientserver/udaStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/serverStartup.cpp b/source/server/serverStartup.cpp
index 745b4951..2a701d61 100755
--- a/source/server/serverStartup.cpp
+++ b/source/server/serverStartup.cpp
@@ -9,6 +9,7 @@
 
 #include <cstdlib>
 #include <cerrno>
+#include <string>
 
 #include <logging/logging.h>
 #include <clientserver/errorLog.h>
@@ -17,17 +18,15 @@
 
 int startup(void)
 {
-    char idamFile[STRING_LENGTH];
-
     //----------------------------------------------------------------
     // Read Environment Variable Values (Held in a Global Structure)
 
-    const ENVIRONMENT* environment = getIdamServerEnvironment();
+    const ENVIRONMENT* environment = getServerEnvironment();
 
     //---------------------------------------------------------------
     // Open the Log Files
 
-    idamSetLogLevel((LOG_LEVEL)environment->loglevel);
+    udaSetLogLevel((LOG_LEVEL)environment->loglevel);
 
     if (environment->loglevel <= UDA_LOG_ACCESS) {
         char cmd[STRING_LENGTH];
@@ -35,9 +34,8 @@ int startup(void)
         system(cmd);
 
         errno = 0;
-        strcpy(idamFile, environment->logdir);
-        strcat(idamFile, "Access.log");
-        FILE* accout = fopen(idamFile, environment->logmode);
+        std::string log_file = std::string{ environment->logdir } + "Access.log";
+        FILE* accout = fopen(log_file.c_str(), environment->logmode);
 
         if (errno != 0) {
             addIdamError(SYSTEMERRORTYPE, "startup", errno, "Access Log: ");
@@ -45,15 +43,14 @@ int startup(void)
                 fclose(accout);
             }
         } else {
-            idamSetLogFile(UDA_LOG_ACCESS, accout);
+            udaSetLogFile(UDA_LOG_ACCESS, accout);
         }
     }
 
     if (environment->loglevel <= UDA_LOG_ERROR) {
         errno = 0;
-        strcpy(idamFile, environment->logdir);
-        strcat(idamFile, "Error.log");
-        FILE* errout = fopen(idamFile, environment->logmode);
+        std::string log_file = std::string{ environment->logdir } + "Error.log";
+        FILE* errout = fopen(log_file.c_str(), environment->logmode);
 
         if (errno != 0) {
             addIdamError(SYSTEMERRORTYPE, "startup", errno, "Error Log: ");
@@ -61,15 +58,14 @@ int startup(void)
                 fclose(errout);
             }
         } else {
-            idamSetLogFile(UDA_LOG_ERROR, errout);
+            udaSetLogFile(UDA_LOG_ERROR, errout);
         }
     }
 
     if (environment->loglevel <= UDA_LOG_WARN) {
         errno = 0;
-        strcpy(idamFile, environment->logdir);
-        strcat(idamFile, "DebugServer.log");
-        FILE* dbgout = fopen(idamFile, environment->logmode);
+        std::string log_file = std::string{ environment->logdir } + "DebugServer.log";
+        FILE* dbgout = fopen(log_file.c_str(), environment->logmode);
 
         if (errno != 0) {
             addIdamError(SYSTEMERRORTYPE, "startup", errno, "Debug Log: ");
@@ -77,13 +73,13 @@ int startup(void)
                 fclose(dbgout);
             }
         } else {
-            idamSetLogFile(UDA_LOG_WARN, dbgout);
-            idamSetLogFile(UDA_LOG_DEBUG, dbgout);
-            idamSetLogFile(UDA_LOG_INFO, dbgout);
+            udaSetLogFile(UDA_LOG_WARN, dbgout);
+            udaSetLogFile(UDA_LOG_DEBUG, dbgout);
+            udaSetLogFile(UDA_LOG_INFO, dbgout);
         }
     }
 
-    printIdamServerEnvironment(environment);
+    printServerEnvironment(environment);
 
     return 0;
 }
diff --git a/source/server/serverStartup.h b/source/server/serverStartup.h
index a23da2c6..d0147a0d 100755
--- a/source/server/serverStartup.h
+++ b/source/server/serverStartup.h
@@ -1,11 +1,7 @@
 #ifndef UDA_SERVER_SERVERSTARTUP_H
 #define UDA_SERVER_SERVERSTARTUP_H
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/serverSubsetData.cpp b/source/server/serverSubsetData.cpp
index e7ceeb60..8239b0c5 100755
--- a/source/server/serverSubsetData.cpp
+++ b/source/server/serverSubsetData.cpp
@@ -45,16 +45,15 @@
 // todo:
 //
 
-static int idamserversubsetindices(char* operation, DIMS* dim, double value, unsigned int* subsetindices);
+static int serverSubsetIndices(char* operation, DIMS* dim, double value, unsigned int* subsetindices);
 
-static int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
-                            char* data, int ndata, int data_type, int notoperation, int reverse,
-                            int start, int end, int start1, int end1, int* n, void** newdata);
+static int serverNewDataArray2(DIMS* dims, int rank, int dimid,
+                               char* data, int ndata, int data_type, int notoperation, int reverse,
+                               int start, int end, int start1, int end1, int* n, void** newdata);
 
-int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* logmalloclist)
+int serverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* logmalloclist)
 {
     DIMS* dim;
-    //DIMS *rdims;
     DIMS newdim;
     SUBSET subset;
     char* operation;
@@ -89,10 +88,7 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
     if (data_block->rank > 2 &&
         !(action.actionType == SUBSETTYPE && !strncasecmp(action.subset.function, "rotateRZ", 8))) {
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                     "Not Configured to Subset Data with Rank Higher than 2");
-        return ierr;
+        THROW_ERROR(9999, "Not Configured to Subset Data with Rank Higher than 2");
     }
 
     //-----------------------------------------------------------------------------------------------------------------------
@@ -124,12 +120,10 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                     i, j, value, operation, dimid, subset.reform);
 
             if (dimid < 0 || dimid >= (int)data_block->rank) {
-                ierr = 9999;
-                UDA_LOG(UDA_LOG_ERROR, "Error ***    DIM id = %d,  Rank = %d, Test = %d \n",
+                UDA_LOG(UDA_LOG_ERROR, "DIM id = %d,  Rank = %d, Test = %d \n",
                         dimid, data_block->rank, dimid >= (int)data_block->rank);
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "Data Subsetting is Impossible as the subset Dimension is not Compatible with the Rank of the Signal");
                 printDataBlock(*data_block);
+                THROW_ERROR(9999, "Data Subsetting is Impossible as the subset Dimension is not Compatible with the Rank of the Signal");
                 return ierr;
             }
 
@@ -200,11 +194,7 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
                                             if ((shape = udt->compoundfield[i].shape) == nullptr &&
                                                 udt->compoundfield[i].rank > 1) {
-                                                ierr = 999;
-                                                addIdamError(CODEERRORTYPE, "idamserverSubsetData",
-                                                             ierr,
-                                                             "The Data Structure member's shape data is missing (rank > 1)");
-                                                return ierr;
+                                                THROW_ERROR(999, "The Data Structure member's shape data is missing (rank > 1)");
                                             }
 
                                         } else {        // mapType == 3
@@ -255,11 +245,7 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                             }
                                         } else {
                                             if (rank > 1) {
-                                                ierr = 999;
-                                                addIdamError(CODEERRORTYPE, "idamserverSubsetData",
-                                                             ierr,
-                                                             "The Data Structure member's shape data is missing (rank > 1)");
-                                                return ierr;
+                                                THROW_ERROR(999, "The Data Structure member's shape data is missing (rank > 1)");
                                             }
                                         }
                                     }
@@ -281,11 +267,8 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                 if (count >= 1 && data_n == 1) {
                                     mapType = 2;
                                 } else {
-                                    ierr = 999;
-                                    addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                                                 "Unable to subset an array of Data Structures when the target "
-                                                 "member is also an array. Functionality has not been implemented!)");
-                                    return ierr;
+                                    THROW_ERROR(999, "Unable to subset an array of Data Structures when the target "
+                                                     "member is also an array. Functionality has not been implemented!)")
                                 }
                             }
 
@@ -384,7 +367,7 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
                         if (logmalloclist != nullptr) {
                             freeMallocLogList(logmalloclist);
-                            free((void*)logmalloclist);
+                            free(logmalloclist);
                             logmalloclist = nullptr;
                         }
 
@@ -426,9 +409,9 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                 dim->compressed = 0;                    // Can't preserve this status after the subset has been applied
                 dim->method = 0;
 
-                if (dim->sams != nullptr) free((void*)dim->sams);
-                if (dim->offs != nullptr) free((void*)dim->offs);
-                if (dim->ints != nullptr) free((void*)dim->ints);
+                if (dim->sams != nullptr) free(dim->sams);
+                if (dim->offs != nullptr) free(dim->offs);
+                if (dim->ints != nullptr) free(dim->ints);
 
                 dim->udoms = 0;
                 dim->sams = nullptr;        // Avoid double freeing of Heap
@@ -498,12 +481,9 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                 if (STR_EQUALS(operation, "!<=")) strcpy(operation, ">");
                 if (STR_EQUALS(operation, "!>=")) strcpy(operation, "<");
 
-                if ((dim_n = idamserversubsetindices(operation, dim, value, subsetindices)) == 0) {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                                 "No Data were found that satisfies a subset");
-                    free((void*)subsetindices);
-                    return ierr;
+                if ((dim_n = serverSubsetIndices(operation, dim, value, subsetindices)) == 0) {
+                    free(subsetindices);
+                    THROW_ERROR(9999, "No Data were found that satisfies a subset");
                 }
 
                 // Start and End of Subset Ranges
@@ -527,22 +507,16 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                         range2 = end1 - start1 + 1;
                     }
                     if (dim_n != end - start + 1 + range2) {        // Dimension array is Not well ordered!
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                                     "The Dimensional Array is Not Ordered: Unable to Subset");
-                        free((void*)subsetindices);
-                        return ierr;
+                        free(subsetindices);
+                        THROW_ERROR(9999, "The Dimensional Array is Not Ordered: Unable to Subset");
                     }
                 } else {
                     if (dim_n != end - start + 1) {        // Dimension array is Not well ordered!
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                                     "The Dimensional Array is Not Ordered: Unable to Subset");
-                        free((void*)subsetindices);
-                        return ierr;
+                        free(subsetindices);
+                        THROW_ERROR(9999, "The Dimensional Array is Not Ordered: Unable to Subset");
                     }
                 }
-                free((void*)subsetindices);
+                free(subsetindices);
             }
 
             newdim.dim_n = dim_n;
@@ -555,22 +529,22 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
             UDA_LOG(UDA_LOG_DEBUG, "\n\n\n*** dim->errhi != nullptr: %d\n\n\n", dim->errhi != nullptr);
             UDA_LOG(UDA_LOG_DEBUG, "\n\n\n*** dim->errlo != nullptr: %d\n\n\n", dim->errlo != nullptr);
 
-            if ((ierr = idamserverNewDataArray2(dim, 1, dimid, dim->dim, dim_n, dim->data_type, notoperation, reverse,
-                                                start, end, start1, end1, &n, (void**)&newdim.dim)) != 0) {
+            if ((ierr = serverNewDataArray2(dim, 1, dimid, dim->dim, dim_n, dim->data_type, notoperation, reverse,
+                                            start, end, start1, end1, &n, (void**)&newdim.dim)) != 0) {
                 return ierr;
             }
 
             if (dim->errhi != nullptr && dim->error_type != UDA_TYPE_UNKNOWN) {
-                if ((ierr = idamserverNewDataArray2(dim, 1, dimid, dim->errhi, dim_n, dim->error_type, notoperation,
-                                                    reverse,
-                                                    start, end, start1, end1, &n, (void**)&newdim.errhi)) != 0)
+                if ((ierr = serverNewDataArray2(dim, 1, dimid, dim->errhi, dim_n, dim->error_type, notoperation,
+                                                reverse,
+                                                start, end, start1, end1, &n, (void**)&newdim.errhi)) != 0)
                     return ierr;
             }
 
             if (dim->errlo != nullptr && dim->error_type != UDA_TYPE_UNKNOWN) {
-                if ((ierr = idamserverNewDataArray2(dim, 1, dimid, dim->errlo, dim_n, dim->error_type, notoperation,
-                                                    reverse,
-                                                    start, end, start1, end1, &n, (void**)&newdim.errlo)) != 0)
+                if ((ierr = serverNewDataArray2(dim, 1, dimid, dim->errlo, dim_n, dim->error_type, notoperation,
+                                                reverse,
+                                                start, end, start1, end1, &n, (void**)&newdim.errlo)) != 0)
                     return ierr;
             }
 
@@ -579,35 +553,35 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
             printDataBlock(*data_block);
 
-            if ((ierr = idamserverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->data,
-                                                data_block->data_n, data_block->data_type, notoperation, reverse,
-                                                start, end, start1, end1, &ndata, (void**)&newdata)) != 0) {
+            if ((ierr = serverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->data,
+                                            data_block->data_n, data_block->data_type, notoperation, reverse,
+                                            start, end, start1, end1, &ndata, (void**)&newdata)) != 0) {
                 return ierr;
             }
 
             if (data_block->error_type != UDA_TYPE_UNKNOWN && data_block->errhi != nullptr) {
-                if ((ierr = idamserverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->errhi,
-                                                    data_block->data_n, data_block->error_type, notoperation, reverse,
-                                                    start, end, start1, end1, &n, (void**)&newerrhi)) != 0) {
+                if ((ierr = serverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->errhi,
+                                                data_block->data_n, data_block->error_type, notoperation, reverse,
+                                                start, end, start1, end1, &n, (void**)&newerrhi)) != 0) {
                     return ierr;
                 }
-                free((void*)data_block->errhi);                // Free Original Heap
+                free(data_block->errhi);                // Free Original Heap
                 data_block->errhi = newerrhi;                // Replace with the Reshaped Array
             }
 
             if (data_block->error_type != UDA_TYPE_UNKNOWN && dim->errlo != nullptr) {
-                if ((ierr = idamserverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->errlo,
-                                                    data_block->data_n, data_block->error_type, notoperation, reverse,
-                                                    start, end, start1, end1, &n, (void**)&newerrlo)) != 0) {
+                if ((ierr = serverNewDataArray2(data_block->dims, data_block->rank, dimid, data_block->errlo,
+                                                data_block->data_n, data_block->error_type, notoperation, reverse,
+                                                start, end, start1, end1, &n, (void**)&newerrlo)) != 0) {
                     return ierr;
                 }
-                free((void*)data_block->errlo);                // Free Original Heap
+                free(data_block->errlo);                // Free Original Heap
                 data_block->errlo = newerrlo;                // Replace with the Reshaped Array
             }
 
             data_block->data_n = ndata;
 
-            free((void*)data_block->data);                // Free Original Heap
+            free(data_block->data);                // Free Original Heap
             data_block->data = newdata;                    // Replace with the Reshaped Array
 
             // replace the Original Dimensional Structure with the New Subsetted Structure unless a
@@ -615,9 +589,9 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
             // Free Heap associated with the original Dimensional Structure Array
 
-            if (dim->dim != nullptr) free((void*)dim->dim);
-            if (dim->errlo != nullptr) free((void*)dim->errlo);
-            if (dim->errhi != nullptr) free((void*)dim->errhi);
+            free(dim->dim);
+            free(dim->errlo);
+            free(dim->errhi);
 
             dim->dim = nullptr;
             dim->errlo = nullptr;
@@ -641,12 +615,12 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                 data_block->dims[j].compressed = 0;
                 data_block->dims[j].method = 0;
 
-                if (data_block->dims[j].dim != nullptr) free((void*)data_block->dims[j].dim);
-                if (data_block->dims[j].errlo != nullptr) free((void*)data_block->dims[j].errlo);
-                if (data_block->dims[j].errhi != nullptr) free((void*)data_block->dims[j].errhi);
-                if (data_block->dims[j].sams != nullptr) free((void*)data_block->dims[j].sams);
-                if (data_block->dims[j].offs != nullptr) free((void*)data_block->dims[j].offs);
-                if (data_block->dims[j].ints != nullptr) free((void*)data_block->dims[j].ints);
+                if (data_block->dims[j].dim != nullptr) free(data_block->dims[j].dim);
+                if (data_block->dims[j].errlo != nullptr) free(data_block->dims[j].errlo);
+                if (data_block->dims[j].errhi != nullptr) free(data_block->dims[j].errhi);
+                if (data_block->dims[j].sams != nullptr) free(data_block->dims[j].sams);
+                if (data_block->dims[j].offs != nullptr) free(data_block->dims[j].offs);
+                if (data_block->dims[j].ints != nullptr) free(data_block->dims[j].ints);
 
                 for (int k = j + 1; k < rank; k++) {
                     data_block->dims[k - 1] = data_block->dims[k];            // Shift array contents
@@ -690,12 +664,9 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
             }
 
             if (dimid < 0 || dimid >= (int)data_block->rank) {
-                ierr = 999;
                 UDA_LOG(UDA_LOG_ERROR, "Function Syntax Error -  dimid = %d,  Rank = %d\n", dimid,
                         data_block->rank);
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "The dimension ID identified via the subset function is outside the rank bounds of the array!");
-                return ierr;
+                THROW_ERROR(999, "The dimension ID identified via the subset function is outside the rank bounds of the array!");
             }
 
             switch (data_block->data_type) {
@@ -724,8 +695,8 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                             dp = (float*)realloc((void*)dp, sizeof(float));        // Reduce array size
                             data_block->rank = 0;
                             data_block->data_n = 1;
-                            free((void*)data_block->dims[0].dim);
-                            free((void*)data_block->dims);
+                            free(data_block->dims[0].dim);
+                            free(data_block->dims);
                             data_block->dims = nullptr;
                             break;
                         }
@@ -743,11 +714,11 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                     }
                                     ddp[i] = min;
                                 }
-                                free((void*)dp);
+                                free(dp);
                                 data_block->rank = 1;
                                 data_block->data_n = data_block->dims[1].dim_n;
                                 data_block->data = (char*)ddp;
-                                free((void*)data_block->dims[0].dim);
+                                free(data_block->dims[0].dim);
                                 data_block->dims[0] = data_block->dims[1];
                             } else {
                                 ddp = (float*)malloc(data_block->dims[0].dim_n * sizeof(float));
@@ -761,11 +732,11 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                     }
                                     ddp[j] = min;
                                 }
-                                free((void*)dp);
+                                free(dp);
                                 data_block->rank = 1;
                                 data_block->data_n = data_block->dims[0].dim_n;
                                 data_block->data = (char*)ddp;
-                                free((void*)data_block->dims[1].dim);
+                                free(data_block->dims[1].dim);
                                 break;
                             }
                             break;
@@ -802,8 +773,8 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                             dp = (double*)realloc((void*)dp, sizeof(double));        // Reduce array size
                             data_block->rank = 0;
                             data_block->data_n = 1;
-                            free((void*)data_block->dims[0].dim);
-                            free((void*)data_block->dims);
+                            free(data_block->dims[0].dim);
+                            free(data_block->dims);
                             data_block->dims = nullptr;
                             break;
                         }
@@ -821,11 +792,11 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                     }
                                     ddp[i] = min;
                                 }
-                                free((void*)dp);
+                                free(dp);
                                 data_block->rank = 1;
                                 data_block->data_n = data_block->dims[1].dim_n;
                                 data_block->data = (char*)ddp;
-                                free((void*)data_block->dims[0].dim);
+                                free(data_block->dims[0].dim);
                                 data_block->dims[0] = data_block->dims[1];
                             } else {
                                 ddp = (double*)malloc(data_block->dims[0].dim_n * sizeof(double));
@@ -839,11 +810,11 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                                     }
                                     ddp[j] = min;
                                 }
-                                free((void*)dp);
+                                free(dp);
                                 data_block->rank = 1;
                                 data_block->data_n = data_block->dims[0].dim_n;
                                 data_block->data = (char*)ddp;
-                                free((void*)data_block->dims[1].dim);
+                                free(data_block->dims[1].dim);
                                 break;
                             }
                             break;
@@ -889,18 +860,18 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                 if (dimid < (int)data_block->rank) {
                     count[0] = (unsigned int)data_block->dims[dimid].dim_n;        // Preserve this value
                     DIMS ddim = data_block->dims[dimid];
-                    if (ddim.dim != nullptr) free((void*)ddim.dim);
-                    if (ddim.errhi != nullptr) free((void*)ddim.errhi);
-                    if (ddim.errlo != nullptr) free((void*)ddim.errlo);
-                    if (ddim.sams != nullptr) free((void*)ddim.sams);
-                    if (ddim.offs != nullptr) free((void*)ddim.offs);
-                    if (ddim.ints != nullptr) free((void*)ddim.ints);
+                    if (ddim.dim != nullptr) free(ddim.dim);
+                    if (ddim.errhi != nullptr) free(ddim.errhi);
+                    if (ddim.errlo != nullptr) free(ddim.errlo);
+                    if (ddim.sams != nullptr) free(ddim.sams);
+                    if (ddim.offs != nullptr) free(ddim.offs);
+                    if (ddim.ints != nullptr) free(ddim.ints);
                 } else {
                     // ERROR
                 }
-                if (data_block->data != nullptr) free((void*)data_block->data);
-                if (data_block->errhi != nullptr) free((void*)data_block->errhi);
-                if (data_block->errlo != nullptr) free((void*)data_block->errlo);
+                if (data_block->data != nullptr) free(data_block->data);
+                if (data_block->errhi != nullptr) free(data_block->errhi);
+                if (data_block->errlo != nullptr) free(data_block->errlo);
                 data_block->data = nullptr;
                 data_block->errhi = nullptr;
                 data_block->errlo = nullptr;
@@ -973,8 +944,8 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 
             UDA_LOG(UDA_LOG_DEBUG, "value = %f\n", value);
 
-            if (data_block->errhi != nullptr) free((void*)data_block->errhi);
-            if (data_block->errlo != nullptr) free((void*)data_block->errlo);
+            if (data_block->errhi != nullptr) free(data_block->errhi);
+            if (data_block->errlo != nullptr) free(data_block->errlo);
             data_block->errhi = nullptr;
             data_block->errlo = nullptr;
             data_block->error_type = UDA_TYPE_UNKNOWN;
@@ -1025,24 +996,15 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
         if (!strncasecmp(subset.function, "rotateRZ", 8)) {        // Rotate R,Z coordinates in rank 3 array
             UDA_LOG(UDA_LOG_DEBUG, "%s\n", subset.function);
             if (data_block->rank != 3) {
-                ierr = 999;
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "The function rotateRZ only operates on rank 3 arrays");
-                return ierr;
+                THROW_ERROR(999, "The function rotateRZ only operates on rank 3 arrays");
             }
             int order = data_block->order;
             if (order < 0) {
-                ierr = 999;
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "The function rotateRZ expects a Time coordinate");
-                return ierr;
+                THROW_ERROR(999, "The function rotateRZ expects a Time coordinate");
             }
             int type = data_block->data_type;
             if (type != UDA_TYPE_DOUBLE) {
-                ierr = 999;
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "The function rotateRZ is configured for type DOUBLE only");
-                return ierr;
+                THROW_ERROR(999, "The function rotateRZ is configured for type DOUBLE only");
             }
             int nt, nr, nz, count;
             count = data_block->data_n;
@@ -1068,20 +1030,17 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                         for (int k = 0; k < nt; k++)
                             newData[offset++] = data[j][i][k];
                 for (int j = 0; j < nz; j++) {
-                    for (int i = 0; i < nr; i++) free((void*)data[j][i]);
-                    free((void*)data[j]);
+                    for (int i = 0; i < nr; i++) free(data[j][i]);
+                    free(data[j]);
                 }
-                free((void*)data);
+                free(data);
 
                 DIMS d1 = data_block->dims[1];
                 DIMS d2 = data_block->dims[2];
                 data_block->dims[1] = d2;
                 data_block->dims[2] = d1;
             } else if (order == 1) {        // array[nz][nt][nr]
-                ierr = 999;
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "The function rotateRZ only operates on arrays with shape [nz][nr][nt] or [nt][nz][nr]");
-                return ierr;
+                THROW_ERROR(999, "The function rotateRZ only operates on arrays with shape [nz][nr][nt] or [nt][nz][nr]");
             } else if (order == 2) {        // array[nt][nz][nr] -> [nt][nr][nz]
                 nr = data_block->dims[0].dim_n;
                 nz = data_block->dims[1].dim_n;
@@ -1101,21 +1060,18 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
                         for (int j = 0; j < nz; j++)
                             newData[offset++] = data[k][j][i];
                 for (int k = 0; k < nt; k++) {
-                    for (int j = 0; j < nz; j++)free((void*)data[k][j]);
-                    free((void*)data[k]);
+                    for (int j = 0; j < nz; j++)free(data[k][j]);
+                    free(data[k]);
                 }
-                free((void*)data);
+                free(data);
                 DIMS d0 = data_block->dims[0];
                 DIMS d1 = data_block->dims[1];
                 data_block->dims[0] = d1;
                 data_block->dims[1] = d0;
             } else {
-                ierr = 999;
-                addIdamError(CODEERRORTYPE, "idamserverSubsetData", ierr,
-                             "rotateRZ: Incorrect ORDER value found!");
-                return ierr;
+                THROW_ERROR(999, "rotateRZ: Incorrect ORDER value found!");
             }
-            free((void*)data_block->data);
+            free(data_block->data);
             data_block->data = (char*)newData;
         }
 
@@ -1147,7 +1103,7 @@ int idamserverSubsetData(DATA_BLOCK* data_block, ACTION action, LOGMALLOCLIST* l
 // SS::SUBSET(\"xx\", [*, 3], member=\"name\", reform, function=\"minimum(dimid=0)\" )
 
 
-int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_serverside)
+int serverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_serverside)
 {
 
     char qchar[2];
@@ -1174,12 +1130,9 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
     strncpy(qchar, request_block->signal + 7, 1);
     qchar[1] = '\0';
 
-    if ((p = strstr(request_block->signal + 8, qchar)) == nullptr) {    // Locate the terminating quotation character
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Syntax Error: The Signal Name has no Terminating "
-                     "Quotation character! ");
-        return ierr;
+    if ((p = strstr(request_block->signal + 8, qchar)) == nullptr) {
+        // Locate the terminating quotation character
+        THROW_ERROR(9999, "Syntax Error: The Signal Name has no Terminating Quotation character!");
     }
 
     lsignal = (int)(p - request_block->signal) - 8;            // Signal name Length
@@ -1198,25 +1151,18 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
     //-------------------------------------------------------------------------------------------------------------
     // Extract the Subset Operation
 
-    if ((t1 = strstr(p + 1, ",")) == nullptr) {    // Locate the separation character
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Syntax Error: No Comma after the Signal Name ");
-        return ierr;
+    if ((t1 = strstr(p + 1, ",")) == nullptr) {
+        // Locate the separation character
+        THROW_ERROR(9999, "Syntax Error: No Comma after the Signal Name");
     }
 
-    if ((t1 = strstr(t1 + 1, "[")) == nullptr) {    // Locate the Operation
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Syntax Error: No [ enclosing the Operation ");
-        return ierr;
+    if ((t1 = strstr(t1 + 1, "[")) == nullptr) {
+        // Locate the Operation
+        THROW_ERROR(9999, "Syntax Error: No [ enclosing the Operation");
     }
 
     if ((t2 = strstr(t1 + 1, "]")) == nullptr) {
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Syntax Error: No ] enclosing the Operation ");
-        return ierr;
+        THROW_ERROR(9999, "Syntax Error: No ] enclosing the Operation ");
     }
 
     strncpy(operation, t1 + 1, t2 - t1 - 1);    // The Requested Operation including Values
@@ -1233,7 +1179,7 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
     // Overwrite the Request Block to enable the correct access to signal data before the subset operations are applied
 
     strcpy(request_block->archive, archive);
-    if (request_block->archive[0] == '\0') strcpy(request_block->archive, getIdamServerEnvironment()->api_archive);
+    if (request_block->archive[0] == '\0') strcpy(request_block->archive, getServerEnvironment()->api_archive);
 
     strcpy(request_block->signal, signal);
 
@@ -1242,10 +1188,7 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
 
     nactions = actions_serverside->nactions + 1;
     if ((action = (ACTION*)realloc((void*)actions_serverside->action, nactions * sizeof(ACTION))) == nullptr) {
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Unable to Allocate Heap memory");
-        return ierr;
+        THROW_ERROR(9999, "Unable to Allocate Heap memory");
     }
 
     initAction(&action[nactions - 1]);
@@ -1258,10 +1201,7 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
 
     nsubsets = 1;
     if ((subsets = (SUBSET*)malloc(sizeof(SUBSET))) == nullptr) {
-        ierr = 9999;
-        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                     "Unable to Allocate Heap memory");
-        return ierr;
+        THROW_ERROR(9999, "Unable to Allocate Heap memory");
     }
 
     for (int i = 0; i < nsubsets; i++) {
@@ -1315,32 +1255,23 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
             strcpy(subsets[nsubsets - 1].operation[nbound - 1], p);
             MidTrimString(subsets[nsubsets - 1].operation[nbound - 1]);    // Remove internal white space
         } else {
-            ierr = 9999;
-            addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                         "Syntax Error: The Signal Operation String is too long ");
-            free((void*)subsets);
-            return ierr;
+            free(subsets);
+            THROW_ERROR(9999, "Syntax Error: The Signal Operation String is too long");
         }
 
         while ((p = strtok(nullptr, ",")) != nullptr) {
             subsets[nsubsets - 1].dimid[nbound] = nbound;
             nbound++;
             if (nbound > MAXDATARANK) {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                             "The number of Dimensional Operations exceeds the Internal Limit ");
-                free((void*)subsets);
-                return ierr;
+                free(subsets);
+                THROW_ERROR(9999, "The number of Dimensional Operations exceeds the Internal Limit");
             }
             if (strlen(p) < SXMLMAXSTRING) {
                 strcpy(subsets[nsubsets - 1].operation[nbound - 1], p);
                 MidTrimString(subsets[nsubsets - 1].operation[nbound - 1]);    // Remove white space
             } else {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                             "Syntax Error: The Signal Operation String is too long ");
-                free((void*)subsets);
-                return ierr;
+                free(subsets);
+                THROW_ERROR(9999, "Syntax Error: The Signal Operation String is too long");
             }
         }
     }
@@ -1379,18 +1310,12 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
                     subsets[nsubsets - 1].lbindex[i] = strtol(t1, &endp,
                                                               0);        // the Lower Index Value of the Bound
                     if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                     "Server Side Operation Syntax Error: Lower Index Bound ");
-                        free((void*)subsets);
-                        return ierr;
+                        free(subsets);
+                        THROW_ERROR(9999, "Server Side Operation Syntax Error: Lower Index Bound");
                     }
                 } else {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                 "Server Side Operation Syntax Error: Lower Index Bound ");
-                    free((void*)subsets);
-                    return ierr;
+                    free(subsets);
+                    THROW_ERROR(9999, "Server Side Operation Syntax Error: Lower Index Bound");
                 }
             }
             if (strlen(t2) > 0 && t2[0] != '*' && t2[0] != '#') {
@@ -1398,18 +1323,12 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
                     subsets[nsubsets - 1].ubindex[i] = strtol(t2, &endp,
                                                               0);        // the Upper Index Value of the Bound
                     if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-                        ierr = 9999;
-                        addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                     "Server Side Operation Syntax Error: Upper Index Bound ");
-                        free((void*)subsets);
-                        return ierr;
+                        free(subsets);
+                        THROW_ERROR(9999, "Server Side Operation Syntax Error: Upper Index Bound");
                     }
                 } else {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                 "Server Side Operation Syntax Error: Upper Index Bound ");
-                    free((void*)subsets);
-                    return ierr;
+                    free(subsets);
+                    THROW_ERROR(9999, "Server Side Operation Syntax Error: Upper Index Bound");
                 }
             }
             strcpy(subsets[nsubsets - 1].operation[i], ":");        // Define Simple Operation
@@ -1436,11 +1355,8 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
             subsets[nsubsets - 1].isindex[i] = 1;
             subsets[nsubsets - 1].ubindex[i] = strtol(opcopy, &endp, 0);        // the Index Value of the Bound
             if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                             "Server Side Operation Syntax Error: Single Index Bound ");
-                free((void*)subsets);
-                return ierr;
+                free(subsets);
+                THROW_ERROR(9999, "Server Side Operation Syntax Error: Single Index Bound");
             }
             subsets[nsubsets - 1].lbindex[i] = subsets[nsubsets - 1].ubindex[i];
             strcpy(subsets[nsubsets - 1].operation[i], ":");        // Define Simple Operation
@@ -1460,37 +1376,27 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
                         p = &subsets[nsubsets - 1].operation[i][j - 1];
                     }
                 } else {
-                    ierr = 9999;
-                    addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                                 "Server Side Operation Syntax Error: No Operator Defined! ");
-                    free((void*)subsets);
-                    return ierr;
+                    free(subsets);
+                    THROW_ERROR(9999, "Server Side Operation Syntax Error: No Operator Defined!");
                 }
                 break;
             }
         }
 
         if (p == nullptr) {
-            ierr = 9999;
-            addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                         "Server Side Operation Syntax Error: No Numerical Bound ");
-            free((void*)subsets);
-            return ierr;
+            free(subsets);
+            THROW_ERROR(9999, "Server Side Operation Syntax Error: No Numerical Bound");
         }
 
         subsets[nsubsets - 1].bound[i] = strtod(p, &endp);            // the Value of the Bound
 
         if (*endp != '\0' || errno == EINVAL || errno == ERANGE) {
-            ierr = 9999;
-            addIdamError(CODEERRORTYPE, "idamserverParseServerSide", ierr,
-                         "Server Side Operation Syntax Error ");
-            free((void*)subsets);
-            return ierr;
+            free(subsets);
+            THROW_ERROR(9999, "Server Side Operation Syntax Error");
         }
 
-        subsets[nsubsets - 1].operation[i][p - &subsets[nsubsets -
-                                                        1].operation[i][0]] = '\0';    // Isolate the Operation only
-
+        // Isolate the Operation only
+        subsets[nsubsets - 1].operation[i][p - &subsets[nsubsets - 1].operation[i][0]] = '\0';
     }
 
     action[nactions - 1].serverside.nsubsets = nsubsets;
@@ -1499,17 +1405,15 @@ int idamserverParseServerSide(REQUEST_BLOCK* request_block, ACTIONS* actions_ser
     actions_serverside->action = action;
     actions_serverside->nactions = nactions;
 
-    return (ierr);
-
+    return ierr;
 }
 
 
 //----------------------------------------------------------------------------------------------------------------------
 // Identify the Index Range satisfying a small set of conditional operators
 
-int idamserversubsetindices(char* operation, DIMS* dim, double value, unsigned int* subsetindices)
+int serverSubsetIndices(char* operation, DIMS* dim, double value, unsigned int* subsetindices)
 {
-
     int count = 0;
 
     // Scan the Array applying the Operation
@@ -1751,9 +1655,9 @@ int idamserversubsetindices(char* operation, DIMS* dim, double value, unsigned i
 }
 
 
-int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
-                            char* data, int ndata, int data_type, int notoperation, int reverse,
-                            int start, int end, int start1, int end1, int* n, void** newdata)
+int serverNewDataArray2(DIMS* dims, int rank, int dimid,
+                        char* data, int ndata, int data_type, int notoperation, int reverse,
+                        int start, int end, int start1, int end1, int* n, void** newdata)
 {
 
     int ierr = 0, rows, columns, newrows, newcols, count = 0;
@@ -1772,10 +1676,7 @@ int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
             // Allocate heap for the reshaped array
 
             if ((p = (float*)malloc(ndata * sizeof(float))) == nullptr) {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverNewDataArray", ierr,
-                             "Unable to Allocate Heap memory");
-                return ierr;
+                THROW_ERROR(9999, "Unable to Allocate Heap memory");
             }
 
             dp = (float*)data;        // the Originating Data Array
@@ -1903,10 +1804,7 @@ int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
             // Allocate heap for the reshaped array
 
             if ((p = (double*)malloc(ndata * sizeof(double))) == nullptr) {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverNewDataArray", ierr,
-                             "Unable to Allocate Heap memory");
-                return ierr;
+                THROW_ERROR(9999, "Unable to Allocate Heap memory");
             }
 
             dp = (double*)data;        // the Originating Data Array
@@ -2034,10 +1932,7 @@ int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
             // Allocate heap for the reshaped array
 
             if ((p = (int*)malloc(ndata * sizeof(int))) == nullptr) {
-                ierr = 9999;
-                addIdamError(CODEERRORTYPE, "idamserverNewDataArray", ierr,
-                             "Unable to Allocate Heap memory");
-                return ierr;
+                THROW_ERROR(9999, "Unable to Allocate Heap memory");
             }
 
             dp = (int*)data;        // the Originating Data Array
@@ -2158,15 +2053,9 @@ int idamserverNewDataArray2(DIMS* dims, int rank, int dimid,
         }
 
         default:
-            ierr = 9999;
-            addIdamError(CODEERRORTYPE, "idamserverNewDataArray", ierr,
-                         "Only Float, Double and 32 bit Signed Integer Numerical Types can be Subset at this time!");
-
-            UDA_LOG(UDA_LOG_ERROR,
-                    "ERROR - Only Float, Double and 32 bit Signed Integer Numerical Types can be Subset at this time!\n");
+            UDA_LOG(UDA_LOG_ERROR, "Only Float, Double and 32 bit Signed Integer Numerical Types can be Subset at this time!\n");
             UDA_LOG(UDA_LOG_ERROR, "Data Type: %d    Rank: %d\n", data_type, rank);
-
-            return ierr;
+            THROW_ERROR(9999, "Only Float, Double and 32 bit Signed Integer Numerical Types can be Subset at this time!");
     }
 
     return ierr;
diff --git a/source/server/serverSubsetData.h b/source/server/serverSubsetData.h
index 40cffb1a..58ca2f09 100755
--- a/source/server/serverSubsetData.h
+++ b/source/server/serverSubsetData.h
@@ -4,19 +4,14 @@
 #include <clientserver/parseXML.h>
 #include <clientserver/udaStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int idamserverSubsetData(DATA_BLOCK *data_block, ACTION action, LOGMALLOCLIST* logmalloclist);
-LIBRARY_API int idamserverParseServerSide(REQUEST_BLOCK *request_block, ACTIONS *actions_serverside);
+LIBRARY_API int serverSubsetData(DATA_BLOCK *data_block, ACTION action, LOGMALLOCLIST* logmalloclist);
+LIBRARY_API int serverParseServerSide(REQUEST_BLOCK *request_block, ACTIONS *actions_serverside);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/sleepServer.h b/source/server/sleepServer.h
index 61eee845..9bc72240 100755
--- a/source/server/sleepServer.h
+++ b/source/server/sleepServer.h
@@ -2,12 +2,7 @@
 #define UDA_SERVER_SLEEPSERVER_H
 
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/udaLegacyServer.cpp b/source/server/udaLegacyServer.cpp
index 06d3d600..7ad7ac99 100755
--- a/source/server/udaLegacyServer.cpp
+++ b/source/server/udaLegacyServer.cpp
@@ -37,8 +37,8 @@ int idamLegacyServer(CLIENT_BLOCK client_block) {
 
 // Legacy Server Entry point
 
-int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
-                     USERDEFINEDTYPELIST* userdefinedtypelist, SOCKETLIST* socket_list, int protocolVersion)
+int legacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
+                 USERDEFINEDTYPELIST* userdefinedtypelist, SOCKETLIST* socket_list, int protocolVersion)
 {
 
     int rc, err = 0, depth, fatal = 0;
@@ -109,8 +109,8 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, nullptr, logmalloclist, userdefinedtypelist,
                                     &client_block, protocolVersion)) != 0) {
-                    UDA_LOG(UDA_LOG_DEBUG, "IdamServer: Problem Receiving Client Data Block\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    UDA_LOG(UDA_LOG_DEBUG, "Problem Receiving Client Data Block\n");
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 10 Error (Receiving Client Block)");
                     concatIdamError(&server_block.idamerrorstack);
                     closeIdamError();
@@ -136,7 +136,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             // The client request may originate from a server.
             // Is the Originating server an externally facing server? If so then switch to this mode: preserve local access policy
 
-            ENVIRONMENT* environment = getIdamServerEnvironment();
+            ENVIRONMENT* environment = getServerEnvironment();
 
             if (!environment->external_user && (privateFlags & PRIVATEFLAG_EXTERNAL)) environment->external_user = 1;
 
@@ -155,7 +155,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &server_block, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Server Data Block\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 11 Error (Sending Server Block #1)");
                     concatIdamError(&server_block.idamerrorstack); // Update Server State with Error Stack
                     closeIdamError();
@@ -186,7 +186,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, nullptr, logmalloclist, userdefinedtypelist,
                                 &request_block, protocolVersion)) != 0) {
                 UDA_LOG(UDA_LOG_DEBUG, "Problem Receiving Client Request Block\n");
-                addIdamError(CODEERRORTYPE, "idamServer", err,
+                addIdamError(CODEERRORTYPE, __func__, err,
                              "Protocol 1 Error (Receiving Client Request)");
                 break;
             }
@@ -226,7 +226,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if(client_block.version < 6) {
                     err = 999;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "PROXY redirection: Originating Client Version not compatible with the PROXY server interface.");
                     break;
                 }
@@ -241,7 +241,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if(strstr(request_block.source, work) != nullptr) {
                     err = 999;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "PROXY redirection: The PROXY is calling itself - Recursive server calls are not advisable!");
                     break;
                 }
@@ -250,7 +250,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if(strlen(request_block.source) >= (STRING_LENGTH-1 - strlen(environment->server_proxy) - 4+strlen(request_block.api_delim))) {
                     err = 999;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "PROXY redirection: The source argument string is too long!");
                     break;
                 }
@@ -278,7 +278,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             //----------------------------------------------------------------------
             // Write to the Access Log
 
-            idamAccessLog(TRUE, client_block, request_block, server_block, pluginlist, getIdamServerEnvironment());
+            udaAccessLog(TRUE, client_block, request_block, server_block, pluginlist, getServerEnvironment());
 
             //----------------------------------------------------------------------
             // Initialise Data Structures
@@ -300,7 +300,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                                     &(request_block.putDataBlockList), protocolVersion)) !=
                     0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Receiving putData Block List\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 1 Error (Receiving Client putDataBlockList)");
                     break;
                 }
@@ -317,12 +317,12 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             // Decide on Authentication procedure
 
             if (protocolVersion >= 6) {
-                if ((err = idamServerPlugin(&request_block, &data_source, &signal_desc, pluginlist,
-                                            getIdamServerEnvironment())) != 0) {
+                if ((err = udaServerPlugin(&request_block, &data_source, &signal_desc, pluginlist,
+                                           getServerEnvironment())) != 0) {
                     break;
                 }
             } else {
-                if ((err = idamServerLegacyPlugin(&request_block, &data_source, &signal_desc)) != 0) break;
+                if ((err = udaServerLegacyPlugin(&request_block, &data_source, &signal_desc)) != 0) break;
             }
 
             //------------------------------------------------------------------------------------------------
@@ -363,7 +363,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             if (client_block.get_dimdble || client_block.get_timedble || client_block.get_scalar) {
                 if (serverProcessing(client_block, &data_block) != 0) {
                     err = 779;
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Server-Side Processing Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Server-Side Processing Error");
                     break;
                 }
             }
@@ -378,7 +378,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 (protocolVersionTypeTest(protocolVersion, data_block.data_type) ||
                  protocolVersionTypeTest(protocolVersion, data_block.error_type))) {
                 err = 999;
-                addIdamError(CODEERRORTYPE, "idamServer", err,
+                addIdamError(CODEERRORTYPE, __func__, err,
                              "The Data has a type that cannot be passed to the Client: A newer client library version is required.");
                 break;
             }
@@ -390,7 +390,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                     if (protocolVersionTypeTest(protocolVersion, dim.data_type) ||
                         protocolVersionTypeTest(protocolVersion, dim.error_type)) {
                         err = 999;
-                        addIdamError(CODEERRORTYPE, "idamServer", err,
+                        addIdamError(CODEERRORTYPE, __func__, err,
                                      "A Coordinate Data has a numerical type that cannot be passed to the Client: A newer client library version is required.");
                         break;
                     }
@@ -428,7 +428,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                 &server_block, protocolVersion)) != 0) {
                 UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Server Data Block #2\n");
-                addIdamError(CODEERRORTYPE, "idamServer", err,
+                addIdamError(CODEERRORTYPE, __func__, err,
                              "Protocol 11 Error (Sending Server Block #2)");
                 break;
             }
@@ -459,7 +459,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, &next_protocol, logmalloclist,
                                     userdefinedtypelist, nullptr, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem #1 Receiving Next Protocol ID\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 3 (Next Protocol #1) Error");
                     break;
                 }
@@ -470,7 +470,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if (next_protocol != PROTOCOL_DATA_SYSTEM) {
                     err = 998;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 3 Error: Protocol Request Inconsistency");
                     break;
                 }
@@ -483,7 +483,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &data_system, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Data System Structure\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 4 Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Protocol 4 Error");
                     break;
                 }
 
@@ -495,7 +495,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &system_config, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending System Configuration Structure\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 5 Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Protocol 5 Error");
                     break;
                 }
 
@@ -507,7 +507,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &data_source, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Data Source Structure\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 6 Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Protocol 6 Error");
                     break;
                 }
 
@@ -519,7 +519,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &signal_rec, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Signal Structure\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 7 Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Protocol 7 Error");
                     break;
                 }
 
@@ -531,7 +531,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &signal_desc, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Signal Description Structure\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 8 Error");
+                    addIdamError(CODEERRORTYPE, __func__, err, "Protocol 8 Error");
                     break;
                 }
 
@@ -545,7 +545,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, &next_protocol, logmalloclist,
                                 userdefinedtypelist, nullptr, protocolVersion)) != 0) {
                 UDA_LOG(UDA_LOG_DEBUG, "Problem #2 Receiving Next Protocol ID\n");
-                addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 3 (Next Protocol #2) Error");
+                addIdamError(CODEERRORTYPE, __func__, err, "Protocol 3 (Next Protocol #2) Error");
                 break;
             }
 
@@ -558,7 +558,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
             if (next_protocol != PROTOCOL_DATA_BLOCK) {
                 err = 997;
-                addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 3 Error: Incorrect Request");
+                addIdamError(CODEERRORTYPE, __func__, err, "Protocol 3 Error: Incorrect Request");
                 break;
             }
 
@@ -570,7 +570,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
             if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                 &data_block, protocolVersion)) != 0) {
                 UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Data Structure\n");
-                addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 2 Error");
+                addIdamError(CODEERRORTYPE, __func__, err, "Protocol 2 Error");
                 break;
             }
 
@@ -586,14 +586,14 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
                 if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, &next_protocol, logmalloclist,
                                     userdefinedtypelist, nullptr, protocolVersion)) != 0) {
                     UDA_LOG(UDA_LOG_DEBUG, "Problem #2a Receiving Next Protocol ID\n");
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Protocol 3 (Next Protocol #2) Error");
                     break;
                 }
 
                 if (next_protocol != PROTOCOL_STRUCTURES) {
                     err = 999;
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Incorrect Next Protocol received: (Structures)");
                     break;
                 }
@@ -618,7 +618,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
                 if ((err = protocol(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                                     &data_block, protocolVersion)) != 0) {
-                    addIdamError(CODEERRORTYPE, "idamServer", err,
+                    addIdamError(CODEERRORTYPE, __func__, err,
                                  "Server Side Protocol Error (Opaque Structure Type)");
                     break;
                 }
@@ -636,7 +636,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
         //----------------------------------------------------------------------
         // Complete & Write the Access Log Record
 
-        idamAccessLog(0, client_block, request_block, server_block, pluginlist, getIdamServerEnvironment());
+        udaAccessLog(0, client_block, request_block, server_block, pluginlist, getServerEnvironment());
 
         //----------------------------------------------------------------------------
         // Server Shutdown ? Next Instruction from Client
@@ -653,7 +653,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
         if ((err = protocol(serverInput, protocol_id, XDR_RECEIVE, &next_protocol, logmalloclist, userdefinedtypelist,
                             nullptr, protocolVersion)) != 0) {
             UDA_LOG(UDA_LOG_DEBUG, "Problem #3 Receiving Next Protocol ID\n");
-            addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 3 (Server Shutdown) Error");
+            addIdamError(CODEERRORTYPE, __func__, err, "Protocol 3 (Server Shutdown) Error");
             break;
         }
 
@@ -682,12 +682,12 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
         //----------------------------------------------------------------------------
         // Free Name Value pair
 
-        freeNameValueList(&request_block.nameValueList);
+        free_name_value_list(&request_block.nameValueList);
 
         //----------------------------------------------------------------------------
         // Free PutData Blocks
 
-        freeIdamServerPutDataBlockList(&request_block.putDataBlockList);
+        freeServerPutDataBlockList(&request_block.putDataBlockList);
 
         //----------------------------------------------------------------------------
         // Write the Error Log Record & Free Error Stack Heap
@@ -749,7 +749,7 @@ int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LO
 
     fflush(nullptr);
 
-    idamCloseLogging();
+    udaCloseLogging();
 
     return 0;
 }
diff --git a/source/server/udaLegacyServer.h b/source/server/udaLegacyServer.h
index bbf6f523..74067f29 100755
--- a/source/server/udaLegacyServer.h
+++ b/source/server/udaLegacyServer.h
@@ -1,8 +1,3 @@
-/*---------------------------------------------------------------
-* UDA Legacy Data Server (protocol versions <= 6)
-*
-*---------------------------------------------------------------------------------------------------------------------*/
-
 #ifndef UDA_SERVER_UDALEGACYSERVER_H
 #define UDA_SERVER_UDALEGACYSERVER_H
 
@@ -10,19 +5,17 @@
 #include <structures/genStructs.h>
 #include <clientserver/socketStructs.h>
 #include <plugins/pluginStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-LIBRARY_API int idamLegacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
-                     USERDEFINEDTYPELIST* userdefinedtypelist, SOCKETLIST* socket_list, int protocolVersion);
+/**
+ * UDA Legacy Data Server (protocol versions <= 6)
+ */
+LIBRARY_API int legacyServer(CLIENT_BLOCK client_block, const PLUGINLIST* pluginlist, LOGMALLOCLIST* logmalloclist,
+                             USERDEFINEDTYPELIST* userdefinedtypelist, SOCKETLIST* socket_list, int protocolVersion);
 
 #ifdef __cplusplus
 }
diff --git a/source/server/udaServer.cpp b/source/server/udaServer.cpp
index 9499a484..90792bda 100755
--- a/source/server/udaServer.cpp
+++ b/source/server/udaServer.cpp
@@ -1,5 +1,4 @@
-#include <stdio.h>
-#include <rpc/rpc.h>
+#include <cstdio>
 #if defined(__GNUC__)
 #  include <strings.h>
 #else
@@ -23,7 +22,6 @@
 #include "createXDRStream.h"
 #include "freeIdamPut.h"
 #include "getServerEnvironment.h"
-#include "makeServerRequestBlock.h"
 #include "serverGetData.h"
 #include "serverLegacyPlugin.h"
 #include "serverProcessing.h"
@@ -35,12 +33,7 @@
 #endif
 
 #if defined(SSLAUTHENTICATION) && !defined(FATCLIENT)
-#include <authentication/udaSSL.h>
-#endif
-
-#ifdef NONETCDFPLUGIN
-void ncclose(int fh) {
-}
+#  include <authentication/udaServerSSL.h>
 #endif
 
 //--------------------------------------------------------------------------------------
@@ -192,7 +185,7 @@ int reportToClient(SERVER_BLOCK* server_block, DATA_BLOCK* data_block, CLIENT_BL
     if ((err = protocol2(serverOutput, protocol_id, XDR_SEND, nullptr, logmalloclist, userdefinedtypelist,
                          server_block, protocolVersion)) != 0) {
         UDA_LOG(UDA_LOG_DEBUG, "Problem Sending Server Data Block #2\n");
-        addIdamError(CODEERRORTYPE, "idamServer", err, "Protocol 11 Error (Sending Server Block #2)");
+        addIdamError(CODEERRORTYPE, __func__, err, "Protocol 11 Error (Sending Server Block #2)");
         return err;
     }
 
@@ -622,7 +615,7 @@ int handleRequest(REQUEST_BLOCK* request_block, CLIENT_BLOCK* client_block, SERV
     //----------------------------------------------------------------------
     // Write to the Access Log
 
-    idamAccessLog(TRUE, *client_block, *request_block, *server_block, &pluginList, getIdamServerEnvironment());
+    udaAccessLog(TRUE, *client_block, *request_block, *server_block, &pluginList, getServerEnvironment());
 
     //----------------------------------------------------------------------
     // Initialise Data Structures
@@ -659,12 +652,12 @@ int handleRequest(REQUEST_BLOCK* request_block, CLIENT_BLOCK* client_block, SERV
     // Decide on Authentication procedure
 
     if (protocolVersion >= 6) {
-        if ((err = idamServerPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc,
-                                    &pluginList, getIdamServerEnvironment())) != 0) {
+        if ((err = udaServerPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc,
+                                   &pluginList, getServerEnvironment())) != 0) {
             return err;
         }
     } else {
-        if ((err = idamServerLegacyPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc)) !=
+        if ((err = udaServerLegacyPlugin(request_block, &metadata_block->data_source, &metadata_block->signal_desc)) !=
             0) {
             return err;
         }
@@ -786,7 +779,7 @@ int doServerLoop(REQUEST_BLOCK* request_block, DATA_BLOCK* data_block, CLIENT_BL
         UDA_LOG(UDA_LOG_DEBUG, "Data structures sent to client\n");
         UDA_LOG(UDA_LOG_DEBUG, "Report To Client Error: %d [%d]\n", err, *fatal);
 
-        idamAccessLog(FALSE, *client_block, *request_block, *server_block, &pluginList, getIdamServerEnvironment());
+        udaAccessLog(FALSE, *client_block, *request_block, *server_block, &pluginList, getServerEnvironment());
 
         err = 0;
         next_protocol = PROTOCOL_SLEEP;
@@ -800,7 +793,7 @@ int doServerLoop(REQUEST_BLOCK* request_block, DATA_BLOCK* data_block, CLIENT_BL
         userdefinedtypelist = nullptr;
 
         freeMallocLogList(logmalloclist);
-        free((void*)logmalloclist);
+        free(logmalloclist);
         logmalloclist = nullptr;
 
         UDA_LOG(UDA_LOG_DEBUG, "freeDataBlock\n");
@@ -815,12 +808,12 @@ int doServerLoop(REQUEST_BLOCK* request_block, DATA_BLOCK* data_block, CLIENT_BL
         //----------------------------------------------------------------------------
         // Free Name Value pair
 
-        freeNameValueList(&request_block->nameValueList);
+        free_name_value_list(&request_block->nameValueList);
 
         //----------------------------------------------------------------------------
         // Free PutData Blocks
 
-        freeIdamServerPutDataBlockList(&request_block->putDataBlockList);
+        freeServerPutDataBlockList(&request_block->putDataBlockList);
 
         //----------------------------------------------------------------------------
         // Write the Error Log Record & Free Error Stack Heap
@@ -840,8 +833,6 @@ int doServerLoop(REQUEST_BLOCK* request_block, DATA_BLOCK* data_block, CLIENT_BL
         UDA_LOG(UDA_LOG_DEBUG, "initServerBlock\n");
         initServerBlock(server_block, serverVersion);
 
-        UDA_LOG(UDA_LOG_DEBUG, "At End of Error Trap\n");
-
         //----------------------------------------------------------------------------
         // Server Wait Loop
 
@@ -890,7 +881,7 @@ int doServerClosedown(CLIENT_BLOCK* client_block, REQUEST_BLOCK* request_block,
 
     fflush(nullptr);
 
-    idamCloseLogging();
+    udaCloseLogging();
 
     //----------------------------------------------------------------------------
     // Close the SSL binding and context
@@ -1036,7 +1027,8 @@ int handshakeClient(CLIENT_BLOCK* client_block, SERVER_BLOCK* server_block, int*
     if (client_block->version <= legacyServerVersion) {
         UDA_LOG(UDA_LOG_DEBUG, "Diverting to the Legacy Server\n");
         UDA_LOG(UDA_LOG_DEBUG, "Client protocol %d\n", client_block->version);
-        return idamLegacyServer(*client_block, &pluginList, logmalloclist, userdefinedtypelist, &socket_list, protocolVersion);
+        return legacyServer(*client_block, &pluginList, logmalloclist, userdefinedtypelist, &socket_list,
+                            protocolVersion);
     }
 
     return err;
@@ -1046,7 +1038,6 @@ int startupServer(SERVER_BLOCK* server_block)
 {
     static int socket_list_initialised = 0;
     static int plugin_list_initialised = 0;
-    //static int fileParsed = 0;
 
     //-------------------------------------------------------------------------
     // Create the Server Log Directory: Fatal Error if any Problem Opening a Log?
@@ -1071,7 +1062,9 @@ int startupServer(SERVER_BLOCK* server_block)
     putUdaServerSSLSocket(0);
     
     int err = 0;
-    if ((err = startUdaServerSSL()) != 0) return err;
+    if ((err = startUdaServerSSL()) != 0) {
+        return err;
+    }
 
 #endif
 
@@ -1119,7 +1112,7 @@ int startupServer(SERVER_BLOCK* server_block)
 
     if (!plugin_list_initialised) {
         pluginList.count = 0;
-        initPluginList(&pluginList, getIdamServerEnvironment());
+        initPluginList(&pluginList, getServerEnvironment());
         plugin_list_initialised = 1;
 
         UDA_LOG(UDA_LOG_INFO, "List of Plugins available\n");
diff --git a/source/server/udaServer.h b/source/server/udaServer.h
index 34ec711a..ed30c0cf 100755
--- a/source/server/udaServer.h
+++ b/source/server/udaServer.h
@@ -4,12 +4,7 @@
 #include <plugins/pluginStructs.h>
 #include <clientserver/socketStructs.h>
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/server/writer.cpp b/source/server/writer.cpp
index 8cd8e9d6..c34066c4 100755
--- a/source/server/writer.cpp
+++ b/source/server/writer.cpp
@@ -26,8 +26,8 @@ void updateSelectParms(int fd, fd_set* rfds, struct timeval* tv)
 {
     FD_ZERO(rfds);
     FD_SET(fd, rfds);
-    if (server_tot_block_time <
-        MAXBLOCK) {    // (ms) For the First blocking period have rapid response (clientserver/udaDefines.h == 1000)
+    if (server_tot_block_time < MAXBLOCK) {
+        // (ms) For the First blocking period have rapid response (clientserver/udaDefines.h == 1000)
         tv->tv_sec = 0;
         tv->tv_usec = MIN_BLOCK_TIME;    // minimum wait (1ms)
     } else {
diff --git a/source/server/writer.h b/source/server/writer.h
index 9cc0ddf6..2ecaab1d 100755
--- a/source/server/writer.h
+++ b/source/server/writer.h
@@ -12,15 +12,11 @@
 #  include <sys/select.h>
 #endif
 
+#include <clientserver/export.h>
+
 #define MIN_BLOCK_TIME	1000
 #define MAX_BLOCK_TIME	10000
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 #ifdef __cplusplus
 extern "C" {
 #endif
diff --git a/source/structures/CMakeLists.txt b/source/structures/CMakeLists.txt
index 18dafa8e..e598bcbb 100755
--- a/source/structures/CMakeLists.txt
+++ b/source/structures/CMakeLists.txt
@@ -3,6 +3,12 @@
 
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 ########################################################################################################################
@@ -21,6 +27,8 @@ include_directories(
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 ########################################################################################################################
diff --git a/source/structures/accessors.cpp b/source/structures/accessors.cpp
index 70bb41ab..30a872c0 100755
--- a/source/structures/accessors.cpp
+++ b/source/structures/accessors.cpp
@@ -162,8 +162,8 @@ NTREE* findNTreeStructureComponent2(LOGMALLOCLIST* logmalloclist, NTREE* ntree,
         }
 
         addMalloc(logmalloclist, (void*)targetlist[ntargets - 1], (int)strlen(targetlist[ntargets - 1]) + 1, sizeof(char), "char");
-        for (int i = 0; i < ntargets - 1; i++) free((void*)targetlist[i]);    // Free all others
-        free((void*)targetlist);                    // Free the list
+        for (int i = 0; i < ntargets - 1; i++) free(targetlist[i]);    // Free all others
+        free(targetlist);                    // Free the list
 
         // Search the user defined type definition for the last name - return if an atomic type
 
@@ -241,9 +241,9 @@ NTREE* findNTreeStructure2(LOGMALLOCLIST* logmalloclist, NTREE* ntree, const cha
         addMalloc(logmalloclist, (void*)targetlist[ntargets - 1], (int)strlen(targetlist[ntargets - 1]) + 1, sizeof(char), "char");
         for (int i = 0; i < ntargets - 1; i++) {
             // Free all others
-            free((void*)targetlist[i]);
+            free(targetlist[i]);
         }
-        free((void*)targetlist);     // Free the list
+        free(targetlist);     // Free the list
 
         return child; // Always the last node you look in !
     }
@@ -399,10 +399,10 @@ NTREE* findNTreeStructureDefinition(NTREE* ntree, const char* target)
 
         // Free all entries
         for (int i = 0; i < ntargets; i++) {
-            free((void*)targetlist[i]);
+            free(targetlist[i]);
         }
 
-        free((void*)targetlist);                    // Free the list
+        free(targetlist);                    // Free the list
 
         return child;
     }
diff --git a/source/structures/accessors.h b/source/structures/accessors.h
index 61d687d5..804d7cd1 100755
--- a/source/structures/accessors.h
+++ b/source/structures/accessors.h
@@ -1,13 +1,8 @@
-#ifndef IDAM_STRUCTURES_ACCESSORS_H
-#define IDAM_STRUCTURES_ACCESSORS_H
+#ifndef UDA_STRUCTURES_ACCESSORS_H
+#define UDA_STRUCTURES_ACCESSORS_H
 
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -246,5 +241,4 @@ LIBRARY_API void defineCompoundField(COMPOUNDFIELD* field, const char* type, con
 }
 #endif
 
-#endif // IDAM_STRUCTURES_ACCESSORS_H
-
+#endif // UDA_STRUCTURES_ACCESSORS_H
\ No newline at end of file
diff --git a/source/structures/genStructs.h b/source/structures/genStructs.h
index 2b8ae47e..07a6533c 100755
--- a/source/structures/genStructs.h
+++ b/source/structures/genStructs.h
@@ -4,11 +4,7 @@
 #include <stdlib.h>
 #include <stdint.h>
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/structures/parseIncludeFile.h b/source/structures/parseIncludeFile.h
index 2c7178a1..1c374774 100755
--- a/source/structures/parseIncludeFile.h
+++ b/source/structures/parseIncludeFile.h
@@ -1,13 +1,9 @@
-#ifndef IDAM_STRUCTURES_PARSEINCLUDEFILE_H
-#define IDAM_STRUCTURES_PARSEINCLUDEFILE_H
+#ifndef UDA_STRUCTURES_PARSEINCLUDEFILE_H
+#define UDA_STRUCTURES_PARSEINCLUDEFILE_H
 
 #include "genStructs.h"
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -19,5 +15,5 @@ LIBRARY_API int parseIncludeFile(USERDEFINEDTYPELIST* userdefinedtypelist, const
 }
 #endif
 
-#endif // IDAM_STRUCTURES_PARSEINCLUDEFILE_H
+#endif // UDA_STRUCTURES_PARSEINCLUDEFILE_H
 
diff --git a/source/structures/struct.cpp b/source/structures/struct.cpp
index 2e4e2355..fc60b6e5 100755
--- a/source/structures/struct.cpp
+++ b/source/structures/struct.cpp
@@ -156,7 +156,7 @@ void freeNTreeNode(NTREE* ntree)
         for (int i = 0; i < ntree->branches; i++) {
             freeNTreeNode(ntree->children[i]);
         }
-        free((void*)ntree->children);
+        free(ntree->children);
     }
 }
 
@@ -378,12 +378,12 @@ void printCompoundField(COMPOUNDFIELD str)
         UDA_LOG(UDA_LOG_DEBUG, "shape    : [", str.shape[0]);
         for (int i = 0; i < str.rank; i++) {
             if (i < str.rank - 1) {
-                idamLog(UDA_LOG_DEBUG, "%d,", str.shape[i]);
+                udaLog(UDA_LOG_DEBUG, "%d,", str.shape[i]);
             } else {
-                idamLog(UDA_LOG_DEBUG, "%d", str.shape[i]);
+                udaLog(UDA_LOG_DEBUG, "%d", str.shape[i]);
             }
         }
-        idamLog(UDA_LOG_DEBUG, "]\n");
+        udaLog(UDA_LOG_DEBUG, "]\n");
     }
 }
 
@@ -813,7 +813,7 @@ int dupCountMallocLog(LOGMALLOCLIST* str)
     for (int i = 1; i < sortCount; i++) {
         if (sorted[i] == sorted[i - 1]) dupCount++;
     }
-    free((void*)sorted);
+    free(sorted);
     return dupCount;
 }
 
@@ -826,10 +826,10 @@ void freeMallocLog(LOGMALLOCLIST* str)
     if (str == nullptr) return;
     for (int i = 0; i < str->listcount; i++) {
         if (str->logmalloc[i].freed == 0) {
-            if (str->logmalloc[i].heap != nullptr && str->logmalloc[i].count > 0) free((void*)str->logmalloc[i].heap);
+            if (str->logmalloc[i].heap != nullptr && str->logmalloc[i].count > 0) free(str->logmalloc[i].heap);
             str->logmalloc[i].freed = 1;
             if (str->logmalloc[i].rank > 1 && str->logmalloc[i].shape != nullptr) {
-                free((void*)str->logmalloc[i].shape);
+                free(str->logmalloc[i].shape);
                 str->logmalloc[i].shape = nullptr;
             }
         }
@@ -845,7 +845,7 @@ void freeMallocLogList(LOGMALLOCLIST* str)
     if (str == nullptr) return;
     freeMallocLog(str);
     if (str->logmalloc != nullptr) {
-        free((void*)str->logmalloc);
+        free(str->logmalloc);
     }
     str->logmalloc = nullptr;
     initLogMallocList(str);
@@ -998,7 +998,7 @@ void addStruct(void* heap, const char* type)
 */
 void freeLogStructList()
 {
-    free((void*)logstructlist.logstruct);
+    free(logstructlist.logstruct);
     initLogStructList();
 }
 
@@ -1387,7 +1387,7 @@ int countUserDefinedType(USERDEFINEDTYPELIST* str)
 void freeCompoundField(COMPOUNDFIELD* str)
 {
     if (str == nullptr) return;
-    free((void*)str->shape);
+    free(str->shape);
     str->shape = nullptr;
 }
 
@@ -1402,10 +1402,10 @@ void freeUserDefinedType(USERDEFINEDTYPE* type)
     for (int i = 0; i < type->fieldcount; i++) {
         freeCompoundField(&type->compoundfield[i]);
     }
-    free((void*)type->compoundfield);
+    free(type->compoundfield);
     type->compoundfield = nullptr;
 
-    free((void*)type->image);
+    free(type->image);
     type->image = nullptr;
 }
 
@@ -1428,7 +1428,7 @@ void freeUserDefinedTypeList(USERDEFINEDTYPELIST* userdefinedtypelist)
     for (int i = 0; i < userdefinedtypelist->listCount; i++) {
         freeUserDefinedType(&userdefinedtypelist->userdefinedtype[i]);
     }
-    free((void*)userdefinedtypelist->userdefinedtype);
+    free(userdefinedtypelist->userdefinedtype);
     initUserDefinedTypeList(userdefinedtypelist);
 }
 
@@ -2469,7 +2469,7 @@ char** parseTarget(const char* target, int* ntargets)
         targetlist[0] = buffer;
     }
     if (*ntargets > 1 && buffer != nullptr) {
-        free((void*)buffer);
+        free(buffer);
     }
     return targetlist;
 }
diff --git a/source/structures/struct.h b/source/structures/struct.h
index ba12075b..4031f858 100755
--- a/source/structures/struct.h
+++ b/source/structures/struct.h
@@ -7,17 +7,10 @@
 
 #include <clientserver/udaTypes.h>
 #include <structures/genStructs.h>
+#include <clientserver/export.h>
 
 #ifdef SERVERBUILD
-
 #  include <server/udaServer.h>
-
-#endif
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
 #endif
 
 #ifdef __cplusplus
diff --git a/source/structures/xdrUserDefinedData.h b/source/structures/xdrUserDefinedData.h
index ce8b5bf9..4d82487a 100755
--- a/source/structures/xdrUserDefinedData.h
+++ b/source/structures/xdrUserDefinedData.h
@@ -4,12 +4,7 @@
 #include <rpc/rpc.h>
 
 #include <structures/genStructs.h>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/version.h.in b/source/version.h.in
new file mode 100644
index 00000000..f58fd48b
--- /dev/null
+++ b/source/version.h.in
@@ -0,0 +1,7 @@
+#ifndef UDA_VERSION_H
+#define UDA_VERSION_H
+
+#define UDA_BUILD_VERSION "@PROJECT_VERSION@"
+#define UDA_BUILD_DATE "@BUILD_TIMESTAMP@"
+
+#endif // UDA_VERSION_H
\ No newline at end of file
diff --git a/source/wrappers/c++/CMakeLists.txt b/source/wrappers/c++/CMakeLists.txt
index f2d73d12..86e045d4 100755
--- a/source/wrappers/c++/CMakeLists.txt
+++ b/source/wrappers/c++/CMakeLists.txt
@@ -11,6 +11,12 @@ if( WIN32 OR MINGW )
   if( NOT MINGW )
     find_package( dlfcn-win32 CONFIG REQUIRED )
   endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 set( SRC_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../.. )
@@ -40,6 +46,8 @@ include_directories( ${LIBXML2_INCLUDE_DIR} ${OPENSSL_INCLUDE_DIR} )
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 if( ITER_CI )
@@ -66,6 +74,8 @@ if( WIN32 OR MINGW )
   else()
     set( LINK_LIB ${LINK_LIB} ${XDR_LIBRARIES} ws2_32 dlfcn-win32::dl )
   endif()
+elseif(TIRPC_FOUND)
+  set( LINK_LIB ${LINK_LIB} ${TIRPC_LIBRARIES})
 endif()
 
 add_library( ${LIB_NAME}-static STATIC $<TARGET_OBJECTS:cpp-objects> ${CLIENT_OBJS} )
diff --git a/source/wrappers/c++/array.hpp b/source/wrappers/c++/array.hpp
index ff2fefb5..8a51a605 100755
--- a/source/wrappers/c++/array.hpp
+++ b/source/wrappers/c++/array.hpp
@@ -3,18 +3,16 @@
 
 #include <vector>
 #include <boost/any.hpp>
+#include <clientserver/export.h>
 
 #include "dim.hpp"
 #include "data.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/client.cpp b/source/wrappers/c++/client.cpp
index 2f713da8..5ae56100 100755
--- a/source/wrappers/c++/client.cpp
+++ b/source/wrappers/c++/client.cpp
@@ -138,7 +138,7 @@ const uda::Result& uda::Client::get(const std::string& signalName, const std::st
     auto data = new Result(idamGetAPI(signalName.c_str(), dataSource.c_str()));
 
     if (data->errorCode() != OK) {
-        IDAMERRORSTACK* errorstack = getIdamServerErrorStack();
+        UDA_ERROR_STACK* errorstack = getIdamServerErrorStack();
         std::vector<std::string> backtrace;
         int code = errorstack->nerrors > 0 ? errorstack->idamerror[0].code : 0;
         std::string msg = errorstack->nerrors > 0 ? errorstack->idamerror[0].msg : "";
diff --git a/source/wrappers/c++/client.hpp b/source/wrappers/c++/client.hpp
index 86575732..a75d48f1 100755
--- a/source/wrappers/c++/client.hpp
+++ b/source/wrappers/c++/client.hpp
@@ -4,18 +4,16 @@
 #include <string>
 #include <vector>
 #include <exception>
+#include <clientserver/export.h>
 
 #include "UDA.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #    pragma warning(disable: 4275)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/data.hpp b/source/wrappers/c++/data.hpp
index ed55bde8..fefbc9b0 100755
--- a/source/wrappers/c++/data.hpp
+++ b/source/wrappers/c++/data.hpp
@@ -3,12 +3,7 @@
 
 #include <typeinfo>
 #include <cstddef>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 namespace uda {
 
diff --git a/source/wrappers/c++/dim.hpp b/source/wrappers/c++/dim.hpp
index efbc31c8..8f25c9f3 100755
--- a/source/wrappers/c++/dim.hpp
+++ b/source/wrappers/c++/dim.hpp
@@ -1,19 +1,16 @@
-#ifndef IDAM_WRAPPERS_CPP_DIM_H
-#define IDAM_WRAPPERS_CPP_DIM_H
+#ifndef UDA_WRAPPERS_CPP_DIM_H
+#define UDA_WRAPPERS_CPP_DIM_H
 
 #include <string>
 #include <boost/multi_array/base.hpp>
-
+#include <clientserver/export.h>
 #include "vector.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
@@ -100,4 +97,4 @@ private:
 #  pragma warning(pop)
 #endif
 
-#endif //IDAM_WRAPPERS_CPP_DIM_H
+#endif // UDA_WRAPPERS_CPP_DIM_H
diff --git a/source/wrappers/c++/result.hpp b/source/wrappers/c++/result.hpp
index 65c7cc9a..4ec15f08 100755
--- a/source/wrappers/c++/result.hpp
+++ b/source/wrappers/c++/result.hpp
@@ -6,18 +6,16 @@
 #include <boost/noncopyable.hpp>
 #include <map>
 
+#include <clientserver/export.h>
 #include "dim.hpp"
 #include "treenode.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #    pragma warning(disable: 4275)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/scalar.hpp b/source/wrappers/c++/scalar.hpp
index 9f7a3983..91671aa4 100755
--- a/source/wrappers/c++/scalar.hpp
+++ b/source/wrappers/c++/scalar.hpp
@@ -5,16 +5,14 @@
 #include <typeinfo>
 #include <boost/any.hpp>
 
+#include <clientserver/export.h>
 #include "data.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/signal.hpp b/source/wrappers/c++/signal.hpp
index 8cdf438f..fd3aff1e 100755
--- a/source/wrappers/c++/signal.hpp
+++ b/source/wrappers/c++/signal.hpp
@@ -2,15 +2,13 @@
 #define UDA_WRAPPERS_CPP_SIGNAL_H
 
 #include "array.hpp"
+#include <clientserver/export.h>
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda
diff --git a/source/wrappers/c++/string.hpp b/source/wrappers/c++/string.hpp
index 9130f8ee..499649e5 100755
--- a/source/wrappers/c++/string.hpp
+++ b/source/wrappers/c++/string.hpp
@@ -5,16 +5,14 @@
 #include <typeinfo>
 #include <string>
 
+#include <clientserver/export.h>
 #include "data.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/structdata.hpp b/source/wrappers/c++/structdata.hpp
index 521b82d9..72ec506f 100755
--- a/source/wrappers/c++/structdata.hpp
+++ b/source/wrappers/c++/structdata.hpp
@@ -3,6 +3,9 @@
 
 #include <vector>
 #include <string>
+
+#include <clientserver/export.h>
+
 #ifdef __GNUC__
 #  include <cxxabi.h>
 #else
@@ -10,13 +13,10 @@
 #endif
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/c++/treenode.hpp b/source/wrappers/c++/treenode.hpp
index b6e84816..b3ebfe5c 100755
--- a/source/wrappers/c++/treenode.hpp
+++ b/source/wrappers/c++/treenode.hpp
@@ -5,18 +5,13 @@
 #include <vector>
 
 #include <structures/genStructs.h>
+#include <clientserver/export.h>
 
 #include "scalar.hpp"
 #include "vector.hpp"
 #include "array.hpp"
 #include "structdata.hpp"
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
-
 namespace uda {
 
 class LIBRARY_API TreeNode
diff --git a/source/wrappers/c++/utilities.h b/source/wrappers/c++/utilities.h
index ff75379b..32ddedc1 100755
--- a/source/wrappers/c++/utilities.h
+++ b/source/wrappers/c++/utilities.h
@@ -12,12 +12,7 @@
 #include <blitz/array.h>
 #include "singleValue.h"
 #include <sstream>
-
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 //!  Utility routines
 namespace UtilitiesNs
@@ -36,9 +31,6 @@ namespace UtilitiesNs
 */
 LIBRARY_API SingleValueNs::SingleValue<double> timeAverage(const SingleValueNs::SingleValue<double> timeWindow, const SingleValueNs::SingleValue<double> timePoint, const SingleValueNs::SingleValue<int> index, const blitz::Array<double,1>& times, const blitz::Array<double,1>& values);
 
-
-
-
 //! Assigns the value of an  XML attribute to a SingleValueNs::SingleValue<double> object.
 /*!
   \param DomElement    The Dom element containing the given attribute.
@@ -48,7 +40,6 @@ LIBRARY_API SingleValueNs::SingleValue<double> timeAverage(const SingleValueNs::
 */
 LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::string& attributeName, SingleValueNs::SingleValue<double>& attributeValue);
 
-
 //! Assigns the value of an  XML attribute to a SingleValueNs::SingleValue<int> object.
 /*!
   \param DomElement    The Dom element containing the given attribute.
@@ -58,7 +49,6 @@ LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::str
 */
 LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::string& attributeName, SingleValueNs::SingleValue<int>& attributeValue);
 
-
 //! Assigns the value of an  XML attribute to a blitz::Array<double,1> object.
 /*!
   The routine will first try to
@@ -72,7 +62,6 @@ LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::str
 */
 LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::string& attributeName, blitz::Array<double,1>& attributeValue);
 
-
 //! Assigns the value of an  XML attribute to a blitz::Array<int,1> object.
 /*!
   The routine will first try to
@@ -86,7 +75,6 @@ LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::str
 */
 LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::string& attributeName, blitz::Array<int,1>& attributeValue);
 
-
 //! Assigns the value of an  XML attribute to a blitz::Array<double,2> object.
 /*!
   The routine  will first try to
@@ -100,7 +88,6 @@ LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::str
 */
 LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::string& attributeName, blitz::Array<double,2>& attributeValue);
 
-
 //! Assigns the value of an  XML attribute to a std::string object.
 /*!
   \param DomElement    The Dom element containing the given attribute.
@@ -115,7 +102,6 @@ LIBRARY_API bool getAttributeValue(const QDomElement& domElement, const std::str
   \brief contains global functions.
 */
 
-
 //! get the version of EFIT++ being run
 /*!
   This function returns a string describing the version of EFIT being run. If it is a release,
@@ -135,16 +121,9 @@ LIBRARY_API std::string getEfitVersion();
 */
 LIBRARY_API double getNaN() ;
 
-
-
 //! Function opens an XML file, parses it and returns a reference to the DOM document.
 LIBRARY_API bool openAndParseXmlFile(const std::string& xmlFileName, QDomDocument& domDocument);
 
-
-
-
-
-
 /////////////////////////////////////////////////////////////////////////////
 //
 //  valueToString converts a scalar of any type to a std::string.
@@ -162,8 +141,6 @@ template <class T> std::string valueToString( T value )
     return oss.str();
 }
 
-
-
 /////////////////////////////////////////////////////////////////////////////
 //
 //  convertStringToValue converts a QString or Std::String scalar variable to an integer. There
diff --git a/source/wrappers/c++/vector.hpp b/source/wrappers/c++/vector.hpp
index f0936370..5d8aa573 100755
--- a/source/wrappers/c++/vector.hpp
+++ b/source/wrappers/c++/vector.hpp
@@ -4,18 +4,17 @@
 #include <string>
 #include <vector>
 #include <memory>
+#include <algorithm>
 #include <boost/any.hpp>
 
+#include <clientserver/export.h>
 #include "data.hpp"
 
 #if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
 #  if !defined(__GNUC__)
 #    pragma warning(push)
 #    pragma warning(disable: 4251)
 #  endif
-#else
-#  define LIBRARY_API
 #endif
 
 namespace uda {
diff --git a/source/wrappers/fortran/accAPI_F.c b/source/wrappers/fortran/accAPI_F.c
index 7525ef2d..fd75b3e4 100755
--- a/source/wrappers/fortran/accAPI_F.c
+++ b/source/wrappers/fortran/accAPI_F.c
@@ -56,8 +56,8 @@ extern void idamgetapi_(char* data_object, char* data_source, int* handle, int l
     source[ldata_source] = '\0';
     TrimString(source);
     *handle = idamGetAPI(object, source);
-    free((void*) object);
-    free((void*) source);
+    free( object);
+    free( source);
     return;
 }
 
@@ -85,7 +85,7 @@ extern void idamapi_(char* signal, int* pulno, int* handle, int lsignal)
             if (ftnout != NULL) {
                 fclose(ftnout);
             }
-            free((void*) sig);
+            free( sig);
             return;
         }
         fprintf(ftnout, "Routine: idamAPI\n");
@@ -97,7 +97,7 @@ extern void idamapi_(char* signal, int* pulno, int* handle, int lsignal)
 
     *handle = idamGetAPI(sig, source);
 
-    free((void*) sig);
+    free( sig);
 
     return;
 }
@@ -127,7 +127,7 @@ extern void idampassapi_(char* signal, int* pulno, int* pass, int* handle, int l
             if (ftnout != NULL) {
                 fclose(ftnout);
             }
-            free((void*) sig);
+            free( sig);
             return;
         }
         fprintf(ftnout, "Routine: idamPassAPI\n");
@@ -139,7 +139,7 @@ extern void idampassapi_(char* signal, int* pulno, int* pass, int* handle, int l
 
     *handle = idamGetAPI(sig, source);
 
-    free((void*) sig);
+    free( sig);
 
     return;
 }
@@ -170,7 +170,7 @@ extern void idamgenapi_(char* archive, char* device, char* signal, int* pulno, i
             if (ftnout != NULL) {
                 fclose(ftnout);
             }
-            free((void*) sig);
+            free( sig);
             return;
         }
         fprintf(ftnout, "Routine: idamGenAPI\n");
@@ -181,7 +181,7 @@ extern void idamgenapi_(char* archive, char* device, char* signal, int* pulno, i
 
     *handle = idamGetAPI(sig, source);
 
-    free((void*) sig);
+    free( sig);
 
     return;
 }
@@ -209,9 +209,9 @@ extern void idamfileapi_(char* file, char* signal, char* format, int* handle,
 
     *handle = idamClientFileAPI(p, s, f);
 
-    free((void*) p);
-    free((void*) s);
-    free((void*) f);
+    free( p);
+    free( s);
+    free( f);
 
     return;
 }
@@ -245,8 +245,8 @@ extern void idamida_(char* file, char* signal, int* pulno, int* pass, int* handl
             if (ftnout != NULL) {
                 fclose(ftnout);
             }
-            free((void*) f);
-            free((void*) s);
+            free( f);
+            free( s);
             return;
         }
         fprintf(ftnout, "Routine: idamIDA\n");
@@ -261,8 +261,8 @@ extern void idamida_(char* file, char* signal, int* pulno, int* pass, int* handl
 
     *handle = idamClientAPI(f, s, ps, pno);
 
-    free((void*) f);
-    free((void*) s);
+    free( f);
+    free( s);
 
     return;
 }
@@ -302,9 +302,9 @@ extern void idammds_(char* server, char* tree, char* node, int* treenum, int* ha
                 fflush(ftnout);
                 fclose(ftnout);
             }
-            free((void*) s);
-            free((void*) t);
-            free((void*) n);
+            free( s);
+            free( t);
+            free( n);
             return;
         }
         fprintf(ftnout, "Routine: idamMDS\n");
@@ -319,9 +319,9 @@ extern void idammds_(char* server, char* tree, char* node, int* treenum, int* ha
 
     *handle = idamClientMDS(s, t, n, tnum);
 
-    free((void*) s);
-    free((void*) t);
-    free((void*) n);
+    free( s);
+    free( t);
+    free( n);
 
     return;
 }
@@ -410,7 +410,7 @@ extern void setidamproperty_(char* property, int lproperty)
     s[lproperty] = '\0';
     s = TrimString(s);
     setIdamProperty(s);
-    free((void*) s);
+    free( s);
 }
 
 extern void getidamproperty_(const char* property, int* value, int lproperty)
@@ -429,7 +429,7 @@ extern void resetidamproperty_(char* property, int lproperty)
     s[lproperty] = '\0';
     s = TrimString(s);
     resetIdamProperty(s);
-    free((void*) s);
+    free( s);
 }
 
 extern void resetidamproperties_()
@@ -459,7 +459,7 @@ extern void putidamserver_(char* h, int* port, int lh)
     host[lh] = '\0';
     TrimString(host);
     putIdamServer(host, *port);
-    free((void*) host);
+    free( host);
 }
 
 extern void putidamserverhost_(char* h, int lh)
@@ -469,7 +469,7 @@ extern void putidamserverhost_(char* h, int lh)
     host[lh] = '\0';
     TrimString(host);
     putIdamServerHost(host);
-    free((void*) host);
+    free( host);
 }
 
 extern void putidamserverport_(int* port)
@@ -658,7 +658,7 @@ extern void getidamdatatypeid_(char* t, int* id, int lt)
     type[lt] = '\0';
     TrimString(type);
     *id = getIdamDataTypeId(type);
-    free((void*) type);
+    free( type);
 }
 
 extern void getidamerrormodel_(int* handle, int* model, int* param_n, float* params)
@@ -678,7 +678,7 @@ extern void getidamerrormodelid_(char* m, int* id, int lm)
     model[lm] = '\0';
     TrimString(model);
     *id = getIdamErrorModelId(model);
-    free((void*) model);
+    free( model);
 }
 
 extern void getidamsyntheticdatablock_(int* handle, void* data)
@@ -1196,13 +1196,13 @@ extern void getidamenv_(char* str, int* rc, char* env, int lstr, int lenv)
 
     if (e == NULL) {
         *rc = 1;
-        free((void*) s);
+        free( s);
         return;
     } else {
         strncpy(env, e, lenv - 1);
         env[lenv - 1] = '\0';
     }
-    free((void*) s);
+    free( s);
 }
 
 extern void whereidamami_(void* var, char* loc, int lloc)
diff --git a/source/wrappers/idl/CMakeLists.txt b/source/wrappers/idl/CMakeLists.txt
index b6d961d0..b059873c 100755
--- a/source/wrappers/idl/CMakeLists.txt
+++ b/source/wrappers/idl/CMakeLists.txt
@@ -2,6 +2,18 @@ find_package( IDL REQUIRED )
 find_package( LibXml2 )
 find_package( NetCDF )
 
+if( WIN32 OR MINGW )
+  find_package( XDR REQUIRED )
+  if( NOT MINGW )
+    find_package( dlfcn-win32 CONFIG REQUIRED )
+  endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)    
+  endif()
+endif()
+
 set( LIB_NAME ${PROJECT_NAME}_idl )
 
 set( SRC_FILES idam_dlm.c idamStructs.c )
@@ -11,6 +23,12 @@ include_directories(
   ${IDL_INCLUDES}
 )
 
+if( MINGW OR WIN32 )
+  include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
+endif()
+
 if( FAT_IDL )
   add_definitions( -DFATCLIENT )
 
@@ -69,6 +87,7 @@ endif()
 set( INSTALL_FILES
   getstruct.pro
   getdata.pro
+  getgeomdata.pro
   calluda.pro
   getfile.pro
   gettext.pro
diff --git a/source/wrappers/idl/getdata.pro b/source/wrappers/idl/getdata.pro
index 1ffa7082..302683d1 100755
--- a/source/wrappers/idl/getdata.pro
+++ b/source/wrappers/idl/getdata.pro
@@ -236,16 +236,8 @@ function getdata, namearg, sourcearg, pass=passarg, tlast=tlast, tfirst=tfirst,
   
   ;---------------------------------------------------------------------------------------------------
   ; For geometry database access :
-  ; If signal starts with "GEOM::" or "SIGGEOM::" then use appropriate
-  ; function
-  ind_match = strpos(workname, 'SIGGEOM::')
-  if ind_match eq 0 then begin
-     workname = strlowcase(strmid(workname, strlen('SIGGEOM::')))
-     struct = getgeomsignaldata(workname, worksource, _extra=_extra)
-
-     return, struct
-  endif
-  
+  ; If signal starts with "GEOM::" then use appropriate
+  ; function  
   ind_match = strpos(workname, 'GEOM::')
   if ind_match eq 0 then begin
      workname = strlowcase(strmid(workname, strlen('GEOM::')))
@@ -352,14 +344,14 @@ function getdata, namearg, sourcearg, pass=passarg, tlast=tlast, tfirst=tfirst,
      if(rank eq 1) then begin
         data = string(data)
         stringdata = 1
-    rank = 0 
+        rank = 0 
      endif else begin
         xxnum  = n_elements(data[0,*])
-    xxdata = strarr(xxnum)
-    for i=0, xxnum-1 do xxdata[i] = string(data[*,i])
-    data = xxdata
-    stringdata = 1
-    rank = 0 
+        xxdata = strarr(xxnum)
+        for i=0, xxnum-1 do xxdata[i] = string(data[*,i])
+        data = xxdata
+        stringdata = 1
+        rank = rank-1
      endelse    
   endif   
 
@@ -411,7 +403,7 @@ function getdata, namearg, sourcearg, pass=passarg, tlast=tlast, tfirst=tfirst,
   endif else begin
     order=indgen(rank>1)
     dtype=order+1
-  endelse
+ endelse
 
   if exists(passarg) then begin
     struct={name:workname,          $
@@ -435,12 +427,15 @@ function getdata, namearg, sourcearg, pass=passarg, tlast=tlast, tfirst=tfirst,
   endelse
 
   ;;if stringdata then rank = rank - 1        ; Reduce Rank for string data
-
   for j=0, (rank-1) do begin
+
     i = j 
-    if(stringdata) then i = j+1 else i = j
 
-    ablk=getidamdimdata(header, order[i])    
+    dim_order = order[i]
+;    if(stringdata) then i = j+1 else i = j
+    if (stringdata) then dim_order = dim_order + 1
+
+    ablk=getidamdimdata(header, dim_order)    
     if not_structure(ablk) then begin
       errmsg='Unable to read axis info ['+strtrim(i,2)+']'
       goto, errorcatch
diff --git a/source/wrappers/idl/getgeomdata.pro b/source/wrappers/idl/getgeomdata.pro
new file mode 100644
index 00000000..5afdbe36
--- /dev/null
+++ b/source/wrappers/idl/getgeomdata.pro
@@ -0,0 +1,9 @@
+function getgeomdata, workname, worksource, _extra=_extra
+
+  errmsg = 'MAST-U GEOMETRY PLUGIN IS NOT INSTALLED'
+
+  print, 'GETGEOMDATA: '+errmsg
+
+  return, {erc: -1, errmsg: errmsg}
+
+end
diff --git a/source/wrappers/idl/idamStructs.c b/source/wrappers/idl/idamStructs.c
index 329b1d9a..1dd5f77a 100755
--- a/source/wrappers/idl/idamStructs.c
+++ b/source/wrappers/idl/idamStructs.c
@@ -2410,7 +2410,7 @@ IDL_VPTR IDL_CDECL getidamnodeatomicdata(int argc, IDL_VPTR argv[], char* argk)
                             IDL_StrStore(&idlData[i], &str[offset]);           // Copy each string
                             idlData[i].slen = lstr;                    // Set the fixed string length
                             offset = (i + 1) * length;
-                            free((void*) s);
+                            free( s);
                         }
 
                         if (kw.debug) {
diff --git a/source/wrappers/idl/idam_dlm.c b/source/wrappers/idl/idam_dlm.c
index e0f0e214..5341152e 100755
--- a/source/wrappers/idl/idam_dlm.c
+++ b/source/wrappers/idl/idam_dlm.c
@@ -574,7 +574,7 @@ typedef struct {
 
 void freeMem(UCHAR* memPtr)
 {
-    free((void*)memPtr);
+    free(memPtr);
 }
 
 
@@ -782,17 +782,39 @@ IDL_VPTR IDL_CDECL idamputapi(int argc, IDL_VPTR argv[], char* argk)
             ndims = 1;
         }
 
-        putData.shape = (int*)malloc(ndims * sizeof(int));
+        if (type != IDL_TYP_STRING) {
+            putData.shape = (int*)malloc(ndims * sizeof(int));
 
-        if (putData.rank > 1) {
-            for (int i = 0; i < (int)putData.rank; i++) {
-                // REVERSE dimensions (IDL => C)
-                putData.shape[putData.rank - 1 - i] = (int)argv[1]->value.arr->dim[i];
+            if (putData.rank > 1) {
+                for (int i = 0; i < (int)putData.rank; i++) {
+                    // REVERSE dimensions (IDL => C)
+                    // putData.shape[putData.rank - 1 - i] = (int)argv[1]->value.arr->dim[i];
+                }
+            } else if (putData.rank == 1) {
+                putData.shape[0] = (int)argv[1]->value.arr->dim[0];
+            } else {
+                putData.shape[0] = 1;
             }
-        } else if (putData.rank == 1) {
-            putData.shape[0] = (int)argv[1]->value.arr->dim[0];
         } else {
-            putData.shape[0] = 1;
+
+            if (putData.rank > 1) {
+                fprintf(stdout, "ERROR: String arrays with more than 1 dimension are not supported for putting to the server\n");
+                return (IDL_GettmpLong(-999));
+            }
+
+            putData.shape = (int*)malloc((ndims+1) * sizeof(int));
+
+            for (int i = 0; i < (int)putData.rank; i++) {
+                putData.shape[i] = (int)argv[1]->value.arr->dim[i];
+                if (kw.debug) {
+                    fprintf(stdout, "+++ idamPutAPI +++\n");
+                    fprintf(stdout, "shape %d : %d\n", i, putData.shape[i]);
+                }
+            }
+
+            // initially set second dimension size to 0 : later will set it to max string length
+            putData.shape[putData.rank] = 0;
+            putData.rank = putData.rank + 1;
         }
 
         if (kw.debug) {
@@ -872,22 +894,23 @@ IDL_VPTR IDL_CDECL idamputapi(int argc, IDL_VPTR argv[], char* argk)
 
         if (type == IDL_TYP_STRING) {
             int maxLength = 0;
-            IDL_STRING* sidl = NULL;
-
-            for (int i = 0; i < (int)putData.count; i++) {
-                sidl = (IDL_STRING*)putData.data;
+            IDL_STRING* sidl = (IDL_STRING*) putData.data;
+            int nString = putData.count;
 
-                if (sidl->slen > maxLength) {
-                    maxLength = sidl->slen;
+            for (int i = 0; i < (int)nString; i++) {
+                if (sidl[i].slen > maxLength) {
+                    maxLength = sidl[i].slen;
                 }
             }
 
-            new_string = (char*)malloc(
-                    putData.count * (maxLength + 1) * sizeof(char)); // Block of memory for the strings
+            putData.count = nString * (maxLength+1);
+            putData.shape[putData.rank - 1] = maxLength;
 
-            for (int i = 0; i < (int)putData.count; i++) {
-                sidl = (IDL_STRING*)putData.data;
-                strncpy(&new_string[i * (maxLength + 1)], (char*)sidl->s, sidl->slen); // should be NULL terminated
+            new_string = (char*)malloc(putData.count * sizeof(char)); // Block of memory for the strings
+
+            for (int i = 0; i < (int)nString; i++) {
+                strncpy(&new_string[i * (maxLength + 1)], IDL_STRING_STR(&sidl[i]), sidl[i].slen);
+                new_string[i * (maxLength + 1) + maxLength] = '\0';
             }
 
             putData.data = new_string;
@@ -903,11 +926,11 @@ IDL_VPTR IDL_CDECL idamputapi(int argc, IDL_VPTR argv[], char* argk)
         handle = idamPutAPI(IDL_STRING_STR(&(argv[0]->value.str)), &putData);
 
         //      if (putData.rank >= 1 && putData.shape != NULL) {
-        free((void*)putData.shape);
+        free(putData.shape);
         //}
 
         if (type == IDL_TYP_STRING && new_string != NULL) {
-            free((void*)new_string);
+            free(new_string);
         }
 
     } else if (argc >= 2 && (argv[1]->flags & IDL_V_STRUCT) && argv[1]->type == IDL_TYP_STRUCT) {
@@ -1257,7 +1280,7 @@ IDL_VPTR IDL_CDECL callidam2(int argc, IDL_VPTR argv[], char* argk)
 
     char* signal;
     char source[STRING_LENGTH];
-    int exp_number;
+    int exp_number = 0;
 
     CLIENT_BLOCK cblock = saveIdamProperties();  // preserve the current set of client properties
 
@@ -2987,6 +3010,17 @@ getidamdata(int argc, IDL_VPTR argv[], char* argk)
             psDef = IDL_MakeStruct(NULL, pTagsLong);
             break;
 
+        case UDA_TYPE_LONG64:
+            sout = (IDAM_DOUT*)malloc(sizeof(IDAM_DOUT) + sizeof(long) * ndata);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            memcpy((void*)&sout->data, (void*)getIdamData(sin->handle), (size_t)ndata * sizeof(long));
+            psDef = IDL_MakeStruct(NULL, pTagsLong);
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
             sout = (IDAM_DOUT*)malloc(sizeof(IDAM_DOUT) + sizeof(unsigned short) * ndata);
 
@@ -3023,6 +3057,18 @@ getidamdata(int argc, IDL_VPTR argv[], char* argk)
             psDef = IDL_MakeStruct(NULL, pTagsUnsignedLong);
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+            sout = (IDAM_DOUT*)malloc(sizeof(IDAM_DOUT) + sizeof(unsigned long) * ndata);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            memcpy((void*)&sout->data, (void*)getIdamData(sin->handle),
+                   (size_t)ndata * sizeof(unsigned long));
+            psDef = IDL_MakeStruct(NULL, pTagsUnsignedLong);
+            break;
+
         case UDA_TYPE_CHAR:
             sout = (IDAM_DOUT*)malloc(sizeof(IDAM_DOUT) + sizeof(char) * ndata);
 
@@ -3288,6 +3334,12 @@ getdataarray(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamData(sin->handle), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamData(sin->handle), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
                                             IDL_ARR_INI_ZERO, &idlArray);
@@ -3306,6 +3358,12 @@ getdataarray(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamData(sin->handle), (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamData(sin->handle), (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
                                             IDL_ARR_INI_ZERO, &idlArray);
@@ -3516,6 +3574,12 @@ geterrorarray(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
                                             IDL_ARR_INI_ZERO, &idlArray);
@@ -3534,6 +3598,12 @@ geterrorarray(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
                                             IDL_ARR_INI_ZERO, &idlArray);
@@ -3928,6 +3998,18 @@ getidamdimdata(int argc, IDL_VPTR argv[], char* argk)
             psDef = IDL_MakeStruct(NULL, pTagsLong);
             break;
 
+        case UDA_TYPE_LONG64:
+            sout = (IDAM_DIMOUT*)malloc(sizeof(IDAM_DIMOUT) + sizeof(long) * ndata);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            memcpy((void*)&sout->dim, (void*)getIdamDimData(sin->handle, dimid),
+                   (size_t)ndata * sizeof(long));
+            psDef = IDL_MakeStruct(NULL, pTagsLong);
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
             sout = (IDAM_DIMOUT*)malloc(sizeof(IDAM_DIMOUT) + sizeof(unsigned short) * ndata);
 
@@ -3964,6 +4046,18 @@ getidamdimdata(int argc, IDL_VPTR argv[], char* argk)
             psDef = IDL_MakeStruct(NULL, pTagsUnsignedLong);
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+            sout = (IDAM_DIMOUT*)malloc(sizeof(IDAM_DIMOUT) + sizeof(unsigned long) * ndata);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            memcpy((void*)&sout->dim, (void*)getIdamDimData(sin->handle, dimid),
+                   (size_t)ndata * sizeof(unsigned long));
+            psDef = IDL_MakeStruct(NULL, pTagsUnsignedLong);
+            break;
+
         case UDA_TYPE_CHAR:
             sout = (IDAM_DIMOUT*)malloc(sizeof(IDAM_DIMOUT) + sizeof(char) * ndata);
 
@@ -4225,6 +4319,13 @@ getdimdataarray(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamDimData(sin->handle, dimid), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamDimData(sin->handle, dimid), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -4249,6 +4350,14 @@ getdimdataarray(int argc, IDL_VPTR argv[], char* argk)
                    (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamDimData(sin->handle, dimid),
+                   (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -4661,6 +4770,13 @@ getdatadata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamData(handle), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamData(handle), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -4682,6 +4798,13 @@ getdatadata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamData(handle), (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamData(handle), (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -4765,6 +4888,13 @@ getsyntheticdata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamSyntheticData(handle), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamSyntheticData(handle), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -4786,6 +4916,13 @@ getsyntheticdata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamSyntheticData(handle), (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamSyntheticData(handle), (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -4871,6 +5008,13 @@ getdataerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -4892,6 +5036,13 @@ getdataerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -4979,6 +5130,13 @@ getasymmetricdataerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -5000,6 +5158,13 @@ getasymmetricdataerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)data_n * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -5244,6 +5409,13 @@ getdimdata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamDimData(handle, dimid), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamDimData(handle, dimid), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -5266,6 +5438,13 @@ getdimdata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamDimData(handle, dimid), (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamDimData(handle, dimid), (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -5348,6 +5527,13 @@ getsyntheticdimdata(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)getIdamSyntheticDimData(handle, dimid), (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamSyntheticDimData(handle, dimid), (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -5372,6 +5558,14 @@ getsyntheticdimdata(int argc, IDL_VPTR argv[], char* argk)
                    (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)getIdamSyntheticDimData(handle, dimid),
+                   (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -5455,6 +5649,13 @@ getdimerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -5476,6 +5677,13 @@ getdimerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -5559,6 +5767,13 @@ getasymmetricdimerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
             break;
 
+        case UDA_TYPE_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_LONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(long));
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_UINT, ndims, (IDL_MEMINT*)ilDims,
@@ -5580,6 +5795,13 @@ getasymmetricdimerror(int argc, IDL_VPTR argv[], char* argk)
             memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
             break;
 
+        case UDA_TYPE_UNSIGNED_LONG64:
+
+            dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_ULONG64, ndims, (IDL_MEMINT*)ilDims,
+                                            IDL_ARR_INI_ZERO, &idlArray);
+            memcpy((void*)dvec, (void*)ep, (size_t)ndata * sizeof(unsigned long));
+            break;
+
         case UDA_TYPE_CHAR:
 
             dvec = (char*)IDL_MakeTempArray((int)IDL_TYP_BYTE, ndims, (IDL_MEMINT*)ilDims,
@@ -7686,6 +7908,61 @@ getdomains(int argc, IDL_VPTR argv[], char* argk)
             psDef = IDL_MakeStruct(NULL, pTagsLong);
             break;
 
+        case UDA_TYPE_LONG64:
+
+            if (kw.debug) {
+                fprintf(stdout, "Domains are of Type LONG\n");
+            }
+
+            sout = (DOMAINS*)malloc(sizeof(DOMAINS) + sizeof(long) * dsize + 2 * sizeof(long) * dsize);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            lp1 = (long*)(&sout->sams) + dsize * sizeof(long);
+            lp2 = (long*)(&sout->sams) + dsize * (sizeof(long) + sizeof(long));
+
+            if (dim->udoms == 0 || dim->method < 1 || dim->method > 3) {
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    lp1[i] = (long)0;
+                    lp2[i] = (long)0;
+                }
+            }
+
+            if (dim->method == 1) {
+                memcpy((void*)&sout->sams, (void*)dim->sams, (size_t)dsize * sizeof(long));
+                memcpy((void*)&sout->sams + dsize * sizeof(long), (void*)dim->offs,
+                       (size_t)dsize * sizeof(long));
+                memcpy((void*)&sout->sams + dsize * (sizeof(long) + sizeof(long)), (void*)dim->ints,
+                       (size_t)dsize * sizeof(long));
+            }
+
+            if (dim->method == 2) {
+                memcpy((void*)&sout->sams + dsize * sizeof(long), (void*)dim->offs,
+                       (size_t)dsize * sizeof(long));
+
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    lp2[i] = (long)0;
+                }
+            }
+
+            if (dim->method == 3) {
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    lp1[i] = (long)0;
+                    lp2[i] = (long)0;
+                }
+
+                lp1[0] = (long)*((long*)dim->offs);
+                lp2[0] = (long)*((long*)dim->ints);
+            }
+
+            psDef = IDL_MakeStruct(NULL, pTagsLong);
+            break;
+
         case UDA_TYPE_UNSIGNED_SHORT: {
             unsigned short* p1, * p2;
 
@@ -7857,6 +8134,64 @@ getdomains(int argc, IDL_VPTR argv[], char* argk)
             break;
         }
 
+        case UDA_TYPE_UNSIGNED_LONG64: {
+            unsigned long* p1, * p2;
+
+            if (kw.debug) {
+                fprintf(stdout, "Domains are of Type UNSIGNED LONG\n");
+            }
+
+            sout = (DOMAINS*)malloc(
+                    sizeof(DOMAINS) + sizeof(long) * dsize + 2 * sizeof(unsigned long) * dsize);
+
+            if (sout == NULL) {
+                break;
+            }
+
+            p1 = (unsigned long*)(&sout->sams) + dsize * sizeof(long);
+            p2 = (unsigned long*)(&sout->sams) + dsize * (sizeof(long) + sizeof(unsigned long));
+
+            if (dim->udoms == 0 || dim->method < 1 || dim->method > 3) {
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    p1[i] = (unsigned long)0;
+                    p2[i] = (unsigned long)0;
+                }
+            }
+
+            if (dim->method == 1) {
+                memcpy((void*)&sout->sams, (void*)dim->sams, (size_t)dsize * sizeof(long));
+                memcpy((void*)&sout->sams + dsize * sizeof(long), (void*)dim->offs,
+                       (size_t)dsize * sizeof(unsigned long));
+                memcpy((void*)&sout->sams + dsize * (sizeof(long) + sizeof(unsigned long)), (void*)dim->ints,
+                       (size_t)dsize * sizeof(unsigned long));
+            }
+
+            if (dim->method == 2) {
+                memcpy((void*)&sout->sams + dsize * sizeof(long), (void*)dim->offs,
+                       (size_t)dsize * sizeof(unsigned long));
+
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    p2[i] = (unsigned long)0;
+                }
+            }
+
+            if (dim->method == 3) {
+                for (int i = 0; i < dsize; i++) {
+                    *(sout->sams + i) = (long)0;
+                    p1[i] = (unsigned long)0;
+                    p2[i] = (unsigned long)0;
+                }
+
+                p1[0] = (unsigned long)*((unsigned long*)dim->offs);
+                p2[0] = (unsigned long)*((unsigned long*)dim->ints);
+            }
+
+            psDef = IDL_MakeStruct(NULL, pTagsUnsignedLong);
+            break;
+        }
+
         case UDA_TYPE_CHAR: {
             char* p1, * p2;
 
diff --git a/source/wrappers/java/CMakeLists.txt b/source/wrappers/java/CMakeLists.txt
index 09f30ca6..3a00a5f7 100755
--- a/source/wrappers/java/CMakeLists.txt
+++ b/source/wrappers/java/CMakeLists.txt
@@ -9,6 +9,12 @@ find_package( Java REQUIRED )
 find_package( JNI REQUIRED )
 if( WIN32 OR MINGW )
   find_package( XDR REQUIRED )
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 include( UseJava )
@@ -22,6 +28,8 @@ include_directories(
 
 if( MINGW OR WIN32 )
   include_directories( ${XDR_INCLUDE_DIR} )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
 endif()
 
 add_library( ${LIB_NAME} SHARED idam_jni.c )
diff --git a/source/wrappers/java/idam_jni.c b/source/wrappers/java/idam_jni.c
index 2f430539..3236fd0a 100755
--- a/source/wrappers/java/idam_jni.c
+++ b/source/wrappers/java/idam_jni.c
@@ -340,7 +340,7 @@ JNIEXPORT jfloatArray JNICALL Java_jIdam_Idam_getIdamFloatData(JNIEnv* env, jobj
         float* data = (float*)malloc(dataNum * sizeof(float));
         getIdamFloatData((int)handle, data);
         (*env)->SetFloatArrayRegion(env, ret, 0, dataNum, data);
-        free((void*)data);
+        free(data);
     }
     return ret;
 }
@@ -361,7 +361,7 @@ JNIEXPORT jdoubleArray JNICALL Java_jIdam_Idam_getIdamDoubleData(JNIEnv* env, jo
         double* data = (double*)malloc(dataNum * sizeof(double));
         getIdamDoubleData((int)handle, data);
         (*env)->SetDoubleArrayRegion(env, ret, 0, dataNum, (jdouble*)data);
-        free((void*)data);
+        free(data);
     }
     return ret;
 }
@@ -515,7 +515,7 @@ JNIEXPORT jfloatArray JNICALL Java_jIdam_Idam_getIdamFloatDimData(JNIEnv* env, j
         float* data = (float*)malloc(dataNum * sizeof(float));
         getIdamFloatDimData((int)handle, (int)dimId, data);
         (*env)->SetFloatArrayRegion(env, ret, 0, dataNum, (jfloat*)data);
-        free((void*)data);
+        free(data);
     }
     return ret;
 }
@@ -536,7 +536,7 @@ JNIEXPORT jdoubleArray JNICALL Java_jIdam_Idam_getIdamDoubleDimData(JNIEnv* env,
         double* data = (double*)malloc(dataNum * sizeof(double));
         getIdamDoubleDimData((int)handle, (int)dimId, data);
         (*env)->SetDoubleArrayRegion(env, ret, 0, dataNum, (jdouble*)data);
-        free((void*)data);
+        free(data);
     }
     return ret;
 }
diff --git a/source/wrappers/java/idam_jni.h b/source/wrappers/java/idam_jni.h
index 6303f981..18f9163b 100755
--- a/source/wrappers/java/idam_jni.h
+++ b/source/wrappers/java/idam_jni.h
@@ -5,11 +5,7 @@
 #ifndef _Included_Idam
 #define _Included_Idam
 
-#if defined(_WIN32)
-#  define LIBRARY_API __declspec(dllexport)
-#else
-#  define LIBRARY_API
-#endif
+#include <clientserver/export.h>
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/source/wrappers/python/CMakeLists.txt b/source/wrappers/python/CMakeLists.txt
index 12225452..620bae48 100755
--- a/source/wrappers/python/CMakeLists.txt
+++ b/source/wrappers/python/CMakeLists.txt
@@ -1,15 +1,13 @@
-function( cat IN_FILE OUT_FILE )
-  file( READ ${IN_FILE} CONTENTS )
-  file( APPEND ${OUT_FILE} "${CONTENTS}" )
-endfunction()
-
 file( GLOB CYTHON_FILES pyuda/cpyuda/*.pyx )
 set( CPYTHON_INSTALL_FILE ${CMAKE_CURRENT_BINARY_DIR}/cpyuda.pyx )
 
-file( WRITE ${CPYTHON_INSTALL_FILE} "" )
-foreach( CYTHON_FILE ${CYTHON_FILES} )
-  cat( ${CYTHON_FILE} ${CPYTHON_INSTALL_FILE} )
-endforeach()
+add_custom_target( cpyuda ALL DEPENDS ${CPYTHON_INSTALL_FILE} )
+add_custom_command(
+  OUTPUT ${CPYTHON_INSTALL_FILE}
+  DEPENDS ${CYTHON_FILES}
+  COMMAND cat ${CYTHON_FILES} > ${CPYTHON_INSTALL_FILE}
+  COMMAND ${CMAKE_COMMAND} -E touch ${CPYTHON_INSTALL_FILE}
+)
 
 install( FILES ${CPYTHON_INSTALL_FILE} pyuda/cpyuda/uda.pxd DESTINATION python_installer/pyuda/cpyuda )
 
@@ -17,7 +15,15 @@ file( GLOB INSTALL_FILES pyuda/*.py )
 
 install( FILES ${INSTALL_FILES} DESTINATION python_installer/pyuda )
 
+configure_file( ${CMAKE_CURRENT_LIST_DIR}/pyuda/_version.py.in ${CMAKE_CURRENT_BINARY_DIR}/pyuda/_version.py @ONLY )
+install( FILES ${CMAKE_CURRENT_BINARY_DIR}/pyuda/_version.py DESTINATION python_installer/pyuda )
+
 find_package( OpenSSL REQUIRED )
+find_package( LibMemcached QUIET )
+
+if( LIBMEMCACHED_FOUND )
+  set( EXTRA_LIBS "memcached" )
+endif()
 
 get_filename_component( OPENSSL_LIB_DIR ${OPENSSL_SSL_LIBRARY} DIRECTORY )
 configure_file( ${CMAKE_CURRENT_LIST_DIR}/setup.py.in ${CMAKE_CURRENT_BINARY_DIR}/setup.py @ONLY )
diff --git a/source/wrappers/python/pyuda/__init__.py b/source/wrappers/python/pyuda/__init__.py
index 744e863f..3312982b 100644
--- a/source/wrappers/python/pyuda/__init__.py
+++ b/source/wrappers/python/pyuda/__init__.py
@@ -10,18 +10,15 @@ from ._video import Video
 from ._dim import Dim
 from ._structured import StructuredData
 from ._json import SignalEncoder, SignalDecoder
+from ._version import __version__, __version_info__
 
 
 UDAException = cpyuda.UDAException
 ProtocolException = cpyuda.ProtocolException
 ServerException = cpyuda.ServerException
 InvalidUseException = cpyuda.InvalidUseException
+Properties = cpyuda.Properties
 
 
-# import the enum values PROP_* from the c_uda library into a Properties class
-Properties = type('Properties', (), dict(
-    (p, getattr(cpyuda, p)) for p in dir(cpyuda) if p.startswith('PROP_')
-))
-
 __all__ = (UDAException, ProtocolException, ServerException, InvalidUseException,
            Client, Signal, Video, Dim, Properties, DEBUG, WARNING, INFO, ERROR)
diff --git a/source/wrappers/python/pyuda/_client.py b/source/wrappers/python/pyuda/_client.py
index 23966b40..56fc33f2 100644
--- a/source/wrappers/python/pyuda/_client.py
+++ b/source/wrappers/python/pyuda/_client.py
@@ -6,6 +6,7 @@ from ._signal import Signal
 from ._string import String
 from ._structured import StructuredData
 from ._video import Video
+from ._version import __version__
 
 from six import with_metaclass
 import logging
@@ -41,9 +42,6 @@ class ClientMeta(type):
         cpyuda.set_server_host_name(value)
 
 
-
-
-
 class Client(with_metaclass(ClientMeta, object)):
     """
     A class representing the IDAM client.
@@ -54,6 +52,9 @@ class Client(with_metaclass(ClientMeta, object)):
     __metaclass__ = ClientMeta
 
     def __init__(self, debug_level=logging.ERROR):
+        self.version = __version__
+        assert self.version == cpyuda.get_build_version().decode(), "mismatching pyuda and c-library versions"
+
         logging.basicConfig(level=debug_level)
         self.logger = logging.getLogger(__name__)
 
@@ -63,12 +64,18 @@ class Client(with_metaclass(ClientMeta, object)):
             from mast.geom import GeomClient
             from mast import MastClient
             self._registered_subclients['geometry'] = GeomClient(self)
+            self._registered_subclients['geometry_signal_mapping'] = GeomClient(self)
             self._registered_subclients['get_images'] = MastClient(self)
             self._registered_subclients['get_shot_date_time'] = MastClient(self)
             self._registered_subclients['latest_shot'] = MastClient(self)
+            self._registered_subclients['latest_source_pass'] = MastClient(self)
+            self._registered_subclients['latest_source_pass_in_range'] = MastClient(self)            
             self._registered_subclients['listGeomSignals'] = GeomClient(self)
             self._registered_subclients['listGeomGroups'] = GeomClient(self)
             self._registered_subclients['list'] = MastClient(self)
+            self._registered_subclients['list_archive_files'] = MastClient(self)
+            self._registered_subclients['list_archive_directories'] = MastClient(self)
+            self._registered_subclients['list_file_signals'] = MastClient(self)            
             self._registered_subclients['list_signals'] = MastClient(self)
             self._registered_subclients['put'] = MastClient(self)
         except ImportError:
@@ -127,7 +134,7 @@ class Client(with_metaclass(ClientMeta, object)):
                 return Video(StructuredData(tree))
             else:
                 return StructuredData(tree.children()[0])
-        elif result.is_string():
+        elif result.is_string() and result.rank() <= 1:
             return String(result)
 
         signal = Signal(result)
@@ -150,5 +157,5 @@ class Client(with_metaclass(ClientMeta, object)):
         return cpyuda.get_property(prop)
 
     @classmethod
-    def set_property(cls, prop, value):
+    def set_property(cls, prop, value=None):
         cpyuda.set_property(prop, value)
diff --git a/source/wrappers/python/pyuda/_signal.py b/source/wrappers/python/pyuda/_signal.py
index 1726c81a..20ec900b 100644
--- a/source/wrappers/python/pyuda/_signal.py
+++ b/source/wrappers/python/pyuda/_signal.py
@@ -93,11 +93,17 @@ class Signal(Data):
 
     @property
     def rank(self):
-        return self._cresult.rank()
+        if not self._cresult.is_string():
+            return self._cresult.rank()
+        else:
+            return self._cresult.rank() - 1
 
     @property
     def shape(self):
-        return tuple(self._cresult.shape())
+        if not self._cresult.is_string():
+            return tuple(self._cresult.shape())
+        else:
+            return tuple(self._cresult.shape()[0:-1])
 
     @property
     def dims(self):
@@ -126,9 +132,15 @@ class Signal(Data):
         self._dims = []
 
         if self._dim_order_reversed:
-            trange = range(self._cresult.rank() - 1, -1, -1)
+            if not self._cresult.is_string():
+                trange = range(self._cresult.rank() - 1, -1, -1)
+            else:
+                trange = range(self._cresult.rank() - 1, 0, -1)
         else:
-            trange = range(self._cresult.rank())
+            if not self._cresult.is_string():
+                trange = range(0, self._cresult.rank()+1)
+            else:
+                trange = range(1, self._cresult.rank()+1)
 
         for i in trange:
             self._import_dim(i)
@@ -147,8 +159,11 @@ class Signal(Data):
         else:
             self._time_index = time_order
 
+        if self._cresult.is_string():
+            self._time_index -= 1
+
     def reverse_dimension_order(self):
-        if self._cresult.rank() <= 1:
+        if self.rank <= 1:
             return
 
         self._dim_order_reversed = not self._dim_order_reversed
@@ -164,13 +179,13 @@ class Signal(Data):
         if self._cresult is None or not self._cresult.has_time_dim():
             return
 
-        if self._cresult.rank() <= 1:
+        if self.rank <= 1:
             return
 
-        if self.time_index > 0 and self.time_index < self._cresult.rank() - 1:
+        if self.time_index > 0 and self.time_index < self.rank - 1:
             raise NotImplementedError("Time is neither first nor last dimension so can not be set as first dimension")
 
-        if self.time_index == self._cresult.rank() - 1:
+        if self.time_index == self.rank - 1:
             # This will be time last, so reverse dimensions to set time first
             self.reverse_dimension_order()
 
@@ -178,10 +193,10 @@ class Signal(Data):
         if self._cresult is None or not self._cresult.has_time_dim():
             return
 
-        if self._cresult.rank() <= 1:
+        if self.rank <= 1:
             return
 
-        if self.time_index > 0 and self.time_index < self._cresult.rank() - 1:
+        if self.time_index > 0 and self.time_index < self.rank - 1:
             raise NotImplementedError("Time is neither first nor last dimension so can not be set as last dimension")
 
         if self.time_index == 0:
diff --git a/source/wrappers/python/pyuda/_version.py.in b/source/wrappers/python/pyuda/_version.py.in
new file mode 100644
index 00000000..eeed5c37
--- /dev/null
+++ b/source/wrappers/python/pyuda/_version.py.in
@@ -0,0 +1,2 @@
+__version__ = '@PROJECT_VERSION@'
+__version_info__ = tuple(int(i) for i in __version__.split('.') if i.isdigit())
\ No newline at end of file
diff --git a/source/wrappers/python/pyuda/cpyuda/client.pyx b/source/wrappers/python/pyuda/cpyuda/client.pyx
index dea11090..d7c9126a 100644
--- a/source/wrappers/python/pyuda/cpyuda/client.pyx
+++ b/source/wrappers/python/pyuda/cpyuda/client.pyx
@@ -1,5 +1,6 @@
 #cython: language_level=3
 
+import numpy as np
 cimport uda
 cimport numpy as np
 from libc cimport string
@@ -7,8 +8,37 @@ from libc.stdlib cimport malloc, free
 from libc.string cimport strlen
 
 
+_properties = {
+    "get_datadble": ("GET_DATA_DOUBLE", False),
+    "get_dimdble": ("GET_DIM_DOUBLE", False),
+    "get_timedble": ("GET_TIME_DOUBLE", False),
+    "get_bytes": ("GET_BYTES", False),
+    "get_bad": ("GET_BAD", False),
+    "get_asis": ("GET_AS_IS", False),
+    "get_uncal": ("GET_UNCALIBRATED", False),
+    "get_notoff": ("GET_NOT_OFFSET", False),
+    "get_synthetic": ("GET_SYNTHETIC", False),
+    "get_scalar": ("GET_SCALAR", False),
+    "get_nodimdata": ("GET_NO_DIM_DATA", False),
+    "get_meta": ("META", False),
+    "timeout": ("TIMEOUT", True),
+    "verbose": ("VERBOSE", False),
+    "debug": ("DEBUG", False),
+    "altdata": ("ALT_DATA", True),
+    "altrank": ("ALT_RANK", False),
+    "reuselasthandle": ("REUSE_LAST_HANDLE", False),
+    "freeandreuselasthandle": ("FREE_AND_REUSE_LAST_HANDLE", False),
+    "filecache": ("FILE_CACHE", False),
+}
+
+
+Properties = type('Properties', (), {v[0]:k for k,v in _properties.items()})
+
+
 def set_property(prop_name, value):
-    if prop_name in ('timeout', 'altRank'):
+    if prop_name.lower() not in _properties:
+        raise ValueError('invalid property ' + prop_name)
+    if _properties[prop_name][1]:
         prop_string = prop_name + '=' + str(value)
     else:
         prop_string = prop_name
@@ -16,8 +46,10 @@ def set_property(prop_name, value):
 
 
 def get_property(prop_name):
-    prop = uda.getIdamProperty(prop_name).decode()
-    if prop_name in ('timeout', 'altRank'):
+    if prop_name.lower() not in _properties:
+        raise ValueError('invalid property ' + prop_name)
+    prop = uda.getIdamProperty(prop_name.encode())
+    if _properties[prop_name][1]:
         return prop
     else:
         return bool(prop)
@@ -31,6 +63,14 @@ def get_server_port():
     return uda.getIdamServerPort()
 
 
+def get_build_version():
+    return uda.getUdaBuildVersion()
+
+
+def get_build_date():
+    return uda.getUdaBuildDate()
+
+
 def set_server_host_name(host_name):
     uda.putIdamServerHost(host_name.encode())
 
@@ -112,6 +152,41 @@ numpy2uda_type_map = {
 cdef numpy_type_to_UDA_type(int type):
     return numpy2uda_type_map[type]
 
+cdef put_ndarray_string(const char* instruction, np.ndarray data):
+    cdef int rank = np.PyArray_NDIM(data)
+
+    if rank > 1:
+        raise UDAException("String arrays with more than 1 dimension are not supported for putting to the server")
+
+    cdef uda.PUTDATA_BLOCK put_data
+    uda.initIdamPutDataBlock(&put_data)
+
+    cdef np.npy_intp* shape = np.PyArray_DIMS(data)
+    cdef int size = data.dtype.itemsize
+    cdef int max_str_len = len(max(data, key=len))
+
+    put_data.data_type = UDA_TYPE_STRING
+    put_data.rank = rank + 1
+    put_data.count = np.PyArray_SIZE(data) * (max_str_len + 1)
+    put_data.shape = <int *> malloc((rank + 1) * sizeof(int))
+
+    cdef int i = 0
+    while i < rank:
+        put_data.shape[i] = shape[i]
+        i += 1
+    put_data.shape[rank] = max_str_len
+
+    cdef np.ndarray fixed_len_array = np.zeros(np.PyArray_SIZE(data), dtype='S'+str(max_str_len+1))
+    for sind, s in enumerate(data):
+        fixed_len_array[sind] = s
+
+    put_string = bytearray(fixed_len_array).decode().encode()
+    put_data.data = put_string
+
+    cdef int handle = uda.idamPutAPI(instruction, &put_data)
+    free(put_data.shape)
+    return Result(handle)
+
 
 cdef put_ndarray(const char* instruction, np.ndarray data):
     cdef uda.PUTDATA_BLOCK put_data
@@ -138,6 +213,7 @@ cdef put_ndarray(const char* instruction, np.ndarray data):
 
 cdef put_scalar(const char* instruction, object data):
     cdef uda.PUTDATA_BLOCK put_data
+    uda.initIdamPutDataBlock(&put_data)
 
     cdef np.dtype type = np.PyArray_DescrFromScalar(data)
     cdef char* bytes = <char *> malloc(type.itemsize)
@@ -158,11 +234,11 @@ cdef put_string(const char* instruction, const char* data):
     cdef uda.PUTDATA_BLOCK put_data
     uda.initIdamPutDataBlock(&put_data)
 
-    cdef int len = strlen(data)
+    cdef int string_length = strlen(data)
 
     put_data.data_type = 17 # UDA_TYPE_STRING
     put_data.rank = 0
-    put_data.count = len
+    put_data.count = string_length + 1
     put_data.shape = NULL
     put_data.data = data
 
@@ -172,7 +248,10 @@ cdef put_string(const char* instruction, const char* data):
 
 def put_data(instruction, data=None):
     if isinstance(data, np.ndarray):
-        return put_ndarray(instruction, data)
+        if np.PyArray_TYPE(data) not in (np.NPY_STRING, np.NPY_UNICODE):
+            return put_ndarray(instruction, data)
+        else:
+            return put_ndarray_string(instruction, data)
     elif np.PyArray_CheckScalar(data):
         return put_scalar(instruction, data)
     elif isinstance(data, bytes):
diff --git a/source/wrappers/python/pyuda/cpyuda/result.pyx b/source/wrappers/python/pyuda/cpyuda/result.pyx
index c519ed04..6c3d7fab 100644
--- a/source/wrappers/python/pyuda/cpyuda/result.pyx
+++ b/source/wrappers/python/pyuda/cpyuda/result.pyx
@@ -14,13 +14,14 @@ cdef class Result:
 
     cdef int _handle
     cdef int _is_tree
-    _meta = {}
+    cdef dict _meta   
 
     def __init__(self, int handle):
         self._handle = handle
         self._is_tree = 1 if uda.setIdamDataTree(handle) != 0 else 0
         cdef uda.SIGNAL_DESC* signal_desc
         cdef uda.DATA_SOURCE* source
+        self._meta = {}
         if handle >= 0 and uda.getIdamProperties(handle).get_meta:
             signal_desc = uda.getIdamSignalDesc(handle)
             self._meta["signal_name"] = signal_desc.signal_name
diff --git a/source/wrappers/python/pyuda/cpyuda/types.pyx b/source/wrappers/python/pyuda/cpyuda/types.pyx
index 59a7df44..cf789953 100644
--- a/source/wrappers/python/pyuda/cpyuda/types.pyx
+++ b/source/wrappers/python/pyuda/cpyuda/types.pyx
@@ -64,7 +64,7 @@ cdef object to_python_c(const char* type, int rank, int* shape, int point, void*
     else:
         np_type = uda_field_type_to_numpy_type(type.decode())
         if np_type >= 0:
-            if point:
+            if point and rank == 0:
                 np_shape[0] = shape[0]
                 arr = np.PyArray_SimpleNewFromData(1, np_shape, np_type, data)
                 return arr
@@ -80,9 +80,19 @@ cdef object to_python_c(const char* type, int rank, int* shape, int point, void*
 
 cdef object to_python_i(int type, int rank, np.npy_intp* np_shape, void* data):
     cdef int np_type
-    strings = []
-    if type == 17:
+    cdef np.npy_intp shape[1024]
+
+    if type == 17 and rank <= 1:
         return (<char*>data).decode()
+    elif type == 17 and rank > 1:
+        slen = np_shape[rank-1]
+        for i in range(rank):
+            shape[i] = <np.npy_intp> np_shape[i] 
+
+        arr = np.PyArray_SimpleNewFromData(rank, shape, np.NPY_BYTE, data)
+        arr_bytes = bytearray(arr).decode()
+
+        return np.array([arr_bytes[s:s+slen] for s in range(0, len(arr_bytes), slen)], dtype='U'+repr(slen))
     else:
         np_type = uda_type_to_numpy_type(type)
         if np_type >= 0:
diff --git a/source/wrappers/python/pyuda/cpyuda/uda.pxd b/source/wrappers/python/pyuda/cpyuda/uda.pxd
index 87b39182..c19a1914 100644
--- a/source/wrappers/python/pyuda/cpyuda/uda.pxd
+++ b/source/wrappers/python/pyuda/cpyuda/uda.pxd
@@ -1,6 +1,8 @@
 cdef extern from "client/udaClient.h":
     const char* getIdamServerHost();
     int getIdamServerPort();
+    const char* getUdaBuildVersion();
+    const char* getUdaBuildDate();
 
 cdef extern from "client/udaGetAPI.h":
     int idamGetAPI(const char* data_object, const char* data_source);
diff --git a/source/wrappers/python/setup.py.in b/source/wrappers/python/setup.py.in
index 9fb38e75..ecaebb96 100644
--- a/source/wrappers/python/setup.py.in
+++ b/source/wrappers/python/setup.py.in
@@ -33,7 +33,7 @@ if build_fat:
     extra_macros = [('FATCLIENT', None)]
 else:
     uda_libs = ['lib@PROJECT_NAME@_client.'+stalib_ext]
-    extra_libs = []
+    extra_libs = '@EXTRA_LIBS@'.split(',') if '@EXTRA_LIBS@' else []
     extra_macros = []
 
 ext = Extension(
diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 6622a2c1..cf900390 100755
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -17,6 +17,12 @@ if( WIN32 OR MINGW )
   if( NOT MINGW )
     find_package( dlfcn-win32 CONFIG REQUIRED )
   endif()
+else()
+  find_package( TIRPC QUIET)
+  if(TIRPC_FOUND)
+    add_definitions(-D__TIRPC__)
+    
+      endif()
 endif()
 
 set( FAT_TESTS OFF CACHE BOOL "Build tests using fat-client" )
@@ -65,6 +71,9 @@ if( WIN32 OR MINGW )
   endif()
   include_directories( ${XDR_INCLUDE_DIR} )
   set( LIBRARIES ${XDR_LIBRARIES} ws2_32 )
+elseif(TIRPC_FOUND)
+  include_directories( ${TIRPC_INCLUDE_DIR} )
+  set( LINK_LIB ${LINK_LIB} ${TIRPC_LIBRARIES})
 endif()
 
 set( LINK_DL )
diff --git a/test/testSecurity.c b/test/testSecurity.c
index ad1e2502..9ebfaa10 100755
--- a/test/testSecurity.c
+++ b/test/testSecurity.c
@@ -138,21 +138,21 @@ int main()
         authenticationStep = SERVER_DECRYPT_CLIENT_TOKEN;
 
         if ((err = serverAuthentication(&client_block, &server_block, &logmalloclist, &userdefinedtypelist, authenticationStep)) != 0) {
-            addIdamError(CODEERRORTYPE, "idamServer", err, "Client or Server Authentication Failed #2");
+            addIdamError(CODEERRORTYPE, __func__, err, "Client or Server Authentication Failed #2");
             break;
         }
 
         authenticationStep = SERVER_ENCRYPT_CLIENT_TOKEN;
 
         if ((err = serverAuthentication(&client_block, &server_block, &logmalloclist, &userdefinedtypelist, authenticationStep)) != 0) {
-            addIdamError(CODEERRORTYPE, "idamServer", err, "Client or Server Authentication Failed #3");
+            addIdamError(CODEERRORTYPE, __func__, err, "Client or Server Authentication Failed #3");
             break;
         }
 
         authenticationStep = SERVER_ISSUE_TOKEN;
 
         if ((err = serverAuthentication(&client_block, &server_block, &logmalloclist, &userdefinedtypelist, authenticationStep)) != 0) {
-            addIdamError(CODEERRORTYPE, "idamServer", err, "Client or Server Authentication Failed #4");
+            addIdamError(CODEERRORTYPE, __func__, err, "Client or Server Authentication Failed #4");
             break;
         }
 
@@ -190,7 +190,7 @@ int main()
         authenticationStep = SERVER_VERIFY_TOKEN;
 
         if ((err = serverAuthentication(&client_block, &server_block, &logmalloclist, &userdefinedtypelist, authenticationStep)) != 0) {
-            addIdamError(CODEERRORTYPE, "idamServer", err, "Client or Server Authentication Failed #7");
+            addIdamError(CODEERRORTYPE, __func__, err, "Client or Server Authentication Failed #7");
             break;
         }
 
